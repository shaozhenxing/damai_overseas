/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, callbacks = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				callbacks.push.apply(callbacks, installedChunks[chunkId]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			modules[moduleId] = moreModules[moduleId];
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);
/******/ 		while(callbacks.length)
/******/ 			callbacks.shift().call(null, __webpack_require__);
/******/ 		if(moreModules[0]) {
/******/ 			installedModules[0] = 0;
/******/ 			return __webpack_require__(0);
/******/ 		}
/******/ 	};

/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// object to store loaded and loading chunks
/******/ 	// "0" means "already loaded"
/******/ 	// Array means "loading", array contains callbacks
/******/ 	var installedChunks = {
/******/ 		0:0
/******/ 	};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}

/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId, callback) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return callback.call(null, __webpack_require__);

/******/ 		// an array means "currently loading".
/******/ 		if(installedChunks[chunkId] !== undefined) {
/******/ 			installedChunks[chunkId].push(callback);
/******/ 		} else {
/******/ 			// start chunk loading
/******/ 			installedChunks[chunkId] = [callback];
/******/ 			var head = document.getElementsByTagName('head')[0];
/******/ 			var script = document.createElement('script');
/******/ 			script.type = 'text/javascript';
/******/ 			script.charset = 'utf-8';
/******/ 			script.async = true;

/******/ 			script.src = __webpack_require__.p + "" + chunkId + "._js\\" + ({"1":"index","2":"setting\\index"}[chunkId]||chunkId) + ".js 1.0.0";
/******/ 			head.appendChild(script);
/******/ 		}
/******/ 	};

/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "D:\\Soft\\wamp\\www\\damai\\mobile\\english\\dist";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(24);
	module.exports = __webpack_require__(25);


/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v1.11.3
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-04-28T16:19Z
	 */

	(function( global, factory ) {

	    if ( typeof module === "object" && typeof module.exports === "object" ) {
	        // For CommonJS and CommonJS-like environments where a proper window is present,
	        // execute the factory and get jQuery
	        // For environments that do not inherently posses a window with a document
	        // (such as Node.js), expose a jQuery-making factory as module.exports
	        // This accentuates the need for the creation of a real window
	        // e.g. var jQuery = require("jquery")(window);
	        // See ticket #14549 for more info
	        module.exports = global.document ?
	            factory( global, true ) :
	            function( w ) {
	                if ( !w.document ) {
	                    throw new Error( "jQuery requires a window with a document" );
	                }
	                return factory( w );
	            };
	    } else {
	        factory( global );
	    }

	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Can't do this because several apps including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	// Support: Firefox 18+
	//

	    var deletedIds = [];

	    var slice = deletedIds.slice;

	    var concat = deletedIds.concat;

	    var push = deletedIds.push;

	    var indexOf = deletedIds.indexOf;

	    var class2type = {};

	    var toString = class2type.toString;

	    var hasOwn = class2type.hasOwnProperty;

	    var support = {};



	    var
	        version = "1.11.3",

	    // Define a local copy of jQuery
	        jQuery = function( selector, context ) {
	            // The jQuery object is actually just the init constructor 'enhanced'
	            // Need init if jQuery is called (just allow error to be thrown if not included)
	            return new jQuery.fn.init( selector, context );
	        },

	    // Support: Android<4.1, IE<9
	    // Make sure we trim BOM and NBSP
	        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	    // Matches dashed string for camelizing
	        rmsPrefix = /^-ms-/,
	        rdashAlpha = /-([\da-z])/gi,

	    // Used by jQuery.camelCase as callback to replace()
	        fcamelCase = function( all, letter ) {
	            return letter.toUpperCase();
	        };

	    jQuery.fn = jQuery.prototype = {
	        // The current version of jQuery being used
	        jquery: version,

	        constructor: jQuery,

	        // Start with an empty selector
	        selector: "",

	        // The default length of a jQuery object is 0
	        length: 0,

	        toArray: function() {
	            return slice.call( this );
	        },

	        // Get the Nth element in the matched element set OR
	        // Get the whole matched element set as a clean array
	        get: function( num ) {
	            return num != null ?

	                // Return just the one element from the set
	                ( num < 0 ? this[ num + this.length ] : this[ num ] ) :

	                // Return all the elements in a clean array
	                slice.call( this );
	        },

	        // Take an array of elements and push it onto the stack
	        // (returning the new matched element set)
	        pushStack: function( elems ) {

	            // Build a new jQuery matched element set
	            var ret = jQuery.merge( this.constructor(), elems );

	            // Add the old object onto the stack (as a reference)
	            ret.prevObject = this;
	            ret.context = this.context;

	            // Return the newly-formed element set
	            return ret;
	        },

	        // Execute a callback for every element in the matched set.
	        // (You can seed the arguments with an array of args, but this is
	        // only used internally.)
	        each: function( callback, args ) {
	            return jQuery.each( this, callback, args );
	        },

	        map: function( callback ) {
	            return this.pushStack( jQuery.map(this, function( elem, i ) {
	                return callback.call( elem, i, elem );
	            }));
	        },

	        slice: function() {
	            return this.pushStack( slice.apply( this, arguments ) );
	        },

	        first: function() {
	            return this.eq( 0 );
	        },

	        last: function() {
	            return this.eq( -1 );
	        },

	        eq: function( i ) {
	            var len = this.length,
	                j = +i + ( i < 0 ? len : 0 );
	            return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	        },

	        end: function() {
	            return this.prevObject || this.constructor(null);
	        },

	        // For internal use only.
	        // Behaves like an Array's method, not like a jQuery method.
	        push: push,
	        sort: deletedIds.sort,
	        splice: deletedIds.splice
	    };

	    jQuery.extend = jQuery.fn.extend = function() {
	        var src, copyIsArray, copy, name, options, clone,
	            target = arguments[0] || {},
	            i = 1,
	            length = arguments.length,
	            deep = false;

	        // Handle a deep copy situation
	        if ( typeof target === "boolean" ) {
	            deep = target;

	            // skip the boolean and the target
	            target = arguments[ i ] || {};
	            i++;
	        }

	        // Handle case when target is a string or something (possible in deep copy)
	        if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
	            target = {};
	        }

	        // extend jQuery itself if only one argument is passed
	        if ( i === length ) {
	            target = this;
	            i--;
	        }

	        for ( ; i < length; i++ ) {
	            // Only deal with non-null/undefined values
	            if ( (options = arguments[ i ]) != null ) {
	                // Extend the base object
	                for ( name in options ) {
	                    src = target[ name ];
	                    copy = options[ name ];

	                    // Prevent never-ending loop
	                    if ( target === copy ) {
	                        continue;
	                    }

	                    // Recurse if we're merging plain objects or arrays
	                    if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
	                        if ( copyIsArray ) {
	                            copyIsArray = false;
	                            clone = src && jQuery.isArray(src) ? src : [];

	                        } else {
	                            clone = src && jQuery.isPlainObject(src) ? src : {};
	                        }

	                        // Never move original objects, clone them
	                        target[ name ] = jQuery.extend( deep, clone, copy );

	                        // Don't bring in undefined values
	                    } else if ( copy !== undefined ) {
	                        target[ name ] = copy;
	                    }
	                }
	            }
	        }

	        // Return the modified object
	        return target;
	    };

	    jQuery.extend({
	        // Unique for each copy of jQuery on the page
	        expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	        // Assume jQuery is ready without the ready module
	        isReady: true,

	        error: function( msg ) {
	            throw new Error( msg );
	        },

	        noop: function() {},

	        // See test/unit/core.js for details concerning isFunction.
	        // Since version 1.3, DOM methods and functions like alert
	        // aren't supported. They return false on IE (#2968).
	        isFunction: function( obj ) {
	            return jQuery.type(obj) === "function";
	        },

	        isArray: Array.isArray || function( obj ) {
	            return jQuery.type(obj) === "array";
	        },

	        isWindow: function( obj ) {
	            /* jshint eqeqeq: false */
	            return obj != null && obj == obj.window;
	        },

	        isNumeric: function( obj ) {
	            // parseFloat NaNs numeric-cast false positives (null|true|false|"")
	            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	            // subtraction forces infinities to NaN
	            // adding 1 corrects loss of precision from parseFloat (#15100)
	            return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	        },

	        isEmptyObject: function( obj ) {
	            var name;
	            for ( name in obj ) {
	                return false;
	            }
	            return true;
	        },

	        isPlainObject: function( obj ) {
	            var key;

	            // Must be an Object.
	            // Because of IE, we also have to check the presence of the constructor property.
	            // Make sure that DOM nodes and window objects don't pass through, as well
	            if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
	                return false;
	            }

	            try {
	                // Not own constructor property must be Object
	                if ( obj.constructor &&
	                    !hasOwn.call(obj, "constructor") &&
	                    !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
	                    return false;
	                }
	            } catch ( e ) {
	                // IE8,9 Will throw exceptions on certain host objects #9897
	                return false;
	            }

	            // Support: IE<9
	            // Handle iteration over inherited properties before own properties.
	            if ( support.ownLast ) {
	                for ( key in obj ) {
	                    return hasOwn.call( obj, key );
	                }
	            }

	            // Own properties are enumerated firstly, so to speed up,
	            // if last one is own, then all properties are own.
	            for ( key in obj ) {}

	            return key === undefined || hasOwn.call( obj, key );
	        },

	        type: function( obj ) {
	            if ( obj == null ) {
	                return obj + "";
	            }
	            return typeof obj === "object" || typeof obj === "function" ?
	            class2type[ toString.call(obj) ] || "object" :
	                typeof obj;
	        },

	        // Evaluates a script in a global context
	        // Workarounds based on findings by Jim Driscoll
	        // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	        globalEval: function( data ) {
	            if ( data && jQuery.trim( data ) ) {
	                // We use execScript on Internet Explorer
	                // We use an anonymous function so that context is window
	                // rather than jQuery in Firefox
	                ( window.execScript || function( data ) {
	                    window[ "eval" ].call( window, data );
	                } )( data );
	            }
	        },

	        // Convert dashed to camelCase; used by the css and data modules
	        // Microsoft forgot to hump their vendor prefix (#9572)
	        camelCase: function( string ) {
	            return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	        },

	        nodeName: function( elem, name ) {
	            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	        },

	        // args is for internal usage only
	        each: function( obj, callback, args ) {
	            var value,
	                i = 0,
	                length = obj.length,
	                isArray = isArraylike( obj );

	            if ( args ) {
	                if ( isArray ) {
	                    for ( ; i < length; i++ ) {
	                        value = callback.apply( obj[ i ], args );

	                        if ( value === false ) {
	                            break;
	                        }
	                    }
	                } else {
	                    for ( i in obj ) {
	                        value = callback.apply( obj[ i ], args );

	                        if ( value === false ) {
	                            break;
	                        }
	                    }
	                }

	                // A special, fast, case for the most common use of each
	            } else {
	                if ( isArray ) {
	                    for ( ; i < length; i++ ) {
	                        value = callback.call( obj[ i ], i, obj[ i ] );

	                        if ( value === false ) {
	                            break;
	                        }
	                    }
	                } else {
	                    for ( i in obj ) {
	                        value = callback.call( obj[ i ], i, obj[ i ] );

	                        if ( value === false ) {
	                            break;
	                        }
	                    }
	                }
	            }

	            return obj;
	        },

	        // Support: Android<4.1, IE<9
	        trim: function( text ) {
	            return text == null ?
	                "" :
	                ( text + "" ).replace( rtrim, "" );
	        },

	        // results is for internal usage only
	        makeArray: function( arr, results ) {
	            var ret = results || [];

	            if ( arr != null ) {
	                if ( isArraylike( Object(arr) ) ) {
	                    jQuery.merge( ret,
	                        typeof arr === "string" ?
	                            [ arr ] : arr
	                    );
	                } else {
	                    push.call( ret, arr );
	                }
	            }

	            return ret;
	        },

	        inArray: function( elem, arr, i ) {
	            var len;

	            if ( arr ) {
	                if ( indexOf ) {
	                    return indexOf.call( arr, elem, i );
	                }

	                len = arr.length;
	                i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

	                for ( ; i < len; i++ ) {
	                    // Skip accessing in sparse arrays
	                    if ( i in arr && arr[ i ] === elem ) {
	                        return i;
	                    }
	                }
	            }

	            return -1;
	        },

	        merge: function( first, second ) {
	            var len = +second.length,
	                j = 0,
	                i = first.length;

	            while ( j < len ) {
	                first[ i++ ] = second[ j++ ];
	            }

	            // Support: IE<9
	            // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
	            if ( len !== len ) {
	                while ( second[j] !== undefined ) {
	                    first[ i++ ] = second[ j++ ];
	                }
	            }

	            first.length = i;

	            return first;
	        },

	        grep: function( elems, callback, invert ) {
	            var callbackInverse,
	                matches = [],
	                i = 0,
	                length = elems.length,
	                callbackExpect = !invert;

	            // Go through the array, only saving the items
	            // that pass the validator function
	            for ( ; i < length; i++ ) {
	                callbackInverse = !callback( elems[ i ], i );
	                if ( callbackInverse !== callbackExpect ) {
	                    matches.push( elems[ i ] );
	                }
	            }

	            return matches;
	        },

	        // arg is for internal usage only
	        map: function( elems, callback, arg ) {
	            var value,
	                i = 0,
	                length = elems.length,
	                isArray = isArraylike( elems ),
	                ret = [];

	            // Go through the array, translating each of the items to their new values
	            if ( isArray ) {
	                for ( ; i < length; i++ ) {
	                    value = callback( elems[ i ], i, arg );

	                    if ( value != null ) {
	                        ret.push( value );
	                    }
	                }

	                // Go through every key on the object,
	            } else {
	                for ( i in elems ) {
	                    value = callback( elems[ i ], i, arg );

	                    if ( value != null ) {
	                        ret.push( value );
	                    }
	                }
	            }

	            // Flatten any nested arrays
	            return concat.apply( [], ret );
	        },

	        // A global GUID counter for objects
	        guid: 1,

	        // Bind a function to a context, optionally partially applying any
	        // arguments.
	        proxy: function( fn, context ) {
	            var args, proxy, tmp;

	            if ( typeof context === "string" ) {
	                tmp = fn[ context ];
	                context = fn;
	                fn = tmp;
	            }

	            // Quick check to determine if target is callable, in the spec
	            // this throws a TypeError, but we will just return undefined.
	            if ( !jQuery.isFunction( fn ) ) {
	                return undefined;
	            }

	            // Simulated bind
	            args = slice.call( arguments, 2 );
	            proxy = function() {
	                return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	            };

	            // Set the guid of unique handler to the same of original handler, so it can be removed
	            proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	            return proxy;
	        },

	        now: function() {
	            return +( new Date() );
	        },

	        // jQuery.support is not used in Core but other projects attach their
	        // properties to it so it needs to exist.
	        support: support
	    });

	// Populate the class2type map
	    jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	        class2type[ "[object " + name + "]" ] = name.toLowerCase();
	    });

	    function isArraylike( obj ) {

	        // Support: iOS 8.2 (not reproducible in simulator)
	        // `in` check used to prevent JIT error (gh-2145)
	        // hasOwn isn't used here due to false negatives
	        // regarding Nodelist length in IE
	        var length = "length" in obj && obj.length,
	            type = jQuery.type( obj );

	        if ( type === "function" || jQuery.isWindow( obj ) ) {
	            return false;
	        }

	        if ( obj.nodeType === 1 && length ) {
	            return true;
	        }

	        return type === "array" || length === 0 ||
	            typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	    }
	    var Sizzle =
	        /*!
	         * Sizzle CSS Selector Engine v2.2.0-pre
	         * http://sizzlejs.com/
	         *
	         * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
	         * Released under the MIT license
	         * http://jquery.org/license
	         *
	         * Date: 2014-12-16
	         */
	        (function( window ) {

	            var i,
	                support,
	                Expr,
	                getText,
	                isXML,
	                tokenize,
	                compile,
	                select,
	                outermostContext,
	                sortInput,
	                hasDuplicate,

	            // Local document vars
	                setDocument,
	                document,
	                docElem,
	                documentIsHTML,
	                rbuggyQSA,
	                rbuggyMatches,
	                matches,
	                contains,

	            // Instance-specific data
	                expando = "sizzle" + 1 * new Date(),
	                preferredDoc = window.document,
	                dirruns = 0,
	                done = 0,
	                classCache = createCache(),
	                tokenCache = createCache(),
	                compilerCache = createCache(),
	                sortOrder = function( a, b ) {
	                    if ( a === b ) {
	                        hasDuplicate = true;
	                    }
	                    return 0;
	                },

	            // General-purpose constants
	                MAX_NEGATIVE = 1 << 31,

	            // Instance methods
	                hasOwn = ({}).hasOwnProperty,
	                arr = [],
	                pop = arr.pop,
	                push_native = arr.push,
	                push = arr.push,
	                slice = arr.slice,
	            // Use a stripped-down indexOf as it's faster than native
	            // http://jsperf.com/thor-indexof-vs-for/5
	                indexOf = function( list, elem ) {
	                    var i = 0,
	                        len = list.length;
	                    for ( ; i < len; i++ ) {
	                        if ( list[i] === elem ) {
	                            return i;
	                        }
	                    }
	                    return -1;
	                },

	                booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	            // Regular expressions

	            // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	                whitespace = "[\\x20\\t\\r\\n\\f]",
	            // http://www.w3.org/TR/css3-syntax/#characters
	                characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	            // Loosely modeled on CSS identifier characters
	            // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	            // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	                identifier = characterEncoding.replace( "w", "w#" ),

	            // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	                attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
	                    // Operator (capture 2)
	                    "*([*^$|!~]?=)" + whitespace +
	                    // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
	                    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
	                    "*\\]",

	                pseudos = ":(" + characterEncoding + ")(?:\\((" +
	                    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
	                    // 1. quoted (capture 3; capture 4 or capture 5)
	                    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
	                    // 2. simple (capture 6)
	                    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
	                    // 3. anything else (capture 2)
	                    ".*" +
	                    ")\\)|)",

	            // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	                rwhitespace = new RegExp( whitespace + "+", "g" ),
	                rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	                rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	                rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	                rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	                rpseudo = new RegExp( pseudos ),
	                ridentifier = new RegExp( "^" + identifier + "$" ),

	                matchExpr = {
	                    "ID": new RegExp( "^#(" + characterEncoding + ")" ),
	                    "CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
	                    "TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
	                    "ATTR": new RegExp( "^" + attributes ),
	                    "PSEUDO": new RegExp( "^" + pseudos ),
	                    "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
	                        "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
	                        "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
	                    "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
	                    // For use in libraries implementing .is()
	                    // We use this for POS matching in `select`
	                    "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
	                        whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	                },

	                rinputs = /^(?:input|select|textarea|button)$/i,
	                rheader = /^h\d$/i,

	                rnative = /^[^{]+\{\s*\[native \w/,

	            // Easily-parseable/retrievable ID or TAG or CLASS selectors
	                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	                rsibling = /[+~]/,
	                rescape = /'|\\/g,

	            // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	                runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	                funescape = function( _, escaped, escapedWhitespace ) {
	                    var high = "0x" + escaped - 0x10000;
	                    // NaN means non-codepoint
	                    // Support: Firefox<24
	                    // Workaround erroneous numeric interpretation of +"0x"
	                    return high !== high || escapedWhitespace ?
	                        escaped :
	                        high < 0 ?
	                            // BMP codepoint
	                            String.fromCharCode( high + 0x10000 ) :
	                            // Supplemental Plane codepoint (surrogate pair)
	                            String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	                },

	            // Used for iframes
	            // See setDocument()
	            // Removing the function wrapper causes a "Permission Denied"
	            // error in IE
	                unloadHandler = function() {
	                    setDocument();
	                };

	// Optimize for push.apply( _, NodeList )
	            try {
	                push.apply(
	                    (arr = slice.call( preferredDoc.childNodes )),
	                    preferredDoc.childNodes
	                );
	                // Support: Android<4.0
	                // Detect silently failing push.apply
	                arr[ preferredDoc.childNodes.length ].nodeType;
	            } catch ( e ) {
	                push = { apply: arr.length ?

	                    // Leverage slice if possible
	                    function( target, els ) {
	                        push_native.apply( target, slice.call(els) );
	                    } :

	                    // Support: IE<9
	                    // Otherwise append directly
	                    function( target, els ) {
	                        var j = target.length,
	                            i = 0;
	                        // Can't trust NodeList.length
	                        while ( (target[j++] = els[i++]) ) {}
	                        target.length = j - 1;
	                    }
	                };
	            }

	            function Sizzle( selector, context, results, seed ) {
	                var match, elem, m, nodeType,
	                // QSA vars
	                    i, groups, old, nid, newContext, newSelector;

	                if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
	                    setDocument( context );
	                }

	                context = context || document;
	                results = results || [];
	                nodeType = context.nodeType;

	                if ( typeof selector !== "string" || !selector ||
	                    nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

	                    return results;
	                }

	                if ( !seed && documentIsHTML ) {

	                    // Try to shortcut find operations when possible (e.g., not under DocumentFragment)
	                    if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
	                        // Speed-up: Sizzle("#ID")
	                        if ( (m = match[1]) ) {
	                            if ( nodeType === 9 ) {
	                                elem = context.getElementById( m );
	                                // Check parentNode to catch when Blackberry 4.6 returns
	                                // nodes that are no longer in the document (jQuery #6963)
	                                if ( elem && elem.parentNode ) {
	                                    // Handle the case where IE, Opera, and Webkit return items
	                                    // by name instead of ID
	                                    if ( elem.id === m ) {
	                                        results.push( elem );
	                                        return results;
	                                    }
	                                } else {
	                                    return results;
	                                }
	                            } else {
	                                // Context is not a document
	                                if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
	                                    contains( context, elem ) && elem.id === m ) {
	                                    results.push( elem );
	                                    return results;
	                                }
	                            }

	                            // Speed-up: Sizzle("TAG")
	                        } else if ( match[2] ) {
	                            push.apply( results, context.getElementsByTagName( selector ) );
	                            return results;

	                            // Speed-up: Sizzle(".CLASS")
	                        } else if ( (m = match[3]) && support.getElementsByClassName ) {
	                            push.apply( results, context.getElementsByClassName( m ) );
	                            return results;
	                        }
	                    }

	                    // QSA path
	                    if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
	                        nid = old = expando;
	                        newContext = context;
	                        newSelector = nodeType !== 1 && selector;

	                        // qSA works strangely on Element-rooted queries
	                        // We can work around this by specifying an extra ID on the root
	                        // and working up from there (Thanks to Andrew Dupont for the technique)
	                        // IE 8 doesn't work on object elements
	                        if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
	                            groups = tokenize( selector );

	                            if ( (old = context.getAttribute("id")) ) {
	                                nid = old.replace( rescape, "\\$&" );
	                            } else {
	                                context.setAttribute( "id", nid );
	                            }
	                            nid = "[id='" + nid + "'] ";

	                            i = groups.length;
	                            while ( i-- ) {
	                                groups[i] = nid + toSelector( groups[i] );
	                            }
	                            newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
	                            newSelector = groups.join(",");
	                        }

	                        if ( newSelector ) {
	                            try {
	                                push.apply( results,
	                                    newContext.querySelectorAll( newSelector )
	                                );
	                                return results;
	                            } catch(qsaError) {
	                            } finally {
	                                if ( !old ) {
	                                    context.removeAttribute("id");
	                                }
	                            }
	                        }
	                    }
	                }

	                // All others
	                return select( selector.replace( rtrim, "$1" ), context, results, seed );
	            }

	            /**
	             * Create key-value caches of limited size
	             * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
	             *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	             *	deleting the oldest entry
	             */
	            function createCache() {
	                var keys = [];

	                function cache( key, value ) {
	                    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
	                    if ( keys.push( key + " " ) > Expr.cacheLength ) {
	                        // Only keep the most recent entries
	                        delete cache[ keys.shift() ];
	                    }
	                    return (cache[ key + " " ] = value);
	                }
	                return cache;
	            }

	            /**
	             * Mark a function for special use by Sizzle
	             * @param {Function} fn The function to mark
	             */
	            function markFunction( fn ) {
	                fn[ expando ] = true;
	                return fn;
	            }

	            /**
	             * Support testing using an element
	             * @param {Function} fn Passed the created div and expects a boolean result
	             */
	            function assert( fn ) {
	                var div = document.createElement("div");

	                try {
	                    return !!fn( div );
	                } catch (e) {
	                    return false;
	                } finally {
	                    // Remove from its parent by default
	                    if ( div.parentNode ) {
	                        div.parentNode.removeChild( div );
	                    }
	                    // release memory in IE
	                    div = null;
	                }
	            }

	            /**
	             * Adds the same handler for all of the specified attrs
	             * @param {String} attrs Pipe-separated list of attributes
	             * @param {Function} handler The method that will be applied
	             */
	            function addHandle( attrs, handler ) {
	                var arr = attrs.split("|"),
	                    i = attrs.length;

	                while ( i-- ) {
	                    Expr.attrHandle[ arr[i] ] = handler;
	                }
	            }

	            /**
	             * Checks document order of two siblings
	             * @param {Element} a
	             * @param {Element} b
	             * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	             */
	            function siblingCheck( a, b ) {
	                var cur = b && a,
	                    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
	                        ( ~b.sourceIndex || MAX_NEGATIVE ) -
	                        ( ~a.sourceIndex || MAX_NEGATIVE );

	                // Use IE sourceIndex if available on both nodes
	                if ( diff ) {
	                    return diff;
	                }

	                // Check if b follows a
	                if ( cur ) {
	                    while ( (cur = cur.nextSibling) ) {
	                        if ( cur === b ) {
	                            return -1;
	                        }
	                    }
	                }

	                return a ? 1 : -1;
	            }

	            /**
	             * Returns a function to use in pseudos for input types
	             * @param {String} type
	             */
	            function createInputPseudo( type ) {
	                return function( elem ) {
	                    var name = elem.nodeName.toLowerCase();
	                    return name === "input" && elem.type === type;
	                };
	            }

	            /**
	             * Returns a function to use in pseudos for buttons
	             * @param {String} type
	             */
	            function createButtonPseudo( type ) {
	                return function( elem ) {
	                    var name = elem.nodeName.toLowerCase();
	                    return (name === "input" || name === "button") && elem.type === type;
	                };
	            }

	            /**
	             * Returns a function to use in pseudos for positionals
	             * @param {Function} fn
	             */
	            function createPositionalPseudo( fn ) {
	                return markFunction(function( argument ) {
	                    argument = +argument;
	                    return markFunction(function( seed, matches ) {
	                        var j,
	                            matchIndexes = fn( [], seed.length, argument ),
	                            i = matchIndexes.length;

	                        // Match elements found at the specified indexes
	                        while ( i-- ) {
	                            if ( seed[ (j = matchIndexes[i]) ] ) {
	                                seed[j] = !(matches[j] = seed[j]);
	                            }
	                        }
	                    });
	                });
	            }

	            /**
	             * Checks a node for validity as a Sizzle context
	             * @param {Element|Object=} context
	             * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	             */
	            function testContext( context ) {
	                return context && typeof context.getElementsByTagName !== "undefined" && context;
	            }

	// Expose support vars for convenience
	            support = Sizzle.support = {};

	            /**
	             * Detects XML nodes
	             * @param {Element|Object} elem An element or a document
	             * @returns {Boolean} True iff elem is a non-HTML XML node
	             */
	            isXML = Sizzle.isXML = function( elem ) {
	                // documentElement is verified for cases where it doesn't yet exist
	                // (such as loading iframes in IE - #4833)
	                var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	                return documentElement ? documentElement.nodeName !== "HTML" : false;
	            };

	            /**
	             * Sets document-related variables once based on the current document
	             * @param {Element|Object} [doc] An element or document object to use to set the document
	             * @returns {Object} Returns the current document
	             */
	            setDocument = Sizzle.setDocument = function( node ) {
	                var hasCompare, parent,
	                    doc = node ? node.ownerDocument || node : preferredDoc;

	                // If no document and documentElement is available, return
	                if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
	                    return document;
	                }

	                // Set our document
	                document = doc;
	                docElem = doc.documentElement;
	                parent = doc.defaultView;

	                // Support: IE>8
	                // If iframe document is assigned to "document" variable and if iframe has been reloaded,
	                // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	                // IE6-8 do not support the defaultView property so parent will be undefined
	                if ( parent && parent !== parent.top ) {
	                    // IE11 does not have attachEvent, so all must suffer
	                    if ( parent.addEventListener ) {
	                        parent.addEventListener( "unload", unloadHandler, false );
	                    } else if ( parent.attachEvent ) {
	                        parent.attachEvent( "onunload", unloadHandler );
	                    }
	                }

	                /* Support tests
	                 ---------------------------------------------------------------------- */
	                documentIsHTML = !isXML( doc );

	                /* Attributes
	                 ---------------------------------------------------------------------- */

	                // Support: IE<8
	                // Verify that getAttribute really returns attributes and not properties
	                // (excepting IE8 booleans)
	                support.attributes = assert(function( div ) {
	                    div.className = "i";
	                    return !div.getAttribute("className");
	                });

	                /* getElement(s)By*
	                 ---------------------------------------------------------------------- */

	                // Check if getElementsByTagName("*") returns only elements
	                support.getElementsByTagName = assert(function( div ) {
	                    div.appendChild( doc.createComment("") );
	                    return !div.getElementsByTagName("*").length;
	                });

	                // Support: IE<9
	                support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	                // Support: IE<10
	                // Check if getElementById returns elements by name
	                // The broken getElementById methods don't pick up programatically-set names,
	                // so use a roundabout getElementsByName test
	                support.getById = assert(function( div ) {
	                    docElem.appendChild( div ).id = expando;
	                    return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	                });

	                // ID find and filter
	                if ( support.getById ) {
	                    Expr.find["ID"] = function( id, context ) {
	                        if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
	                            var m = context.getElementById( id );
	                            // Check parentNode to catch when Blackberry 4.6 returns
	                            // nodes that are no longer in the document #6963
	                            return m && m.parentNode ? [ m ] : [];
	                        }
	                    };
	                    Expr.filter["ID"] = function( id ) {
	                        var attrId = id.replace( runescape, funescape );
	                        return function( elem ) {
	                            return elem.getAttribute("id") === attrId;
	                        };
	                    };
	                } else {
	                    // Support: IE6/7
	                    // getElementById is not reliable as a find shortcut
	                    delete Expr.find["ID"];

	                    Expr.filter["ID"] =  function( id ) {
	                        var attrId = id.replace( runescape, funescape );
	                        return function( elem ) {
	                            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
	                            return node && node.value === attrId;
	                        };
	                    };
	                }

	                // Tag
	                Expr.find["TAG"] = support.getElementsByTagName ?
	                    function( tag, context ) {
	                        if ( typeof context.getElementsByTagName !== "undefined" ) {
	                            return context.getElementsByTagName( tag );

	                            // DocumentFragment nodes don't have gEBTN
	                        } else if ( support.qsa ) {
	                            return context.querySelectorAll( tag );
	                        }
	                    } :

	                    function( tag, context ) {
	                        var elem,
	                            tmp = [],
	                            i = 0,
	                        // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
	                            results = context.getElementsByTagName( tag );

	                        // Filter out possible comments
	                        if ( tag === "*" ) {
	                            while ( (elem = results[i++]) ) {
	                                if ( elem.nodeType === 1 ) {
	                                    tmp.push( elem );
	                                }
	                            }

	                            return tmp;
	                        }
	                        return results;
	                    };

	                // Class
	                Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
	                        if ( documentIsHTML ) {
	                            return context.getElementsByClassName( className );
	                        }
	                    };

	                /* QSA/matchesSelector
	                 ---------------------------------------------------------------------- */

	                // QSA and matchesSelector support

	                // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	                rbuggyMatches = [];

	                // qSa(:focus) reports false when true (Chrome 21)
	                // We allow this because of a bug in IE8/9 that throws an error
	                // whenever `document.activeElement` is accessed on an iframe
	                // So, we allow :focus to pass through QSA all the time to avoid the IE error
	                // See http://bugs.jquery.com/ticket/13378
	                rbuggyQSA = [];

	                if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
	                    // Build QSA regex
	                    // Regex strategy adopted from Diego Perini
	                    assert(function( div ) {
	                        // Select is set to empty string on purpose
	                        // This is to test IE's treatment of not explicitly
	                        // setting a boolean content attribute,
	                        // since its presence should be enough
	                        // http://bugs.jquery.com/ticket/12359
	                        docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
	                            "<select id='" + expando + "-\f]' msallowcapture=''>" +
	                            "<option selected=''></option></select>";

	                        // Support: IE8, Opera 11-12.16
	                        // Nothing should be selected when empty strings follow ^= or $= or *=
	                        // The test attribute must be unknown in Opera but "safe" for WinRT
	                        // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
	                        if ( div.querySelectorAll("[msallowcapture^='']").length ) {
	                            rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
	                        }

	                        // Support: IE8
	                        // Boolean attributes and "value" are not treated correctly
	                        if ( !div.querySelectorAll("[selected]").length ) {
	                            rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
	                        }

	                        // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
	                        if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
	                            rbuggyQSA.push("~=");
	                        }

	                        // Webkit/Opera - :checked should return selected option elements
	                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
	                        // IE8 throws error here and will not see later tests
	                        if ( !div.querySelectorAll(":checked").length ) {
	                            rbuggyQSA.push(":checked");
	                        }

	                        // Support: Safari 8+, iOS 8+
	                        // https://bugs.webkit.org/show_bug.cgi?id=136851
	                        // In-page `selector#id sibing-combinator selector` fails
	                        if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
	                            rbuggyQSA.push(".#.+[+~]");
	                        }
	                    });

	                    assert(function( div ) {
	                        // Support: Windows 8 Native Apps
	                        // The type and name attributes are restricted during .innerHTML assignment
	                        var input = doc.createElement("input");
	                        input.setAttribute( "type", "hidden" );
	                        div.appendChild( input ).setAttribute( "name", "D" );

	                        // Support: IE8
	                        // Enforce case-sensitivity of name attribute
	                        if ( div.querySelectorAll("[name=d]").length ) {
	                            rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
	                        }

	                        // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
	                        // IE8 throws error here and will not see later tests
	                        if ( !div.querySelectorAll(":enabled").length ) {
	                            rbuggyQSA.push( ":enabled", ":disabled" );
	                        }

	                        // Opera 10-11 does not throw on post-comma invalid pseudos
	                        div.querySelectorAll("*,:x");
	                        rbuggyQSA.push(",.*:");
	                    });
	                }

	                if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
	                        docElem.webkitMatchesSelector ||
	                        docElem.mozMatchesSelector ||
	                        docElem.oMatchesSelector ||
	                        docElem.msMatchesSelector) )) ) {

	                    assert(function( div ) {
	                        // Check to see if it's possible to do matchesSelector
	                        // on a disconnected node (IE 9)
	                        support.disconnectedMatch = matches.call( div, "div" );

	                        // This should fail with an exception
	                        // Gecko does not error, returns false instead
	                        matches.call( div, "[s!='']:x" );
	                        rbuggyMatches.push( "!=", pseudos );
	                    });
	                }

	                rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	                rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	                /* Contains
	                 ---------------------------------------------------------------------- */
	                hasCompare = rnative.test( docElem.compareDocumentPosition );

	                // Element contains another
	                // Purposefully does not implement inclusive descendent
	                // As in, an element does not contain itself
	                contains = hasCompare || rnative.test( docElem.contains ) ?
	                    function( a, b ) {
	                        var adown = a.nodeType === 9 ? a.documentElement : a,
	                            bup = b && b.parentNode;
	                        return a === bup || !!( bup && bup.nodeType === 1 && (
	                                adown.contains ?
	                                    adown.contains( bup ) :
	                                a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	                            ));
	                    } :
	                    function( a, b ) {
	                        if ( b ) {
	                            while ( (b = b.parentNode) ) {
	                                if ( b === a ) {
	                                    return true;
	                                }
	                            }
	                        }
	                        return false;
	                    };

	                /* Sorting
	                 ---------------------------------------------------------------------- */

	                // Document order sorting
	                sortOrder = hasCompare ?
	                    function( a, b ) {

	                        // Flag for duplicate removal
	                        if ( a === b ) {
	                            hasDuplicate = true;
	                            return 0;
	                        }

	                        // Sort on method existence if only one input has compareDocumentPosition
	                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
	                        if ( compare ) {
	                            return compare;
	                        }

	                        // Calculate position if both inputs belong to the same document
	                        compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
	                            a.compareDocumentPosition( b ) :

	                            // Otherwise we know they are disconnected
	                            1;

	                        // Disconnected nodes
	                        if ( compare & 1 ||
	                            (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

	                            // Choose the first element that is related to our preferred document
	                            if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
	                                return -1;
	                            }
	                            if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
	                                return 1;
	                            }

	                            // Maintain original order
	                            return sortInput ?
	                                ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
	                                0;
	                        }

	                        return compare & 4 ? -1 : 1;
	                    } :
	                    function( a, b ) {
	                        // Exit early if the nodes are identical
	                        if ( a === b ) {
	                            hasDuplicate = true;
	                            return 0;
	                        }

	                        var cur,
	                            i = 0,
	                            aup = a.parentNode,
	                            bup = b.parentNode,
	                            ap = [ a ],
	                            bp = [ b ];

	                        // Parentless nodes are either documents or disconnected
	                        if ( !aup || !bup ) {
	                            return a === doc ? -1 :
	                                b === doc ? 1 :
	                                    aup ? -1 :
	                                        bup ? 1 :
	                                            sortInput ?
	                                                ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
	                                                0;

	                            // If the nodes are siblings, we can do a quick check
	                        } else if ( aup === bup ) {
	                            return siblingCheck( a, b );
	                        }

	                        // Otherwise we need full lists of their ancestors for comparison
	                        cur = a;
	                        while ( (cur = cur.parentNode) ) {
	                            ap.unshift( cur );
	                        }
	                        cur = b;
	                        while ( (cur = cur.parentNode) ) {
	                            bp.unshift( cur );
	                        }

	                        // Walk down the tree looking for a discrepancy
	                        while ( ap[i] === bp[i] ) {
	                            i++;
	                        }

	                        return i ?
	                            // Do a sibling check if the nodes have a common ancestor
	                            siblingCheck( ap[i], bp[i] ) :

	                            // Otherwise nodes in our document sort first
	                            ap[i] === preferredDoc ? -1 :
	                                bp[i] === preferredDoc ? 1 :
	                                    0;
	                    };

	                return doc;
	            };

	            Sizzle.matches = function( expr, elements ) {
	                return Sizzle( expr, null, null, elements );
	            };

	            Sizzle.matchesSelector = function( elem, expr ) {
	                // Set document vars if needed
	                if ( ( elem.ownerDocument || elem ) !== document ) {
	                    setDocument( elem );
	                }

	                // Make sure that attribute selectors are quoted
	                expr = expr.replace( rattributeQuotes, "='$1']" );

	                if ( support.matchesSelector && documentIsHTML &&
	                    ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
	                    ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

	                    try {
	                        var ret = matches.call( elem, expr );

	                        // IE 9's matchesSelector returns false on disconnected nodes
	                        if ( ret || support.disconnectedMatch ||
	                            // As well, disconnected nodes are said to be in a document
	                            // fragment in IE 9
	                            elem.document && elem.document.nodeType !== 11 ) {
	                            return ret;
	                        }
	                    } catch (e) {}
	                }

	                return Sizzle( expr, document, null, [ elem ] ).length > 0;
	            };

	            Sizzle.contains = function( context, elem ) {
	                // Set document vars if needed
	                if ( ( context.ownerDocument || context ) !== document ) {
	                    setDocument( context );
	                }
	                return contains( context, elem );
	            };

	            Sizzle.attr = function( elem, name ) {
	                // Set document vars if needed
	                if ( ( elem.ownerDocument || elem ) !== document ) {
	                    setDocument( elem );
	                }

	                var fn = Expr.attrHandle[ name.toLowerCase() ],
	                // Don't get fooled by Object.prototype properties (jQuery #13807)
	                    val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
	                        fn( elem, name, !documentIsHTML ) :
	                        undefined;

	                return val !== undefined ?
	                    val :
	                    support.attributes || !documentIsHTML ?
	                        elem.getAttribute( name ) :
	                        (val = elem.getAttributeNode(name)) && val.specified ?
	                            val.value :
	                            null;
	            };

	            Sizzle.error = function( msg ) {
	                throw new Error( "Syntax error, unrecognized expression: " + msg );
	            };

	            /**
	             * Document sorting and removing duplicates
	             * @param {ArrayLike} results
	             */
	            Sizzle.uniqueSort = function( results ) {
	                var elem,
	                    duplicates = [],
	                    j = 0,
	                    i = 0;

	                // Unless we *know* we can detect duplicates, assume their presence
	                hasDuplicate = !support.detectDuplicates;
	                sortInput = !support.sortStable && results.slice( 0 );
	                results.sort( sortOrder );

	                if ( hasDuplicate ) {
	                    while ( (elem = results[i++]) ) {
	                        if ( elem === results[ i ] ) {
	                            j = duplicates.push( i );
	                        }
	                    }
	                    while ( j-- ) {
	                        results.splice( duplicates[ j ], 1 );
	                    }
	                }

	                // Clear input after sorting to release objects
	                // See https://github.com/jquery/sizzle/pull/225
	                sortInput = null;

	                return results;
	            };

	            /**
	             * Utility function for retrieving the text value of an array of DOM nodes
	             * @param {Array|Element} elem
	             */
	            getText = Sizzle.getText = function( elem ) {
	                var node,
	                    ret = "",
	                    i = 0,
	                    nodeType = elem.nodeType;

	                if ( !nodeType ) {
	                    // If no nodeType, this is expected to be an array
	                    while ( (node = elem[i++]) ) {
	                        // Do not traverse comment nodes
	                        ret += getText( node );
	                    }
	                } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
	                    // Use textContent for elements
	                    // innerText usage removed for consistency of new lines (jQuery #11153)
	                    if ( typeof elem.textContent === "string" ) {
	                        return elem.textContent;
	                    } else {
	                        // Traverse its children
	                        for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
	                            ret += getText( elem );
	                        }
	                    }
	                } else if ( nodeType === 3 || nodeType === 4 ) {
	                    return elem.nodeValue;
	                }
	                // Do not include comment or processing instruction nodes

	                return ret;
	            };

	            Expr = Sizzle.selectors = {

	                // Can be adjusted by the user
	                cacheLength: 50,

	                createPseudo: markFunction,

	                match: matchExpr,

	                attrHandle: {},

	                find: {},

	                relative: {
	                    ">": { dir: "parentNode", first: true },
	                    " ": { dir: "parentNode" },
	                    "+": { dir: "previousSibling", first: true },
	                    "~": { dir: "previousSibling" }
	                },

	                preFilter: {
	                    "ATTR": function( match ) {
	                        match[1] = match[1].replace( runescape, funescape );

	                        // Move the given value to match[3] whether quoted or unquoted
	                        match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

	                        if ( match[2] === "~=" ) {
	                            match[3] = " " + match[3] + " ";
	                        }

	                        return match.slice( 0, 4 );
	                    },

	                    "CHILD": function( match ) {
	                        /* matches from matchExpr["CHILD"]
	                         1 type (only|nth|...)
	                         2 what (child|of-type)
	                         3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
	                         4 xn-component of xn+y argument ([+-]?\d*n|)
	                         5 sign of xn-component
	                         6 x of xn-component
	                         7 sign of y-component
	                         8 y of y-component
	                         */
	                        match[1] = match[1].toLowerCase();

	                        if ( match[1].slice( 0, 3 ) === "nth" ) {
	                            // nth-* requires argument
	                            if ( !match[3] ) {
	                                Sizzle.error( match[0] );
	                            }

	                            // numeric x and y parameters for Expr.filter.CHILD
	                            // remember that false/true cast respectively to 0/1
	                            match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
	                            match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

	                            // other types prohibit arguments
	                        } else if ( match[3] ) {
	                            Sizzle.error( match[0] );
	                        }

	                        return match;
	                    },

	                    "PSEUDO": function( match ) {
	                        var excess,
	                            unquoted = !match[6] && match[2];

	                        if ( matchExpr["CHILD"].test( match[0] ) ) {
	                            return null;
	                        }

	                        // Accept quoted arguments as-is
	                        if ( match[3] ) {
	                            match[2] = match[4] || match[5] || "";

	                            // Strip excess characters from unquoted arguments
	                        } else if ( unquoted && rpseudo.test( unquoted ) &&
	                            // Get excess from tokenize (recursively)
	                            (excess = tokenize( unquoted, true )) &&
	                            // advance to the next closing parenthesis
	                            (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

	                            // excess is a negative index
	                            match[0] = match[0].slice( 0, excess );
	                            match[2] = unquoted.slice( 0, excess );
	                        }

	                        // Return only captures needed by the pseudo filter method (type and argument)
	                        return match.slice( 0, 3 );
	                    }
	                },

	                filter: {

	                    "TAG": function( nodeNameSelector ) {
	                        var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
	                        return nodeNameSelector === "*" ?
	                            function() { return true; } :
	                            function( elem ) {
	                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
	                            };
	                    },

	                    "CLASS": function( className ) {
	                        var pattern = classCache[ className + " " ];

	                        return pattern ||
	                            (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
	                            classCache( className, function( elem ) {
	                                return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
	                            });
	                    },

	                    "ATTR": function( name, operator, check ) {
	                        return function( elem ) {
	                            var result = Sizzle.attr( elem, name );

	                            if ( result == null ) {
	                                return operator === "!=";
	                            }
	                            if ( !operator ) {
	                                return true;
	                            }

	                            result += "";

	                            return operator === "=" ? result === check :
	                                operator === "!=" ? result !== check :
	                                    operator === "^=" ? check && result.indexOf( check ) === 0 :
	                                        operator === "*=" ? check && result.indexOf( check ) > -1 :
	                                            operator === "$=" ? check && result.slice( -check.length ) === check :
	                                                operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
	                                                    operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
	                                                        false;
	                        };
	                    },

	                    "CHILD": function( type, what, argument, first, last ) {
	                        var simple = type.slice( 0, 3 ) !== "nth",
	                            forward = type.slice( -4 ) !== "last",
	                            ofType = what === "of-type";

	                        return first === 1 && last === 0 ?

	                            // Shortcut for :nth-*(n)
	                            function( elem ) {
	                                return !!elem.parentNode;
	                            } :

	                            function( elem, context, xml ) {
	                                var cache, outerCache, node, diff, nodeIndex, start,
	                                    dir = simple !== forward ? "nextSibling" : "previousSibling",
	                                    parent = elem.parentNode,
	                                    name = ofType && elem.nodeName.toLowerCase(),
	                                    useCache = !xml && !ofType;

	                                if ( parent ) {

	                                    // :(first|last|only)-(child|of-type)
	                                    if ( simple ) {
	                                        while ( dir ) {
	                                            node = elem;
	                                            while ( (node = node[ dir ]) ) {
	                                                if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
	                                                    return false;
	                                                }
	                                            }
	                                            // Reverse direction for :only-* (if we haven't yet done so)
	                                            start = dir = type === "only" && !start && "nextSibling";
	                                        }
	                                        return true;
	                                    }

	                                    start = [ forward ? parent.firstChild : parent.lastChild ];

	                                    // non-xml :nth-child(...) stores cache data on `parent`
	                                    if ( forward && useCache ) {
	                                        // Seek `elem` from a previously-cached index
	                                        outerCache = parent[ expando ] || (parent[ expando ] = {});
	                                        cache = outerCache[ type ] || [];
	                                        nodeIndex = cache[0] === dirruns && cache[1];
	                                        diff = cache[0] === dirruns && cache[2];
	                                        node = nodeIndex && parent.childNodes[ nodeIndex ];

	                                        while ( (node = ++nodeIndex && node && node[ dir ] ||

	                                            // Fallback to seeking `elem` from the start
	                                            (diff = nodeIndex = 0) || start.pop()) ) {

	                                            // When found, cache indexes on `parent` and break
	                                            if ( node.nodeType === 1 && ++diff && node === elem ) {
	                                                outerCache[ type ] = [ dirruns, nodeIndex, diff ];
	                                                break;
	                                            }
	                                        }

	                                        // Use previously-cached element index if available
	                                    } else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
	                                        diff = cache[1];

	                                        // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
	                                    } else {
	                                        // Use the same loop as above to seek `elem` from the start
	                                        while ( (node = ++nodeIndex && node && node[ dir ] ||
	                                            (diff = nodeIndex = 0) || start.pop()) ) {

	                                            if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
	                                                // Cache the index of each encountered element
	                                                if ( useCache ) {
	                                                    (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
	                                                }

	                                                if ( node === elem ) {
	                                                    break;
	                                                }
	                                            }
	                                        }
	                                    }

	                                    // Incorporate the offset, then check against cycle size
	                                    diff -= last;
	                                    return diff === first || ( diff % first === 0 && diff / first >= 0 );
	                                }
	                            };
	                    },

	                    "PSEUDO": function( pseudo, argument ) {
	                        // pseudo-class names are case-insensitive
	                        // http://www.w3.org/TR/selectors/#pseudo-classes
	                        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
	                        // Remember that setFilters inherits from pseudos
	                        var args,
	                            fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
	                                Sizzle.error( "unsupported pseudo: " + pseudo );

	                        // The user may use createPseudo to indicate that
	                        // arguments are needed to create the filter function
	                        // just as Sizzle does
	                        if ( fn[ expando ] ) {
	                            return fn( argument );
	                        }

	                        // But maintain support for old signatures
	                        if ( fn.length > 1 ) {
	                            args = [ pseudo, pseudo, "", argument ];
	                            return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
	                                markFunction(function( seed, matches ) {
	                                    var idx,
	                                        matched = fn( seed, argument ),
	                                        i = matched.length;
	                                    while ( i-- ) {
	                                        idx = indexOf( seed, matched[i] );
	                                        seed[ idx ] = !( matches[ idx ] = matched[i] );
	                                    }
	                                }) :
	                                function( elem ) {
	                                    return fn( elem, 0, args );
	                                };
	                        }

	                        return fn;
	                    }
	                },

	                pseudos: {
	                    // Potentially complex pseudos
	                    "not": markFunction(function( selector ) {
	                        // Trim the selector passed to compile
	                        // to avoid treating leading and trailing
	                        // spaces as combinators
	                        var input = [],
	                            results = [],
	                            matcher = compile( selector.replace( rtrim, "$1" ) );

	                        return matcher[ expando ] ?
	                            markFunction(function( seed, matches, context, xml ) {
	                                var elem,
	                                    unmatched = matcher( seed, null, xml, [] ),
	                                    i = seed.length;

	                                // Match elements unmatched by `matcher`
	                                while ( i-- ) {
	                                    if ( (elem = unmatched[i]) ) {
	                                        seed[i] = !(matches[i] = elem);
	                                    }
	                                }
	                            }) :
	                            function( elem, context, xml ) {
	                                input[0] = elem;
	                                matcher( input, null, xml, results );
	                                // Don't keep the element (issue #299)
	                                input[0] = null;
	                                return !results.pop();
	                            };
	                    }),

	                    "has": markFunction(function( selector ) {
	                        return function( elem ) {
	                            return Sizzle( selector, elem ).length > 0;
	                        };
	                    }),

	                    "contains": markFunction(function( text ) {
	                        text = text.replace( runescape, funescape );
	                        return function( elem ) {
	                            return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
	                        };
	                    }),

	                    // "Whether an element is represented by a :lang() selector
	                    // is based solely on the element's language value
	                    // being equal to the identifier C,
	                    // or beginning with the identifier C immediately followed by "-".
	                    // The matching of C against the element's language value is performed case-insensitively.
	                    // The identifier C does not have to be a valid language name."
	                    // http://www.w3.org/TR/selectors/#lang-pseudo
	                    "lang": markFunction( function( lang ) {
	                        // lang value must be a valid identifier
	                        if ( !ridentifier.test(lang || "") ) {
	                            Sizzle.error( "unsupported lang: " + lang );
	                        }
	                        lang = lang.replace( runescape, funescape ).toLowerCase();
	                        return function( elem ) {
	                            var elemLang;
	                            do {
	                                if ( (elemLang = documentIsHTML ?
	                                        elem.lang :
	                                    elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

	                                    elemLang = elemLang.toLowerCase();
	                                    return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
	                                }
	                            } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
	                            return false;
	                        };
	                    }),

	                    // Miscellaneous
	                    "target": function( elem ) {
	                        var hash = window.location && window.location.hash;
	                        return hash && hash.slice( 1 ) === elem.id;
	                    },

	                    "root": function( elem ) {
	                        return elem === docElem;
	                    },

	                    "focus": function( elem ) {
	                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
	                    },

	                    // Boolean properties
	                    "enabled": function( elem ) {
	                        return elem.disabled === false;
	                    },

	                    "disabled": function( elem ) {
	                        return elem.disabled === true;
	                    },

	                    "checked": function( elem ) {
	                        // In CSS3, :checked should return both checked and selected elements
	                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
	                        var nodeName = elem.nodeName.toLowerCase();
	                        return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
	                    },

	                    "selected": function( elem ) {
	                        // Accessing this property makes selected-by-default
	                        // options in Safari work properly
	                        if ( elem.parentNode ) {
	                            elem.parentNode.selectedIndex;
	                        }

	                        return elem.selected === true;
	                    },

	                    // Contents
	                    "empty": function( elem ) {
	                        // http://www.w3.org/TR/selectors/#empty-pseudo
	                        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
	                        //   but not by others (comment: 8; processing instruction: 7; etc.)
	                        // nodeType < 6 works because attributes (2) do not appear as children
	                        for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
	                            if ( elem.nodeType < 6 ) {
	                                return false;
	                            }
	                        }
	                        return true;
	                    },

	                    "parent": function( elem ) {
	                        return !Expr.pseudos["empty"]( elem );
	                    },

	                    // Element/input types
	                    "header": function( elem ) {
	                        return rheader.test( elem.nodeName );
	                    },

	                    "input": function( elem ) {
	                        return rinputs.test( elem.nodeName );
	                    },

	                    "button": function( elem ) {
	                        var name = elem.nodeName.toLowerCase();
	                        return name === "input" && elem.type === "button" || name === "button";
	                    },

	                    "text": function( elem ) {
	                        var attr;
	                        return elem.nodeName.toLowerCase() === "input" &&
	                            elem.type === "text" &&

	                            // Support: IE<8
	                            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
	                            ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
	                    },

	                    // Position-in-collection
	                    "first": createPositionalPseudo(function() {
	                        return [ 0 ];
	                    }),

	                    "last": createPositionalPseudo(function( matchIndexes, length ) {
	                        return [ length - 1 ];
	                    }),

	                    "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
	                        return [ argument < 0 ? argument + length : argument ];
	                    }),

	                    "even": createPositionalPseudo(function( matchIndexes, length ) {
	                        var i = 0;
	                        for ( ; i < length; i += 2 ) {
	                            matchIndexes.push( i );
	                        }
	                        return matchIndexes;
	                    }),

	                    "odd": createPositionalPseudo(function( matchIndexes, length ) {
	                        var i = 1;
	                        for ( ; i < length; i += 2 ) {
	                            matchIndexes.push( i );
	                        }
	                        return matchIndexes;
	                    }),

	                    "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
	                        var i = argument < 0 ? argument + length : argument;
	                        for ( ; --i >= 0; ) {
	                            matchIndexes.push( i );
	                        }
	                        return matchIndexes;
	                    }),

	                    "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
	                        var i = argument < 0 ? argument + length : argument;
	                        for ( ; ++i < length; ) {
	                            matchIndexes.push( i );
	                        }
	                        return matchIndexes;
	                    })
	                }
	            };

	            Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	            for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	                Expr.pseudos[ i ] = createInputPseudo( i );
	            }
	            for ( i in { submit: true, reset: true } ) {
	                Expr.pseudos[ i ] = createButtonPseudo( i );
	            }

	// Easy API for creating new setFilters
	            function setFilters() {}
	            setFilters.prototype = Expr.filters = Expr.pseudos;
	            Expr.setFilters = new setFilters();

	            tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	                var matched, match, tokens, type,
	                    soFar, groups, preFilters,
	                    cached = tokenCache[ selector + " " ];

	                if ( cached ) {
	                    return parseOnly ? 0 : cached.slice( 0 );
	                }

	                soFar = selector;
	                groups = [];
	                preFilters = Expr.preFilter;

	                while ( soFar ) {

	                    // Comma and first run
	                    if ( !matched || (match = rcomma.exec( soFar )) ) {
	                        if ( match ) {
	                            // Don't consume trailing commas as valid
	                            soFar = soFar.slice( match[0].length ) || soFar;
	                        }
	                        groups.push( (tokens = []) );
	                    }

	                    matched = false;

	                    // Combinators
	                    if ( (match = rcombinators.exec( soFar )) ) {
	                        matched = match.shift();
	                        tokens.push({
	                            value: matched,
	                            // Cast descendant combinators to space
	                            type: match[0].replace( rtrim, " " )
	                        });
	                        soFar = soFar.slice( matched.length );
	                    }

	                    // Filters
	                    for ( type in Expr.filter ) {
	                        if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
	                            (match = preFilters[ type ]( match ))) ) {
	                            matched = match.shift();
	                            tokens.push({
	                                value: matched,
	                                type: type,
	                                matches: match
	                            });
	                            soFar = soFar.slice( matched.length );
	                        }
	                    }

	                    if ( !matched ) {
	                        break;
	                    }
	                }

	                // Return the length of the invalid excess
	                // if we're just parsing
	                // Otherwise, throw an error or return tokens
	                return parseOnly ?
	                    soFar.length :
	                    soFar ?
	                        Sizzle.error( selector ) :
	                        // Cache the tokens
	                        tokenCache( selector, groups ).slice( 0 );
	            };

	            function toSelector( tokens ) {
	                var i = 0,
	                    len = tokens.length,
	                    selector = "";
	                for ( ; i < len; i++ ) {
	                    selector += tokens[i].value;
	                }
	                return selector;
	            }

	            function addCombinator( matcher, combinator, base ) {
	                var dir = combinator.dir,
	                    checkNonElements = base && dir === "parentNode",
	                    doneName = done++;

	                return combinator.first ?
	                    // Check against closest ancestor/preceding element
	                    function( elem, context, xml ) {
	                        while ( (elem = elem[ dir ]) ) {
	                            if ( elem.nodeType === 1 || checkNonElements ) {
	                                return matcher( elem, context, xml );
	                            }
	                        }
	                    } :

	                    // Check against all ancestor/preceding elements
	                    function( elem, context, xml ) {
	                        var oldCache, outerCache,
	                            newCache = [ dirruns, doneName ];

	                        // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
	                        if ( xml ) {
	                            while ( (elem = elem[ dir ]) ) {
	                                if ( elem.nodeType === 1 || checkNonElements ) {
	                                    if ( matcher( elem, context, xml ) ) {
	                                        return true;
	                                    }
	                                }
	                            }
	                        } else {
	                            while ( (elem = elem[ dir ]) ) {
	                                if ( elem.nodeType === 1 || checkNonElements ) {
	                                    outerCache = elem[ expando ] || (elem[ expando ] = {});
	                                    if ( (oldCache = outerCache[ dir ]) &&
	                                        oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

	                                        // Assign to newCache so results back-propagate to previous elements
	                                        return (newCache[ 2 ] = oldCache[ 2 ]);
	                                    } else {
	                                        // Reuse newcache so results back-propagate to previous elements
	                                        outerCache[ dir ] = newCache;

	                                        // A match means we're done; a fail means we have to keep checking
	                                        if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
	                                            return true;
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    };
	            }

	            function elementMatcher( matchers ) {
	                return matchers.length > 1 ?
	                    function( elem, context, xml ) {
	                        var i = matchers.length;
	                        while ( i-- ) {
	                            if ( !matchers[i]( elem, context, xml ) ) {
	                                return false;
	                            }
	                        }
	                        return true;
	                    } :
	                    matchers[0];
	            }

	            function multipleContexts( selector, contexts, results ) {
	                var i = 0,
	                    len = contexts.length;
	                for ( ; i < len; i++ ) {
	                    Sizzle( selector, contexts[i], results );
	                }
	                return results;
	            }

	            function condense( unmatched, map, filter, context, xml ) {
	                var elem,
	                    newUnmatched = [],
	                    i = 0,
	                    len = unmatched.length,
	                    mapped = map != null;

	                for ( ; i < len; i++ ) {
	                    if ( (elem = unmatched[i]) ) {
	                        if ( !filter || filter( elem, context, xml ) ) {
	                            newUnmatched.push( elem );
	                            if ( mapped ) {
	                                map.push( i );
	                            }
	                        }
	                    }
	                }

	                return newUnmatched;
	            }

	            function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	                if ( postFilter && !postFilter[ expando ] ) {
	                    postFilter = setMatcher( postFilter );
	                }
	                if ( postFinder && !postFinder[ expando ] ) {
	                    postFinder = setMatcher( postFinder, postSelector );
	                }
	                return markFunction(function( seed, results, context, xml ) {
	                    var temp, i, elem,
	                        preMap = [],
	                        postMap = [],
	                        preexisting = results.length,

	                    // Get initial elements from seed or context
	                        elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

	                    // Prefilter to get matcher input, preserving a map for seed-results synchronization
	                        matcherIn = preFilter && ( seed || !selector ) ?
	                            condense( elems, preMap, preFilter, context, xml ) :
	                            elems,

	                        matcherOut = matcher ?
	                            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
	                            postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

	                                // ...intermediate processing is necessary
	                                [] :

	                                // ...otherwise use results directly
	                                results :
	                            matcherIn;

	                    // Find primary matches
	                    if ( matcher ) {
	                        matcher( matcherIn, matcherOut, context, xml );
	                    }

	                    // Apply postFilter
	                    if ( postFilter ) {
	                        temp = condense( matcherOut, postMap );
	                        postFilter( temp, [], context, xml );

	                        // Un-match failing elements by moving them back to matcherIn
	                        i = temp.length;
	                        while ( i-- ) {
	                            if ( (elem = temp[i]) ) {
	                                matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
	                            }
	                        }
	                    }

	                    if ( seed ) {
	                        if ( postFinder || preFilter ) {
	                            if ( postFinder ) {
	                                // Get the final matcherOut by condensing this intermediate into postFinder contexts
	                                temp = [];
	                                i = matcherOut.length;
	                                while ( i-- ) {
	                                    if ( (elem = matcherOut[i]) ) {
	                                        // Restore matcherIn since elem is not yet a final match
	                                        temp.push( (matcherIn[i] = elem) );
	                                    }
	                                }
	                                postFinder( null, (matcherOut = []), temp, xml );
	                            }

	                            // Move matched elements from seed to results to keep them synchronized
	                            i = matcherOut.length;
	                            while ( i-- ) {
	                                if ( (elem = matcherOut[i]) &&
	                                    (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

	                                    seed[temp] = !(results[temp] = elem);
	                                }
	                            }
	                        }

	                        // Add elements to results, through postFinder if defined
	                    } else {
	                        matcherOut = condense(
	                            matcherOut === results ?
	                                matcherOut.splice( preexisting, matcherOut.length ) :
	                                matcherOut
	                        );
	                        if ( postFinder ) {
	                            postFinder( null, results, matcherOut, xml );
	                        } else {
	                            push.apply( results, matcherOut );
	                        }
	                    }
	                });
	            }

	            function matcherFromTokens( tokens ) {
	                var checkContext, matcher, j,
	                    len = tokens.length,
	                    leadingRelative = Expr.relative[ tokens[0].type ],
	                    implicitRelative = leadingRelative || Expr.relative[" "],
	                    i = leadingRelative ? 1 : 0,

	                // The foundational matcher ensures that elements are reachable from top-level context(s)
	                    matchContext = addCombinator( function( elem ) {
	                        return elem === checkContext;
	                    }, implicitRelative, true ),
	                    matchAnyContext = addCombinator( function( elem ) {
	                        return indexOf( checkContext, elem ) > -1;
	                    }, implicitRelative, true ),
	                    matchers = [ function( elem, context, xml ) {
	                        var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
	                                (checkContext = context).nodeType ?
	                                    matchContext( elem, context, xml ) :
	                                    matchAnyContext( elem, context, xml ) );
	                        // Avoid hanging onto element (issue #299)
	                        checkContext = null;
	                        return ret;
	                    } ];

	                for ( ; i < len; i++ ) {
	                    if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
	                        matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
	                    } else {
	                        matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

	                        // Return special upon seeing a positional matcher
	                        if ( matcher[ expando ] ) {
	                            // Find the next relative operator (if any) for proper handling
	                            j = ++i;
	                            for ( ; j < len; j++ ) {
	                                if ( Expr.relative[ tokens[j].type ] ) {
	                                    break;
	                                }
	                            }
	                            return setMatcher(
	                                i > 1 && elementMatcher( matchers ),
	                                i > 1 && toSelector(
	                                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
	                                    tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
	                                ).replace( rtrim, "$1" ),
	                                matcher,
	                                i < j && matcherFromTokens( tokens.slice( i, j ) ),
	                                j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
	                                j < len && toSelector( tokens )
	                            );
	                        }
	                        matchers.push( matcher );
	                    }
	                }

	                return elementMatcher( matchers );
	            }

	            function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	                var bySet = setMatchers.length > 0,
	                    byElement = elementMatchers.length > 0,
	                    superMatcher = function( seed, context, xml, results, outermost ) {
	                        var elem, j, matcher,
	                            matchedCount = 0,
	                            i = "0",
	                            unmatched = seed && [],
	                            setMatched = [],
	                            contextBackup = outermostContext,
	                        // We must always have either seed elements or outermost context
	                            elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
	                        // Use integer dirruns iff this is the outermost matcher
	                            dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
	                            len = elems.length;

	                        if ( outermost ) {
	                            outermostContext = context !== document && context;
	                        }

	                        // Add elements passing elementMatchers directly to results
	                        // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
	                        // Support: IE<9, Safari
	                        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
	                        for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
	                            if ( byElement && elem ) {
	                                j = 0;
	                                while ( (matcher = elementMatchers[j++]) ) {
	                                    if ( matcher( elem, context, xml ) ) {
	                                        results.push( elem );
	                                        break;
	                                    }
	                                }
	                                if ( outermost ) {
	                                    dirruns = dirrunsUnique;
	                                }
	                            }

	                            // Track unmatched elements for set filters
	                            if ( bySet ) {
	                                // They will have gone through all possible matchers
	                                if ( (elem = !matcher && elem) ) {
	                                    matchedCount--;
	                                }

	                                // Lengthen the array for every element, matched or not
	                                if ( seed ) {
	                                    unmatched.push( elem );
	                                }
	                            }
	                        }

	                        // Apply set filters to unmatched elements
	                        matchedCount += i;
	                        if ( bySet && i !== matchedCount ) {
	                            j = 0;
	                            while ( (matcher = setMatchers[j++]) ) {
	                                matcher( unmatched, setMatched, context, xml );
	                            }

	                            if ( seed ) {
	                                // Reintegrate element matches to eliminate the need for sorting
	                                if ( matchedCount > 0 ) {
	                                    while ( i-- ) {
	                                        if ( !(unmatched[i] || setMatched[i]) ) {
	                                            setMatched[i] = pop.call( results );
	                                        }
	                                    }
	                                }

	                                // Discard index placeholder values to get only actual matches
	                                setMatched = condense( setMatched );
	                            }

	                            // Add matches to results
	                            push.apply( results, setMatched );

	                            // Seedless set matches succeeding multiple successful matchers stipulate sorting
	                            if ( outermost && !seed && setMatched.length > 0 &&
	                                ( matchedCount + setMatchers.length ) > 1 ) {

	                                Sizzle.uniqueSort( results );
	                            }
	                        }

	                        // Override manipulation of globals by nested matchers
	                        if ( outermost ) {
	                            dirruns = dirrunsUnique;
	                            outermostContext = contextBackup;
	                        }

	                        return unmatched;
	                    };

	                return bySet ?
	                    markFunction( superMatcher ) :
	                    superMatcher;
	            }

	            compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	                var i,
	                    setMatchers = [],
	                    elementMatchers = [],
	                    cached = compilerCache[ selector + " " ];

	                if ( !cached ) {
	                    // Generate a function of recursive functions that can be used to check each element
	                    if ( !match ) {
	                        match = tokenize( selector );
	                    }
	                    i = match.length;
	                    while ( i-- ) {
	                        cached = matcherFromTokens( match[i] );
	                        if ( cached[ expando ] ) {
	                            setMatchers.push( cached );
	                        } else {
	                            elementMatchers.push( cached );
	                        }
	                    }

	                    // Cache the compiled function
	                    cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

	                    // Save selector and tokenization
	                    cached.selector = selector;
	                }
	                return cached;
	            };

	            /**
	             * A low-level selection function that works with Sizzle's compiled
	             *  selector functions
	             * @param {String|Function} selector A selector or a pre-compiled
	             *  selector function built with Sizzle.compile
	             * @param {Element} context
	             * @param {Array} [results]
	             * @param {Array} [seed] A set of elements to match against
	             */
	            select = Sizzle.select = function( selector, context, results, seed ) {
	                var i, tokens, token, type, find,
	                    compiled = typeof selector === "function" && selector,
	                    match = !seed && tokenize( (selector = compiled.selector || selector) );

	                results = results || [];

	                // Try to minimize operations if there is no seed and only one group
	                if ( match.length === 1 ) {

	                    // Take a shortcut and set the context if the root selector is an ID
	                    tokens = match[0] = match[0].slice( 0 );
	                    if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
	                        support.getById && context.nodeType === 9 && documentIsHTML &&
	                        Expr.relative[ tokens[1].type ] ) {

	                        context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
	                        if ( !context ) {
	                            return results;

	                            // Precompiled matchers will still verify ancestry, so step up a level
	                        } else if ( compiled ) {
	                            context = context.parentNode;
	                        }

	                        selector = selector.slice( tokens.shift().value.length );
	                    }

	                    // Fetch a seed set for right-to-left matching
	                    i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
	                    while ( i-- ) {
	                        token = tokens[i];

	                        // Abort if we hit a combinator
	                        if ( Expr.relative[ (type = token.type) ] ) {
	                            break;
	                        }
	                        if ( (find = Expr.find[ type ]) ) {
	                            // Search, expanding context for leading sibling combinators
	                            if ( (seed = find(
	                                    token.matches[0].replace( runescape, funescape ),
	                                    rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
	                                )) ) {

	                                // If seed is empty or no tokens remain, we can return early
	                                tokens.splice( i, 1 );
	                                selector = seed.length && toSelector( tokens );
	                                if ( !selector ) {
	                                    push.apply( results, seed );
	                                    return results;
	                                }

	                                break;
	                            }
	                        }
	                    }
	                }

	                // Compile and execute a filtering function if one is not provided
	                // Provide `match` to avoid retokenization if we modified the selector above
	                ( compiled || compile( selector, match ) )(
	                    seed,
	                    context,
	                    !documentIsHTML,
	                    results,
	                    rsibling.test( selector ) && testContext( context.parentNode ) || context
	                );
	                return results;
	            };

	// One-time assignments

	// Sort stability
	            support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	            support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	            setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	            support.sortDetached = assert(function( div1 ) {
	                // Should return 1, but returns 4 (following)
	                return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	            });

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	            if ( !assert(function( div ) {
	                    div.innerHTML = "<a href='#'></a>";
	                    return div.firstChild.getAttribute("href") === "#" ;
	                }) ) {
	                addHandle( "type|href|height|width", function( elem, name, isXML ) {
	                    if ( !isXML ) {
	                        return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
	                    }
	                });
	            }

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	            if ( !support.attributes || !assert(function( div ) {
	                    div.innerHTML = "<input/>";
	                    div.firstChild.setAttribute( "value", "" );
	                    return div.firstChild.getAttribute( "value" ) === "";
	                }) ) {
	                addHandle( "value", function( elem, name, isXML ) {
	                    if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
	                        return elem.defaultValue;
	                    }
	                });
	            }

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	            if ( !assert(function( div ) {
	                    return div.getAttribute("disabled") == null;
	                }) ) {
	                addHandle( booleans, function( elem, name, isXML ) {
	                    var val;
	                    if ( !isXML ) {
	                        return elem[ name ] === true ? name.toLowerCase() :
	                            (val = elem.getAttributeNode( name )) && val.specified ?
	                                val.value :
	                                null;
	                    }
	                });
	            }

	            return Sizzle;

	        })( window );



	    jQuery.find = Sizzle;
	    jQuery.expr = Sizzle.selectors;
	    jQuery.expr[":"] = jQuery.expr.pseudos;
	    jQuery.unique = Sizzle.uniqueSort;
	    jQuery.text = Sizzle.getText;
	    jQuery.isXMLDoc = Sizzle.isXML;
	    jQuery.contains = Sizzle.contains;



	    var rneedsContext = jQuery.expr.match.needsContext;

	    var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



	    var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	    function winnow( elements, qualifier, not ) {
	        if ( jQuery.isFunction( qualifier ) ) {
	            return jQuery.grep( elements, function( elem, i ) {
	                /* jshint -W018 */
	                return !!qualifier.call( elem, i, elem ) !== not;
	            });

	        }

	        if ( qualifier.nodeType ) {
	            return jQuery.grep( elements, function( elem ) {
	                return ( elem === qualifier ) !== not;
	            });

	        }

	        if ( typeof qualifier === "string" ) {
	            if ( risSimple.test( qualifier ) ) {
	                return jQuery.filter( qualifier, elements, not );
	            }

	            qualifier = jQuery.filter( qualifier, elements );
	        }

	        return jQuery.grep( elements, function( elem ) {
	            return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
	        });
	    }

	    jQuery.filter = function( expr, elems, not ) {
	        var elem = elems[ 0 ];

	        if ( not ) {
	            expr = ":not(" + expr + ")";
	        }

	        return elems.length === 1 && elem.nodeType === 1 ?
	            jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
	            jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
	                return elem.nodeType === 1;
	            }));
	    };

	    jQuery.fn.extend({
	        find: function( selector ) {
	            var i,
	                ret = [],
	                self = this,
	                len = self.length;

	            if ( typeof selector !== "string" ) {
	                return this.pushStack( jQuery( selector ).filter(function() {
	                    for ( i = 0; i < len; i++ ) {
	                        if ( jQuery.contains( self[ i ], this ) ) {
	                            return true;
	                        }
	                    }
	                }) );
	            }

	            for ( i = 0; i < len; i++ ) {
	                jQuery.find( selector, self[ i ], ret );
	            }

	            // Needed because $( selector, context ) becomes $( context ).find( selector )
	            ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
	            ret.selector = this.selector ? this.selector + " " + selector : selector;
	            return ret;
	        },
	        filter: function( selector ) {
	            return this.pushStack( winnow(this, selector || [], false) );
	        },
	        not: function( selector ) {
	            return this.pushStack( winnow(this, selector || [], true) );
	        },
	        is: function( selector ) {
	            return !!winnow(
	                this,

	                // If this is a positional/relative selector, check membership in the returned set
	                // so $("p:first").is("p:last") won't return true for a doc with two "p".
	                typeof selector === "string" && rneedsContext.test( selector ) ?
	                    jQuery( selector ) :
	                selector || [],
	                false
	            ).length;
	        }
	    });


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	    var rootjQuery,

	    // Use the correct document accordingly with window argument (sandbox)
	        document = window.document,

	    // A simple way to check for HTML strings
	    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	    // Strict HTML recognition (#11290: must start with <)
	        rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	        init = jQuery.fn.init = function( selector, context ) {
	            var match, elem;

	            // HANDLE: $(""), $(null), $(undefined), $(false)
	            if ( !selector ) {
	                return this;
	            }

	            // Handle HTML strings
	            if ( typeof selector === "string" ) {
	                if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
	                    // Assume that strings that start and end with <> are HTML and skip the regex check
	                    match = [ null, selector, null ];

	                } else {
	                    match = rquickExpr.exec( selector );
	                }

	                // Match html or make sure no context is specified for #id
	                if ( match && (match[1] || !context) ) {

	                    // HANDLE: $(html) -> $(array)
	                    if ( match[1] ) {
	                        context = context instanceof jQuery ? context[0] : context;

	                        // scripts is true for back-compat
	                        // Intentionally let the error be thrown if parseHTML is not present
	                        jQuery.merge( this, jQuery.parseHTML(
	                            match[1],
	                            context && context.nodeType ? context.ownerDocument || context : document,
	                            true
	                        ) );

	                        // HANDLE: $(html, props)
	                        if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
	                            for ( match in context ) {
	                                // Properties of context are called as methods if possible
	                                if ( jQuery.isFunction( this[ match ] ) ) {
	                                    this[ match ]( context[ match ] );

	                                    // ...and otherwise set as attributes
	                                } else {
	                                    this.attr( match, context[ match ] );
	                                }
	                            }
	                        }

	                        return this;

	                        // HANDLE: $(#id)
	                    } else {
	                        elem = document.getElementById( match[2] );

	                        // Check parentNode to catch when Blackberry 4.6 returns
	                        // nodes that are no longer in the document #6963
	                        if ( elem && elem.parentNode ) {
	                            // Handle the case where IE and Opera return items
	                            // by name instead of ID
	                            if ( elem.id !== match[2] ) {
	                                return rootjQuery.find( selector );
	                            }

	                            // Otherwise, we inject the element directly into the jQuery object
	                            this.length = 1;
	                            this[0] = elem;
	                        }

	                        this.context = document;
	                        this.selector = selector;
	                        return this;
	                    }

	                    // HANDLE: $(expr, $(...))
	                } else if ( !context || context.jquery ) {
	                    return ( context || rootjQuery ).find( selector );

	                    // HANDLE: $(expr, context)
	                    // (which is just equivalent to: $(context).find(expr)
	                } else {
	                    return this.constructor( context ).find( selector );
	                }

	                // HANDLE: $(DOMElement)
	            } else if ( selector.nodeType ) {
	                this.context = this[0] = selector;
	                this.length = 1;
	                return this;

	                // HANDLE: $(function)
	                // Shortcut for document ready
	            } else if ( jQuery.isFunction( selector ) ) {
	                return typeof rootjQuery.ready !== "undefined" ?
	                    rootjQuery.ready( selector ) :
	                    // Execute immediately if ready is not present
	                    selector( jQuery );
	            }

	            if ( selector.selector !== undefined ) {
	                this.selector = selector.selector;
	                this.context = selector.context;
	            }

	            return jQuery.makeArray( selector, this );
	        };

	// Give the init function the jQuery prototype for later instantiation
	    init.prototype = jQuery.fn;

	// Initialize central reference
	    rootjQuery = jQuery( document );


	    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	    // methods guaranteed to produce a unique set when starting from a unique set
	        guaranteedUnique = {
	            children: true,
	            contents: true,
	            next: true,
	            prev: true
	        };

	    jQuery.extend({
	        dir: function( elem, dir, until ) {
	            var matched = [],
	                cur = elem[ dir ];

	            while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
	                if ( cur.nodeType === 1 ) {
	                    matched.push( cur );
	                }
	                cur = cur[dir];
	            }
	            return matched;
	        },

	        sibling: function( n, elem ) {
	            var r = [];

	            for ( ; n; n = n.nextSibling ) {
	                if ( n.nodeType === 1 && n !== elem ) {
	                    r.push( n );
	                }
	            }

	            return r;
	        }
	    });

	    jQuery.fn.extend({
	        has: function( target ) {
	            var i,
	                targets = jQuery( target, this ),
	                len = targets.length;

	            return this.filter(function() {
	                for ( i = 0; i < len; i++ ) {
	                    if ( jQuery.contains( this, targets[i] ) ) {
	                        return true;
	                    }
	                }
	            });
	        },

	        closest: function( selectors, context ) {
	            var cur,
	                i = 0,
	                l = this.length,
	                matched = [],
	                pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
	                    jQuery( selectors, context || this.context ) :
	                    0;

	            for ( ; i < l; i++ ) {
	                for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
	                    // Always skip document fragments
	                    if ( cur.nodeType < 11 && (pos ?
	                        pos.index(cur) > -1 :

	                            // Don't pass non-elements to Sizzle
	                        cur.nodeType === 1 &&
	                        jQuery.find.matchesSelector(cur, selectors)) ) {

	                        matched.push( cur );
	                        break;
	                    }
	                }
	            }

	            return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	        },

	        // Determine the position of an element within
	        // the matched set of elements
	        index: function( elem ) {

	            // No argument, return index in parent
	            if ( !elem ) {
	                return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
	            }

	            // index in selector
	            if ( typeof elem === "string" ) {
	                return jQuery.inArray( this[0], jQuery( elem ) );
	            }

	            // Locate the position of the desired element
	            return jQuery.inArray(
	                // If it receives a jQuery object, the first element is used
	                elem.jquery ? elem[0] : elem, this );
	        },

	        add: function( selector, context ) {
	            return this.pushStack(
	                jQuery.unique(
	                    jQuery.merge( this.get(), jQuery( selector, context ) )
	                )
	            );
	        },

	        addBack: function( selector ) {
	            return this.add( selector == null ?
	                this.prevObject : this.prevObject.filter(selector)
	            );
	        }
	    });

	    function sibling( cur, dir ) {
	        do {
	            cur = cur[ dir ];
	        } while ( cur && cur.nodeType !== 1 );

	        return cur;
	    }

	    jQuery.each({
	        parent: function( elem ) {
	            var parent = elem.parentNode;
	            return parent && parent.nodeType !== 11 ? parent : null;
	        },
	        parents: function( elem ) {
	            return jQuery.dir( elem, "parentNode" );
	        },
	        parentsUntil: function( elem, i, until ) {
	            return jQuery.dir( elem, "parentNode", until );
	        },
	        next: function( elem ) {
	            return sibling( elem, "nextSibling" );
	        },
	        prev: function( elem ) {
	            return sibling( elem, "previousSibling" );
	        },
	        nextAll: function( elem ) {
	            return jQuery.dir( elem, "nextSibling" );
	        },
	        prevAll: function( elem ) {
	            return jQuery.dir( elem, "previousSibling" );
	        },
	        nextUntil: function( elem, i, until ) {
	            return jQuery.dir( elem, "nextSibling", until );
	        },
	        prevUntil: function( elem, i, until ) {
	            return jQuery.dir( elem, "previousSibling", until );
	        },
	        siblings: function( elem ) {
	            return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	        },
	        children: function( elem ) {
	            return jQuery.sibling( elem.firstChild );
	        },
	        contents: function( elem ) {
	            return jQuery.nodeName( elem, "iframe" ) ?
	            elem.contentDocument || elem.contentWindow.document :
	                jQuery.merge( [], elem.childNodes );
	        }
	    }, function( name, fn ) {
	        jQuery.fn[ name ] = function( until, selector ) {
	            var ret = jQuery.map( this, fn, until );

	            if ( name.slice( -5 ) !== "Until" ) {
	                selector = until;
	            }

	            if ( selector && typeof selector === "string" ) {
	                ret = jQuery.filter( selector, ret );
	            }

	            if ( this.length > 1 ) {
	                // Remove duplicates
	                if ( !guaranteedUnique[ name ] ) {
	                    ret = jQuery.unique( ret );
	                }

	                // Reverse order for parents* and prev-derivatives
	                if ( rparentsprev.test( name ) ) {
	                    ret = ret.reverse();
	                }
	            }

	            return this.pushStack( ret );
	        };
	    });
	    var rnotwhite = (/\S+/g);



	// String to Object options format cache
	    var optionsCache = {};

	// Convert String-formatted options into Object-formatted ones and store in cache
	    function createOptions( options ) {
	        var object = optionsCache[ options ] = {};
	        jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
	            object[ flag ] = true;
	        });
	        return object;
	    }

	    /*
	     * Create a callback list using the following parameters:
	     *
	     *	options: an optional list of space-separated options that will change how
	     *			the callback list behaves or a more traditional option object
	     *
	     * By default a callback list will act like an event callback list and can be
	     * "fired" multiple times.
	     *
	     * Possible options:
	     *
	     *	once:			will ensure the callback list can only be fired once (like a Deferred)
	     *
	     *	memory:			will keep track of previous values and will call any callback added
	     *					after the list has been fired right away with the latest "memorized"
	     *					values (like a Deferred)
	     *
	     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	     *
	     *	stopOnFalse:	interrupt callings when a callback returns false
	     *
	     */
	    jQuery.Callbacks = function( options ) {

	        // Convert options from String-formatted to Object-formatted if needed
	        // (we check in cache first)
	        options = typeof options === "string" ?
	            ( optionsCache[ options ] || createOptions( options ) ) :
	            jQuery.extend( {}, options );

	        var // Flag to know if list is currently firing
	            firing,
	        // Last fire value (for non-forgettable lists)
	            memory,
	        // Flag to know if list was already fired
	            fired,
	        // End of the loop when firing
	            firingLength,
	        // Index of currently firing callback (modified by remove if needed)
	            firingIndex,
	        // First callback to fire (used internally by add and fireWith)
	            firingStart,
	        // Actual callback list
	            list = [],
	        // Stack of fire calls for repeatable lists
	            stack = !options.once && [],
	        // Fire callbacks
	            fire = function( data ) {
	                memory = options.memory && data;
	                fired = true;
	                firingIndex = firingStart || 0;
	                firingStart = 0;
	                firingLength = list.length;
	                firing = true;
	                for ( ; list && firingIndex < firingLength; firingIndex++ ) {
	                    if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
	                        memory = false; // To prevent further calls using add
	                        break;
	                    }
	                }
	                firing = false;
	                if ( list ) {
	                    if ( stack ) {
	                        if ( stack.length ) {
	                            fire( stack.shift() );
	                        }
	                    } else if ( memory ) {
	                        list = [];
	                    } else {
	                        self.disable();
	                    }
	                }
	            },
	        // Actual Callbacks object
	            self = {
	                // Add a callback or a collection of callbacks to the list
	                add: function() {
	                    if ( list ) {
	                        // First, we save the current length
	                        var start = list.length;
	                        (function add( args ) {
	                            jQuery.each( args, function( _, arg ) {
	                                var type = jQuery.type( arg );
	                                if ( type === "function" ) {
	                                    if ( !options.unique || !self.has( arg ) ) {
	                                        list.push( arg );
	                                    }
	                                } else if ( arg && arg.length && type !== "string" ) {
	                                    // Inspect recursively
	                                    add( arg );
	                                }
	                            });
	                        })( arguments );
	                        // Do we need to add the callbacks to the
	                        // current firing batch?
	                        if ( firing ) {
	                            firingLength = list.length;
	                            // With memory, if we're not firing then
	                            // we should call right away
	                        } else if ( memory ) {
	                            firingStart = start;
	                            fire( memory );
	                        }
	                    }
	                    return this;
	                },
	                // Remove a callback from the list
	                remove: function() {
	                    if ( list ) {
	                        jQuery.each( arguments, function( _, arg ) {
	                            var index;
	                            while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
	                                list.splice( index, 1 );
	                                // Handle firing indexes
	                                if ( firing ) {
	                                    if ( index <= firingLength ) {
	                                        firingLength--;
	                                    }
	                                    if ( index <= firingIndex ) {
	                                        firingIndex--;
	                                    }
	                                }
	                            }
	                        });
	                    }
	                    return this;
	                },
	                // Check if a given callback is in the list.
	                // If no argument is given, return whether or not list has callbacks attached.
	                has: function( fn ) {
	                    return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
	                },
	                // Remove all callbacks from the list
	                empty: function() {
	                    list = [];
	                    firingLength = 0;
	                    return this;
	                },
	                // Have the list do nothing anymore
	                disable: function() {
	                    list = stack = memory = undefined;
	                    return this;
	                },
	                // Is it disabled?
	                disabled: function() {
	                    return !list;
	                },
	                // Lock the list in its current state
	                lock: function() {
	                    stack = undefined;
	                    if ( !memory ) {
	                        self.disable();
	                    }
	                    return this;
	                },
	                // Is it locked?
	                locked: function() {
	                    return !stack;
	                },
	                // Call all callbacks with the given context and arguments
	                fireWith: function( context, args ) {
	                    if ( list && ( !fired || stack ) ) {
	                        args = args || [];
	                        args = [ context, args.slice ? args.slice() : args ];
	                        if ( firing ) {
	                            stack.push( args );
	                        } else {
	                            fire( args );
	                        }
	                    }
	                    return this;
	                },
	                // Call all the callbacks with the given arguments
	                fire: function() {
	                    self.fireWith( this, arguments );
	                    return this;
	                },
	                // To know if the callbacks have already been called at least once
	                fired: function() {
	                    return !!fired;
	                }
	            };

	        return self;
	    };


	    jQuery.extend({

	        Deferred: function( func ) {
	            var tuples = [
	                    // action, add listener, listener list, final state
	                    [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
	                    [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
	                    [ "notify", "progress", jQuery.Callbacks("memory") ]
	                ],
	                state = "pending",
	                promise = {
	                    state: function() {
	                        return state;
	                    },
	                    always: function() {
	                        deferred.done( arguments ).fail( arguments );
	                        return this;
	                    },
	                    then: function( /* fnDone, fnFail, fnProgress */ ) {
	                        var fns = arguments;
	                        return jQuery.Deferred(function( newDefer ) {
	                            jQuery.each( tuples, function( i, tuple ) {
	                                var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
	                                // deferred[ done | fail | progress ] for forwarding actions to newDefer
	                                deferred[ tuple[1] ](function() {
	                                    var returned = fn && fn.apply( this, arguments );
	                                    if ( returned && jQuery.isFunction( returned.promise ) ) {
	                                        returned.promise()
	                                            .done( newDefer.resolve )
	                                            .fail( newDefer.reject )
	                                            .progress( newDefer.notify );
	                                    } else {
	                                        newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
	                                    }
	                                });
	                            });
	                            fns = null;
	                        }).promise();
	                    },
	                    // Get a promise for this deferred
	                    // If obj is provided, the promise aspect is added to the object
	                    promise: function( obj ) {
	                        return obj != null ? jQuery.extend( obj, promise ) : promise;
	                    }
	                },
	                deferred = {};

	            // Keep pipe for back-compat
	            promise.pipe = promise.then;

	            // Add list-specific methods
	            jQuery.each( tuples, function( i, tuple ) {
	                var list = tuple[ 2 ],
	                    stateString = tuple[ 3 ];

	                // promise[ done | fail | progress ] = list.add
	                promise[ tuple[1] ] = list.add;

	                // Handle state
	                if ( stateString ) {
	                    list.add(function() {
	                        // state = [ resolved | rejected ]
	                        state = stateString;

	                        // [ reject_list | resolve_list ].disable; progress_list.lock
	                    }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
	                }

	                // deferred[ resolve | reject | notify ]
	                deferred[ tuple[0] ] = function() {
	                    deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
	                    return this;
	                };
	                deferred[ tuple[0] + "With" ] = list.fireWith;
	            });

	            // Make the deferred a promise
	            promise.promise( deferred );

	            // Call given func if any
	            if ( func ) {
	                func.call( deferred, deferred );
	            }

	            // All done!
	            return deferred;
	        },

	        // Deferred helper
	        when: function( subordinate /* , ..., subordinateN */ ) {
	            var i = 0,
	                resolveValues = slice.call( arguments ),
	                length = resolveValues.length,

	            // the count of uncompleted subordinates
	                remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

	            // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
	                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

	            // Update function for both resolve and progress values
	                updateFunc = function( i, contexts, values ) {
	                    return function( value ) {
	                        contexts[ i ] = this;
	                        values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
	                        if ( values === progressValues ) {
	                            deferred.notifyWith( contexts, values );

	                        } else if ( !(--remaining) ) {
	                            deferred.resolveWith( contexts, values );
	                        }
	                    };
	                },

	                progressValues, progressContexts, resolveContexts;

	            // add listeners to Deferred subordinates; treat others as resolved
	            if ( length > 1 ) {
	                progressValues = new Array( length );
	                progressContexts = new Array( length );
	                resolveContexts = new Array( length );
	                for ( ; i < length; i++ ) {
	                    if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
	                        resolveValues[ i ].promise()
	                            .done( updateFunc( i, resolveContexts, resolveValues ) )
	                            .fail( deferred.reject )
	                            .progress( updateFunc( i, progressContexts, progressValues ) );
	                    } else {
	                        --remaining;
	                    }
	                }
	            }

	            // if we're not waiting on anything, resolve the master
	            if ( !remaining ) {
	                deferred.resolveWith( resolveContexts, resolveValues );
	            }

	            return deferred.promise();
	        }
	    });


	// The deferred used on DOM ready
	    var readyList;

	    jQuery.fn.ready = function( fn ) {
	        // Add the callback
	        jQuery.ready.promise().done( fn );

	        return this;
	    };

	    jQuery.extend({
	        // Is the DOM ready to be used? Set to true once it occurs.
	        isReady: false,

	        // A counter to track how many items to wait for before
	        // the ready event fires. See #6781
	        readyWait: 1,

	        // Hold (or release) the ready event
	        holdReady: function( hold ) {
	            if ( hold ) {
	                jQuery.readyWait++;
	            } else {
	                jQuery.ready( true );
	            }
	        },

	        // Handle when the DOM is ready
	        ready: function( wait ) {

	            // Abort if there are pending holds or we're already ready
	            if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
	                return;
	            }

	            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
	            if ( !document.body ) {
	                return setTimeout( jQuery.ready );
	            }

	            // Remember that the DOM is ready
	            jQuery.isReady = true;

	            // If a normal DOM Ready event fired, decrement, and wait if need be
	            if ( wait !== true && --jQuery.readyWait > 0 ) {
	                return;
	            }

	            // If there are functions bound, to execute
	            readyList.resolveWith( document, [ jQuery ] );

	            // Trigger any bound ready events
	            if ( jQuery.fn.triggerHandler ) {
	                jQuery( document ).triggerHandler( "ready" );
	                jQuery( document ).off( "ready" );
	            }
	        }
	    });

	    /**
	     * Clean-up method for dom ready events
	     */
	    function detach() {
	        if ( document.addEventListener ) {
	            document.removeEventListener( "DOMContentLoaded", completed, false );
	            window.removeEventListener( "load", completed, false );

	        } else {
	            document.detachEvent( "onreadystatechange", completed );
	            window.detachEvent( "onload", completed );
	        }
	    }

	    /**
	     * The ready event handler and self cleanup method
	     */
	    function completed() {
	        // readyState === "complete" is good enough for us to call the dom ready in oldIE
	        if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
	            detach();
	            jQuery.ready();
	        }
	    }

	    jQuery.ready.promise = function( obj ) {
	        if ( !readyList ) {

	            readyList = jQuery.Deferred();

	            // Catch cases where $(document).ready() is called after the browser event has already occurred.
	            // we once tried to use readyState "interactive" here, but it caused issues like the one
	            // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
	            if ( document.readyState === "complete" ) {
	                // Handle it asynchronously to allow scripts the opportunity to delay ready
	                setTimeout( jQuery.ready );

	                // Standards-based browsers support DOMContentLoaded
	            } else if ( document.addEventListener ) {
	                // Use the handy event callback
	                document.addEventListener( "DOMContentLoaded", completed, false );

	                // A fallback to window.onload, that will always work
	                window.addEventListener( "load", completed, false );

	                // If IE event model is used
	            } else {
	                // Ensure firing before onload, maybe late but safe also for iframes
	                document.attachEvent( "onreadystatechange", completed );

	                // A fallback to window.onload, that will always work
	                window.attachEvent( "onload", completed );

	                // If IE and not a frame
	                // continually check to see if the document is ready
	                var top = false;

	                try {
	                    top = window.frameElement == null && document.documentElement;
	                } catch(e) {}

	                if ( top && top.doScroll ) {
	                    (function doScrollCheck() {
	                        if ( !jQuery.isReady ) {

	                            try {
	                                // Use the trick by Diego Perini
	                                // http://javascript.nwbox.com/IEContentLoaded/
	                                top.doScroll("left");
	                            } catch(e) {
	                                return setTimeout( doScrollCheck, 50 );
	                            }

	                            // detach all dom ready events
	                            detach();

	                            // and execute any waiting functions
	                            jQuery.ready();
	                        }
	                    })();
	                }
	            }
	        }
	        return readyList.promise( obj );
	    };


	    var strundefined = typeof undefined;



	// Support: IE<9
	// Iteration over object's inherited properties before its own
	    var i;
	    for ( i in jQuery( support ) ) {
	        break;
	    }
	    support.ownLast = i !== "0";

	// Note: most support tests are defined in their respective modules.
	// false until the test is run
	    support.inlineBlockNeedsLayout = false;

	// Execute ASAP in case we need to set body.style.zoom
	    jQuery(function() {
	        // Minified: var a,b,c,d
	        var val, div, body, container;

	        body = document.getElementsByTagName( "body" )[ 0 ];
	        if ( !body || !body.style ) {
	            // Return for frameset docs that don't have a body
	            return;
	        }

	        // Setup
	        div = document.createElement( "div" );
	        container = document.createElement( "div" );
	        container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
	        body.appendChild( container ).appendChild( div );

	        if ( typeof div.style.zoom !== strundefined ) {
	            // Support: IE<8
	            // Check if natively block-level elements act like inline-block
	            // elements when setting their display to 'inline' and giving
	            // them layout
	            div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";

	            support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
	            if ( val ) {
	                // Prevent IE 6 from affecting layout for positioned elements #11048
	                // Prevent IE from shrinking the body in IE 7 mode #12869
	                // Support: IE<8
	                body.style.zoom = 1;
	            }
	        }

	        body.removeChild( container );
	    });




	    (function() {
	        var div = document.createElement( "div" );

	        // Execute the test only if not already executed in another module.
	        if (support.deleteExpando == null) {
	            // Support: IE<9
	            support.deleteExpando = true;
	            try {
	                delete div.test;
	            } catch( e ) {
	                support.deleteExpando = false;
	            }
	        }

	        // Null elements to avoid leaks in IE.
	        div = null;
	    })();


	    /**
	     * Determines whether an object can have data
	     */
	    jQuery.acceptData = function( elem ) {
	        var noData = jQuery.noData[ (elem.nodeName + " ").toLowerCase() ],
	            nodeType = +elem.nodeType || 1;

	        // Do not set data on non-element DOM nodes because it will not be cleared (#8335).
	        return nodeType !== 1 && nodeType !== 9 ?
	            false :

	            // Nodes accept data unless otherwise specified; rejection can be conditional
	        !noData || noData !== true && elem.getAttribute("classid") === noData;
	    };


	    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	        rmultiDash = /([A-Z])/g;

	    function dataAttr( elem, key, data ) {
	        // If nothing was found internally, try to fetch any
	        // data from the HTML5 data-* attribute
	        if ( data === undefined && elem.nodeType === 1 ) {

	            var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

	            data = elem.getAttribute( name );

	            if ( typeof data === "string" ) {
	                try {
	                    data = data === "true" ? true :
	                        data === "false" ? false :
	                            data === "null" ? null :
	                                // Only convert to a number if it doesn't change the string
	                                +data + "" === data ? +data :
	                                    rbrace.test( data ) ? jQuery.parseJSON( data ) :
	                                        data;
	                } catch( e ) {}

	                // Make sure we set the data so it isn't changed later
	                jQuery.data( elem, key, data );

	            } else {
	                data = undefined;
	            }
	        }

	        return data;
	    }

	// checks a cache object for emptiness
	    function isEmptyDataObject( obj ) {
	        var name;
	        for ( name in obj ) {

	            // if the public data object is empty, the private is still empty
	            if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
	                continue;
	            }
	            if ( name !== "toJSON" ) {
	                return false;
	            }
	        }

	        return true;
	    }

	    function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
	        if ( !jQuery.acceptData( elem ) ) {
	            return;
	        }

	        var ret, thisCache,
	            internalKey = jQuery.expando,

	        // We have to handle DOM nodes and JS objects differently because IE6-7
	        // can't GC object references properly across the DOM-JS boundary
	            isNode = elem.nodeType,

	        // Only DOM nodes need the global jQuery cache; JS object data is
	        // attached directly to the object so GC can occur automatically
	            cache = isNode ? jQuery.cache : elem,

	        // Only defining an ID for JS objects if its cache already exists allows
	        // the code to shortcut on the same path as a DOM node with no cache
	            id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

	        // Avoid doing any more work than we need to when trying to get data on an
	        // object that has no data at all
	        if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
	            return;
	        }

	        if ( !id ) {
	            // Only DOM nodes need a new unique ID for each element since their data
	            // ends up in the global cache
	            if ( isNode ) {
	                id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
	            } else {
	                id = internalKey;
	            }
	        }

	        if ( !cache[ id ] ) {
	            // Avoid exposing jQuery metadata on plain JS objects when the object
	            // is serialized using JSON.stringify
	            cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
	        }

	        // An object can be passed to jQuery.data instead of a key/value pair; this gets
	        // shallow copied over onto the existing cache
	        if ( typeof name === "object" || typeof name === "function" ) {
	            if ( pvt ) {
	                cache[ id ] = jQuery.extend( cache[ id ], name );
	            } else {
	                cache[ id ].data = jQuery.extend( cache[ id ].data, name );
	            }
	        }

	        thisCache = cache[ id ];

	        // jQuery data() is stored in a separate object inside the object's internal data
	        // cache in order to avoid key collisions between internal data and user-defined
	        // data.
	        if ( !pvt ) {
	            if ( !thisCache.data ) {
	                thisCache.data = {};
	            }

	            thisCache = thisCache.data;
	        }

	        if ( data !== undefined ) {
	            thisCache[ jQuery.camelCase( name ) ] = data;
	        }

	        // Check for both converted-to-camel and non-converted data property names
	        // If a data property was specified
	        if ( typeof name === "string" ) {

	            // First Try to find as-is property data
	            ret = thisCache[ name ];

	            // Test for null|undefined property data
	            if ( ret == null ) {

	                // Try to find the camelCased property
	                ret = thisCache[ jQuery.camelCase( name ) ];
	            }
	        } else {
	            ret = thisCache;
	        }

	        return ret;
	    }

	    function internalRemoveData( elem, name, pvt ) {
	        if ( !jQuery.acceptData( elem ) ) {
	            return;
	        }

	        var thisCache, i,
	            isNode = elem.nodeType,

	        // See jQuery.data for more information
	            cache = isNode ? jQuery.cache : elem,
	            id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	        // If there is already no cache entry for this object, there is no
	        // purpose in continuing
	        if ( !cache[ id ] ) {
	            return;
	        }

	        if ( name ) {

	            thisCache = pvt ? cache[ id ] : cache[ id ].data;

	            if ( thisCache ) {

	                // Support array or space separated string names for data keys
	                if ( !jQuery.isArray( name ) ) {

	                    // try the string as a key before any manipulation
	                    if ( name in thisCache ) {
	                        name = [ name ];
	                    } else {

	                        // split the camel cased version by spaces unless a key with the spaces exists
	                        name = jQuery.camelCase( name );
	                        if ( name in thisCache ) {
	                            name = [ name ];
	                        } else {
	                            name = name.split(" ");
	                        }
	                    }
	                } else {
	                    // If "name" is an array of keys...
	                    // When data is initially created, via ("key", "val") signature,
	                    // keys will be converted to camelCase.
	                    // Since there is no way to tell _how_ a key was added, remove
	                    // both plain key and camelCase key. #12786
	                    // This will only penalize the array argument path.
	                    name = name.concat( jQuery.map( name, jQuery.camelCase ) );
	                }

	                i = name.length;
	                while ( i-- ) {
	                    delete thisCache[ name[i] ];
	                }

	                // If there is no data left in the cache, we want to continue
	                // and let the cache object itself get destroyed
	                if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
	                    return;
	                }
	            }
	        }

	        // See jQuery.data for more information
	        if ( !pvt ) {
	            delete cache[ id ].data;

	            // Don't destroy the parent cache unless the internal data object
	            // had been the only thing left in it
	            if ( !isEmptyDataObject( cache[ id ] ) ) {
	                return;
	            }
	        }

	        // Destroy the cache
	        if ( isNode ) {
	            jQuery.cleanData( [ elem ], true );

	            // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
	            /* jshint eqeqeq: false */
	        } else if ( support.deleteExpando || cache != cache.window ) {
	            /* jshint eqeqeq: true */
	            delete cache[ id ];

	            // When all else fails, null
	        } else {
	            cache[ id ] = null;
	        }
	    }

	    jQuery.extend({
	        cache: {},

	        // The following elements (space-suffixed to avoid Object.prototype collisions)
	        // throw uncatchable exceptions if you attempt to set expando properties
	        noData: {
	            "applet ": true,
	            "embed ": true,
	            // ...but Flash objects (which have this classid) *can* handle expandos
	            "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
	        },

	        hasData: function( elem ) {
	            elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
	            return !!elem && !isEmptyDataObject( elem );
	        },

	        data: function( elem, name, data ) {
	            return internalData( elem, name, data );
	        },

	        removeData: function( elem, name ) {
	            return internalRemoveData( elem, name );
	        },

	        // For internal use only.
	        _data: function( elem, name, data ) {
	            return internalData( elem, name, data, true );
	        },

	        _removeData: function( elem, name ) {
	            return internalRemoveData( elem, name, true );
	        }
	    });

	    jQuery.fn.extend({
	        data: function( key, value ) {
	            var i, name, data,
	                elem = this[0],
	                attrs = elem && elem.attributes;

	            // Special expections of .data basically thwart jQuery.access,
	            // so implement the relevant behavior ourselves

	            // Gets all values
	            if ( key === undefined ) {
	                if ( this.length ) {
	                    data = jQuery.data( elem );

	                    if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
	                        i = attrs.length;
	                        while ( i-- ) {

	                            // Support: IE11+
	                            // The attrs elements can be null (#14894)
	                            if ( attrs[ i ] ) {
	                                name = attrs[ i ].name;
	                                if ( name.indexOf( "data-" ) === 0 ) {
	                                    name = jQuery.camelCase( name.slice(5) );
	                                    dataAttr( elem, name, data[ name ] );
	                                }
	                            }
	                        }
	                        jQuery._data( elem, "parsedAttrs", true );
	                    }
	                }

	                return data;
	            }

	            // Sets multiple values
	            if ( typeof key === "object" ) {
	                return this.each(function() {
	                    jQuery.data( this, key );
	                });
	            }

	            return arguments.length > 1 ?

	                // Sets one value
	                this.each(function() {
	                    jQuery.data( this, key, value );
	                }) :

	                // Gets one value
	                // Try to fetch any internally stored data first
	                elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
	        },

	        removeData: function( key ) {
	            return this.each(function() {
	                jQuery.removeData( this, key );
	            });
	        }
	    });


	    jQuery.extend({
	        queue: function( elem, type, data ) {
	            var queue;

	            if ( elem ) {
	                type = ( type || "fx" ) + "queue";
	                queue = jQuery._data( elem, type );

	                // Speed up dequeue by getting out quickly if this is just a lookup
	                if ( data ) {
	                    if ( !queue || jQuery.isArray(data) ) {
	                        queue = jQuery._data( elem, type, jQuery.makeArray(data) );
	                    } else {
	                        queue.push( data );
	                    }
	                }
	                return queue || [];
	            }
	        },

	        dequeue: function( elem, type ) {
	            type = type || "fx";

	            var queue = jQuery.queue( elem, type ),
	                startLength = queue.length,
	                fn = queue.shift(),
	                hooks = jQuery._queueHooks( elem, type ),
	                next = function() {
	                    jQuery.dequeue( elem, type );
	                };

	            // If the fx queue is dequeued, always remove the progress sentinel
	            if ( fn === "inprogress" ) {
	                fn = queue.shift();
	                startLength--;
	            }

	            if ( fn ) {

	                // Add a progress sentinel to prevent the fx queue from being
	                // automatically dequeued
	                if ( type === "fx" ) {
	                    queue.unshift( "inprogress" );
	                }

	                // clear up the last queue stop function
	                delete hooks.stop;
	                fn.call( elem, next, hooks );
	            }

	            if ( !startLength && hooks ) {
	                hooks.empty.fire();
	            }
	        },

	        // not intended for public consumption - generates a queueHooks object, or returns the current one
	        _queueHooks: function( elem, type ) {
	            var key = type + "queueHooks";
	            return jQuery._data( elem, key ) || jQuery._data( elem, key, {
	                    empty: jQuery.Callbacks("once memory").add(function() {
	                        jQuery._removeData( elem, type + "queue" );
	                        jQuery._removeData( elem, key );
	                    })
	                });
	        }
	    });

	    jQuery.fn.extend({
	        queue: function( type, data ) {
	            var setter = 2;

	            if ( typeof type !== "string" ) {
	                data = type;
	                type = "fx";
	                setter--;
	            }

	            if ( arguments.length < setter ) {
	                return jQuery.queue( this[0], type );
	            }

	            return data === undefined ?
	                this :
	                this.each(function() {
	                    var queue = jQuery.queue( this, type, data );

	                    // ensure a hooks for this queue
	                    jQuery._queueHooks( this, type );

	                    if ( type === "fx" && queue[0] !== "inprogress" ) {
	                        jQuery.dequeue( this, type );
	                    }
	                });
	        },
	        dequeue: function( type ) {
	            return this.each(function() {
	                jQuery.dequeue( this, type );
	            });
	        },
	        clearQueue: function( type ) {
	            return this.queue( type || "fx", [] );
	        },
	        // Get a promise resolved when queues of a certain type
	        // are emptied (fx is the type by default)
	        promise: function( type, obj ) {
	            var tmp,
	                count = 1,
	                defer = jQuery.Deferred(),
	                elements = this,
	                i = this.length,
	                resolve = function() {
	                    if ( !( --count ) ) {
	                        defer.resolveWith( elements, [ elements ] );
	                    }
	                };

	            if ( typeof type !== "string" ) {
	                obj = type;
	                type = undefined;
	            }
	            type = type || "fx";

	            while ( i-- ) {
	                tmp = jQuery._data( elements[ i ], type + "queueHooks" );
	                if ( tmp && tmp.empty ) {
	                    count++;
	                    tmp.empty.add( resolve );
	                }
	            }
	            resolve();
	            return defer.promise( obj );
	        }
	    });
	    var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

	    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	    var isHidden = function( elem, el ) {
	        // isHidden might be called from jQuery#filter function;
	        // in that case, element will be second argument
	        elem = el || elem;
	        return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	    };



	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	    var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	        var i = 0,
	            length = elems.length,
	            bulk = key == null;

	        // Sets many values
	        if ( jQuery.type( key ) === "object" ) {
	            chainable = true;
	            for ( i in key ) {
	                jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
	            }

	            // Sets one value
	        } else if ( value !== undefined ) {
	            chainable = true;

	            if ( !jQuery.isFunction( value ) ) {
	                raw = true;
	            }

	            if ( bulk ) {
	                // Bulk operations run against the entire set
	                if ( raw ) {
	                    fn.call( elems, value );
	                    fn = null;

	                    // ...except when executing function values
	                } else {
	                    bulk = fn;
	                    fn = function( elem, key, value ) {
	                        return bulk.call( jQuery( elem ), value );
	                    };
	                }
	            }

	            if ( fn ) {
	                for ( ; i < length; i++ ) {
	                    fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
	                }
	            }
	        }

	        return chainable ?
	            elems :

	            // Gets
	            bulk ?
	                fn.call( elems ) :
	                length ? fn( elems[0], key ) : emptyGet;
	    };
	    var rcheckableType = (/^(?:checkbox|radio)$/i);



	    (function() {
	        // Minified: var a,b,c
	        var input = document.createElement( "input" ),
	            div = document.createElement( "div" ),
	            fragment = document.createDocumentFragment();

	        // Setup
	        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	        // IE strips leading whitespace when .innerHTML is used
	        support.leadingWhitespace = div.firstChild.nodeType === 3;

	        // Make sure that tbody elements aren't automatically inserted
	        // IE will insert them into empty tables
	        support.tbody = !div.getElementsByTagName( "tbody" ).length;

	        // Make sure that link elements get serialized correctly by innerHTML
	        // This requires a wrapper element in IE
	        support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;

	        // Makes sure cloning an html5 element does not cause problems
	        // Where outerHTML is undefined, this still works
	        support.html5Clone =
	            document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";

	        // Check if a disconnected checkbox will retain its checked
	        // value of true after appended to the DOM (IE6/7)
	        input.type = "checkbox";
	        input.checked = true;
	        fragment.appendChild( input );
	        support.appendChecked = input.checked;

	        // Make sure textarea (and checkbox) defaultValue is properly cloned
	        // Support: IE6-IE11+
	        div.innerHTML = "<textarea>x</textarea>";
	        support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	        // #11217 - WebKit loses check when the name is after the checked attribute
	        fragment.appendChild( div );
	        div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

	        // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	        // old WebKit doesn't clone checked state correctly in fragments
	        support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	        // Support: IE<9
	        // Opera does not clone events (and typeof div.attachEvent === undefined).
	        // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
	        support.noCloneEvent = true;
	        if ( div.attachEvent ) {
	            div.attachEvent( "onclick", function() {
	                support.noCloneEvent = false;
	            });

	            div.cloneNode( true ).click();
	        }

	        // Execute the test only if not already executed in another module.
	        if (support.deleteExpando == null) {
	            // Support: IE<9
	            support.deleteExpando = true;
	            try {
	                delete div.test;
	            } catch( e ) {
	                support.deleteExpando = false;
	            }
	        }
	    })();


	    (function() {
	        var i, eventName,
	            div = document.createElement( "div" );

	        // Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
	        for ( i in { submit: true, change: true, focusin: true }) {
	            eventName = "on" + i;

	            if ( !(support[ i + "Bubbles" ] = eventName in window) ) {
	                // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
	                div.setAttribute( eventName, "t" );
	                support[ i + "Bubbles" ] = div.attributes[ eventName ].expando === false;
	            }
	        }

	        // Null elements to avoid leaks in IE.
	        div = null;
	    })();


	    var rformElems = /^(?:input|select|textarea)$/i,
	        rkeyEvent = /^key/,
	        rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	        rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

	    function returnTrue() {
	        return true;
	    }

	    function returnFalse() {
	        return false;
	    }

	    function safeActiveElement() {
	        try {
	            return document.activeElement;
	        } catch ( err ) { }
	    }

	    /*
	     * Helper functions for managing events -- not part of the public interface.
	     * Props to Dean Edwards' addEvent library for many of the ideas.
	     */
	    jQuery.event = {

	        global: {},

	        add: function( elem, types, handler, data, selector ) {
	            var tmp, events, t, handleObjIn,
	                special, eventHandle, handleObj,
	                handlers, type, namespaces, origType,
	                elemData = jQuery._data( elem );

	            // Don't attach events to noData or text/comment nodes (but allow plain objects)
	            if ( !elemData ) {
	                return;
	            }

	            // Caller can pass in an object of custom data in lieu of the handler
	            if ( handler.handler ) {
	                handleObjIn = handler;
	                handler = handleObjIn.handler;
	                selector = handleObjIn.selector;
	            }

	            // Make sure that the handler has a unique ID, used to find/remove it later
	            if ( !handler.guid ) {
	                handler.guid = jQuery.guid++;
	            }

	            // Init the element's event structure and main handler, if this is the first
	            if ( !(events = elemData.events) ) {
	                events = elemData.events = {};
	            }
	            if ( !(eventHandle = elemData.handle) ) {
	                eventHandle = elemData.handle = function( e ) {
	                    // Discard the second event of a jQuery.event.trigger() and
	                    // when an event is called after a page has unloaded
	                    return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?
	                        jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
	                        undefined;
	                };
	                // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
	                eventHandle.elem = elem;
	            }

	            // Handle multiple events separated by a space
	            types = ( types || "" ).match( rnotwhite ) || [ "" ];
	            t = types.length;
	            while ( t-- ) {
	                tmp = rtypenamespace.exec( types[t] ) || [];
	                type = origType = tmp[1];
	                namespaces = ( tmp[2] || "" ).split( "." ).sort();

	                // There *must* be a type, no attaching namespace-only handlers
	                if ( !type ) {
	                    continue;
	                }

	                // If event changes its type, use the special event handlers for the changed type
	                special = jQuery.event.special[ type ] || {};

	                // If selector defined, determine special event api type, otherwise given type
	                type = ( selector ? special.delegateType : special.bindType ) || type;

	                // Update special based on newly reset type
	                special = jQuery.event.special[ type ] || {};

	                // handleObj is passed to all event handlers
	                handleObj = jQuery.extend({
	                    type: type,
	                    origType: origType,
	                    data: data,
	                    handler: handler,
	                    guid: handler.guid,
	                    selector: selector,
	                    needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
	                    namespace: namespaces.join(".")
	                }, handleObjIn );

	                // Init the event handler queue if we're the first
	                if ( !(handlers = events[ type ]) ) {
	                    handlers = events[ type ] = [];
	                    handlers.delegateCount = 0;

	                    // Only use addEventListener/attachEvent if the special events handler returns false
	                    if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
	                        // Bind the global event handler to the element
	                        if ( elem.addEventListener ) {
	                            elem.addEventListener( type, eventHandle, false );

	                        } else if ( elem.attachEvent ) {
	                            elem.attachEvent( "on" + type, eventHandle );
	                        }
	                    }
	                }

	                if ( special.add ) {
	                    special.add.call( elem, handleObj );

	                    if ( !handleObj.handler.guid ) {
	                        handleObj.handler.guid = handler.guid;
	                    }
	                }

	                // Add to the element's handler list, delegates in front
	                if ( selector ) {
	                    handlers.splice( handlers.delegateCount++, 0, handleObj );
	                } else {
	                    handlers.push( handleObj );
	                }

	                // Keep track of which events have ever been used, for event optimization
	                jQuery.event.global[ type ] = true;
	            }

	            // Nullify elem to prevent memory leaks in IE
	            elem = null;
	        },

	        // Detach an event or set of events from an element
	        remove: function( elem, types, handler, selector, mappedTypes ) {
	            var j, handleObj, tmp,
	                origCount, t, events,
	                special, handlers, type,
	                namespaces, origType,
	                elemData = jQuery.hasData( elem ) && jQuery._data( elem );

	            if ( !elemData || !(events = elemData.events) ) {
	                return;
	            }

	            // Once for each type.namespace in types; type may be omitted
	            types = ( types || "" ).match( rnotwhite ) || [ "" ];
	            t = types.length;
	            while ( t-- ) {
	                tmp = rtypenamespace.exec( types[t] ) || [];
	                type = origType = tmp[1];
	                namespaces = ( tmp[2] || "" ).split( "." ).sort();

	                // Unbind all events (on this namespace, if provided) for the element
	                if ( !type ) {
	                    for ( type in events ) {
	                        jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
	                    }
	                    continue;
	                }

	                special = jQuery.event.special[ type ] || {};
	                type = ( selector ? special.delegateType : special.bindType ) || type;
	                handlers = events[ type ] || [];
	                tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

	                // Remove matching events
	                origCount = j = handlers.length;
	                while ( j-- ) {
	                    handleObj = handlers[ j ];

	                    if ( ( mappedTypes || origType === handleObj.origType ) &&
	                        ( !handler || handler.guid === handleObj.guid ) &&
	                        ( !tmp || tmp.test( handleObj.namespace ) ) &&
	                        ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
	                        handlers.splice( j, 1 );

	                        if ( handleObj.selector ) {
	                            handlers.delegateCount--;
	                        }
	                        if ( special.remove ) {
	                            special.remove.call( elem, handleObj );
	                        }
	                    }
	                }

	                // Remove generic event handler if we removed something and no more handlers exist
	                // (avoids potential for endless recursion during removal of special event handlers)
	                if ( origCount && !handlers.length ) {
	                    if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
	                        jQuery.removeEvent( elem, type, elemData.handle );
	                    }

	                    delete events[ type ];
	                }
	            }

	            // Remove the expando if it's no longer used
	            if ( jQuery.isEmptyObject( events ) ) {
	                delete elemData.handle;

	                // removeData also checks for emptiness and clears the expando if empty
	                // so use it instead of delete
	                jQuery._removeData( elem, "events" );
	            }
	        },

	        trigger: function( event, data, elem, onlyHandlers ) {
	            var handle, ontype, cur,
	                bubbleType, special, tmp, i,
	                eventPath = [ elem || document ],
	                type = hasOwn.call( event, "type" ) ? event.type : event,
	                namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

	            cur = tmp = elem = elem || document;

	            // Don't do events on text and comment nodes
	            if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
	                return;
	            }

	            // focus/blur morphs to focusin/out; ensure we're not firing them right now
	            if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
	                return;
	            }

	            if ( type.indexOf(".") >= 0 ) {
	                // Namespaced trigger; create a regexp to match event type in handle()
	                namespaces = type.split(".");
	                type = namespaces.shift();
	                namespaces.sort();
	            }
	            ontype = type.indexOf(":") < 0 && "on" + type;

	            // Caller can pass in a jQuery.Event object, Object, or just an event type string
	            event = event[ jQuery.expando ] ?
	                event :
	                new jQuery.Event( type, typeof event === "object" && event );

	            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
	            event.isTrigger = onlyHandlers ? 2 : 3;
	            event.namespace = namespaces.join(".");
	            event.namespace_re = event.namespace ?
	                new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
	                null;

	            // Clean up the event in case it is being reused
	            event.result = undefined;
	            if ( !event.target ) {
	                event.target = elem;
	            }

	            // Clone any incoming data and prepend the event, creating the handler arg list
	            data = data == null ?
	                [ event ] :
	                jQuery.makeArray( data, [ event ] );

	            // Allow special events to draw outside the lines
	            special = jQuery.event.special[ type ] || {};
	            if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
	                return;
	            }

	            // Determine event propagation path in advance, per W3C events spec (#9951)
	            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
	            if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

	                bubbleType = special.delegateType || type;
	                if ( !rfocusMorph.test( bubbleType + type ) ) {
	                    cur = cur.parentNode;
	                }
	                for ( ; cur; cur = cur.parentNode ) {
	                    eventPath.push( cur );
	                    tmp = cur;
	                }

	                // Only add window if we got to document (e.g., not plain obj or detached DOM)
	                if ( tmp === (elem.ownerDocument || document) ) {
	                    eventPath.push( tmp.defaultView || tmp.parentWindow || window );
	                }
	            }

	            // Fire handlers on the event path
	            i = 0;
	            while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

	                event.type = i > 1 ?
	                    bubbleType :
	                special.bindType || type;

	                // jQuery handler
	                handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
	                if ( handle ) {
	                    handle.apply( cur, data );
	                }

	                // Native handler
	                handle = ontype && cur[ ontype ];
	                if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
	                    event.result = handle.apply( cur, data );
	                    if ( event.result === false ) {
	                        event.preventDefault();
	                    }
	                }
	            }
	            event.type = type;

	            // If nobody prevented the default action, do it now
	            if ( !onlyHandlers && !event.isDefaultPrevented() ) {

	                if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
	                    jQuery.acceptData( elem ) ) {

	                    // Call a native DOM method on the target with the same name name as the event.
	                    // Can't use an .isFunction() check here because IE6/7 fails that test.
	                    // Don't do default actions on window, that's where global variables be (#6170)
	                    if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

	                        // Don't re-trigger an onFOO event when we call its FOO() method
	                        tmp = elem[ ontype ];

	                        if ( tmp ) {
	                            elem[ ontype ] = null;
	                        }

	                        // Prevent re-triggering of the same event, since we already bubbled it above
	                        jQuery.event.triggered = type;
	                        try {
	                            elem[ type ]();
	                        } catch ( e ) {
	                            // IE<9 dies on focus/blur to hidden element (#1486,#12518)
	                            // only reproducible on winXP IE8 native, not IE9 in IE8 mode
	                        }
	                        jQuery.event.triggered = undefined;

	                        if ( tmp ) {
	                            elem[ ontype ] = tmp;
	                        }
	                    }
	                }
	            }

	            return event.result;
	        },

	        dispatch: function( event ) {

	            // Make a writable jQuery.Event from the native event object
	            event = jQuery.event.fix( event );

	            var i, ret, handleObj, matched, j,
	                handlerQueue = [],
	                args = slice.call( arguments ),
	                handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
	                special = jQuery.event.special[ event.type ] || {};

	            // Use the fix-ed jQuery.Event rather than the (read-only) native event
	            args[0] = event;
	            event.delegateTarget = this;

	            // Call the preDispatch hook for the mapped type, and let it bail if desired
	            if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
	                return;
	            }

	            // Determine handlers
	            handlerQueue = jQuery.event.handlers.call( this, event, handlers );

	            // Run delegates first; they may want to stop propagation beneath us
	            i = 0;
	            while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
	                event.currentTarget = matched.elem;

	                j = 0;
	                while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

	                    // Triggered event must either 1) have no namespace, or
	                    // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
	                    if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

	                        event.handleObj = handleObj;
	                        event.data = handleObj.data;

	                        ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
	                            .apply( matched.elem, args );

	                        if ( ret !== undefined ) {
	                            if ( (event.result = ret) === false ) {
	                                event.preventDefault();
	                                event.stopPropagation();
	                            }
	                        }
	                    }
	                }
	            }

	            // Call the postDispatch hook for the mapped type
	            if ( special.postDispatch ) {
	                special.postDispatch.call( this, event );
	            }

	            return event.result;
	        },

	        handlers: function( event, handlers ) {
	            var sel, handleObj, matches, i,
	                handlerQueue = [],
	                delegateCount = handlers.delegateCount,
	                cur = event.target;

	            // Find delegate handlers
	            // Black-hole SVG <use> instance trees (#13180)
	            // Avoid non-left-click bubbling in Firefox (#3861)
	            if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

	                /* jshint eqeqeq: false */
	                for ( ; cur != this; cur = cur.parentNode || this ) {
	                    /* jshint eqeqeq: true */

	                    // Don't check non-elements (#13208)
	                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
	                    if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
	                        matches = [];
	                        for ( i = 0; i < delegateCount; i++ ) {
	                            handleObj = handlers[ i ];

	                            // Don't conflict with Object.prototype properties (#13203)
	                            sel = handleObj.selector + " ";

	                            if ( matches[ sel ] === undefined ) {
	                                matches[ sel ] = handleObj.needsContext ?
	                                jQuery( sel, this ).index( cur ) >= 0 :
	                                    jQuery.find( sel, this, null, [ cur ] ).length;
	                            }
	                            if ( matches[ sel ] ) {
	                                matches.push( handleObj );
	                            }
	                        }
	                        if ( matches.length ) {
	                            handlerQueue.push({ elem: cur, handlers: matches });
	                        }
	                    }
	                }
	            }

	            // Add the remaining (directly-bound) handlers
	            if ( delegateCount < handlers.length ) {
	                handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
	            }

	            return handlerQueue;
	        },

	        fix: function( event ) {
	            if ( event[ jQuery.expando ] ) {
	                return event;
	            }

	            // Create a writable copy of the event object and normalize some properties
	            var i, prop, copy,
	                type = event.type,
	                originalEvent = event,
	                fixHook = this.fixHooks[ type ];

	            if ( !fixHook ) {
	                this.fixHooks[ type ] = fixHook =
	                    rmouseEvent.test( type ) ? this.mouseHooks :
	                        rkeyEvent.test( type ) ? this.keyHooks :
	                        {};
	            }
	            copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

	            event = new jQuery.Event( originalEvent );

	            i = copy.length;
	            while ( i-- ) {
	                prop = copy[ i ];
	                event[ prop ] = originalEvent[ prop ];
	            }

	            // Support: IE<9
	            // Fix target property (#1925)
	            if ( !event.target ) {
	                event.target = originalEvent.srcElement || document;
	            }

	            // Support: Chrome 23+, Safari?
	            // Target should not be a text node (#504, #13143)
	            if ( event.target.nodeType === 3 ) {
	                event.target = event.target.parentNode;
	            }

	            // Support: IE<9
	            // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
	            event.metaKey = !!event.metaKey;

	            return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	        },

	        // Includes some event props shared by KeyEvent and MouseEvent
	        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	        fixHooks: {},

	        keyHooks: {
	            props: "char charCode key keyCode".split(" "),
	            filter: function( event, original ) {

	                // Add which for key events
	                if ( event.which == null ) {
	                    event.which = original.charCode != null ? original.charCode : original.keyCode;
	                }

	                return event;
	            }
	        },

	        mouseHooks: {
	            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
	            filter: function( event, original ) {
	                var body, eventDoc, doc,
	                    button = original.button,
	                    fromElement = original.fromElement;

	                // Calculate pageX/Y if missing and clientX/Y available
	                if ( event.pageX == null && original.clientX != null ) {
	                    eventDoc = event.target.ownerDocument || document;
	                    doc = eventDoc.documentElement;
	                    body = eventDoc.body;

	                    event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
	                    event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
	                }

	                // Add relatedTarget, if necessary
	                if ( !event.relatedTarget && fromElement ) {
	                    event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
	                }

	                // Add which for click: 1 === left; 2 === middle; 3 === right
	                // Note: button is not normalized, so don't use it
	                if ( !event.which && button !== undefined ) {
	                    event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
	                }

	                return event;
	            }
	        },

	        special: {
	            load: {
	                // Prevent triggered image.load events from bubbling to window.load
	                noBubble: true
	            },
	            focus: {
	                // Fire native event if possible so blur/focus sequence is correct
	                trigger: function() {
	                    if ( this !== safeActiveElement() && this.focus ) {
	                        try {
	                            this.focus();
	                            return false;
	                        } catch ( e ) {
	                            // Support: IE<9
	                            // If we error on focus to hidden element (#1486, #12518),
	                            // let .trigger() run the handlers
	                        }
	                    }
	                },
	                delegateType: "focusin"
	            },
	            blur: {
	                trigger: function() {
	                    if ( this === safeActiveElement() && this.blur ) {
	                        this.blur();
	                        return false;
	                    }
	                },
	                delegateType: "focusout"
	            },
	            click: {
	                // For checkbox, fire native event so checked state will be right
	                trigger: function() {
	                    if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
	                        this.click();
	                        return false;
	                    }
	                },

	                // For cross-browser consistency, don't fire native .click() on links
	                _default: function( event ) {
	                    return jQuery.nodeName( event.target, "a" );
	                }
	            },

	            beforeunload: {
	                postDispatch: function( event ) {

	                    // Support: Firefox 20+
	                    // Firefox doesn't alert if the returnValue field is not set.
	                    if ( event.result !== undefined && event.originalEvent ) {
	                        event.originalEvent.returnValue = event.result;
	                    }
	                }
	            }
	        },

	        simulate: function( type, elem, event, bubble ) {
	            // Piggyback on a donor event to simulate a different one.
	            // Fake originalEvent to avoid donor's stopPropagation, but if the
	            // simulated event prevents default then we do the same on the donor.
	            var e = jQuery.extend(
	                new jQuery.Event(),
	                event,
	                {
	                    type: type,
	                    isSimulated: true,
	                    originalEvent: {}
	                }
	            );
	            if ( bubble ) {
	                jQuery.event.trigger( e, null, elem );
	            } else {
	                jQuery.event.dispatch.call( elem, e );
	            }
	            if ( e.isDefaultPrevented() ) {
	                event.preventDefault();
	            }
	        }
	    };

	    jQuery.removeEvent = document.removeEventListener ?
	        function( elem, type, handle ) {
	            if ( elem.removeEventListener ) {
	                elem.removeEventListener( type, handle, false );
	            }
	        } :
	        function( elem, type, handle ) {
	            var name = "on" + type;

	            if ( elem.detachEvent ) {

	                // #8545, #7054, preventing memory leaks for custom events in IE6-8
	                // detachEvent needed property on element, by name of that event, to properly expose it to GC
	                if ( typeof elem[ name ] === strundefined ) {
	                    elem[ name ] = null;
	                }

	                elem.detachEvent( name, handle );
	            }
	        };

	    jQuery.Event = function( src, props ) {
	        // Allow instantiation without the 'new' keyword
	        if ( !(this instanceof jQuery.Event) ) {
	            return new jQuery.Event( src, props );
	        }

	        // Event object
	        if ( src && src.type ) {
	            this.originalEvent = src;
	            this.type = src.type;

	            // Events bubbling up the document may have been marked as prevented
	            // by a handler lower down the tree; reflect the correct value.
	            this.isDefaultPrevented = src.defaultPrevented ||
	            src.defaultPrevented === undefined &&
	            // Support: IE < 9, Android < 4.0
	            src.returnValue === false ?
	                returnTrue :
	                returnFalse;

	            // Event type
	        } else {
	            this.type = src;
	        }

	        // Put explicitly provided properties onto the event object
	        if ( props ) {
	            jQuery.extend( this, props );
	        }

	        // Create a timestamp if incoming event doesn't have one
	        this.timeStamp = src && src.timeStamp || jQuery.now();

	        // Mark it as fixed
	        this[ jQuery.expando ] = true;
	    };

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	    jQuery.Event.prototype = {
	        isDefaultPrevented: returnFalse,
	        isPropagationStopped: returnFalse,
	        isImmediatePropagationStopped: returnFalse,

	        preventDefault: function() {
	            var e = this.originalEvent;

	            this.isDefaultPrevented = returnTrue;
	            if ( !e ) {
	                return;
	            }

	            // If preventDefault exists, run it on the original event
	            if ( e.preventDefault ) {
	                e.preventDefault();

	                // Support: IE
	                // Otherwise set the returnValue property of the original event to false
	            } else {
	                e.returnValue = false;
	            }
	        },
	        stopPropagation: function() {
	            var e = this.originalEvent;

	            this.isPropagationStopped = returnTrue;
	            if ( !e ) {
	                return;
	            }
	            // If stopPropagation exists, run it on the original event
	            if ( e.stopPropagation ) {
	                e.stopPropagation();
	            }

	            // Support: IE
	            // Set the cancelBubble property of the original event to true
	            e.cancelBubble = true;
	        },
	        stopImmediatePropagation: function() {
	            var e = this.originalEvent;

	            this.isImmediatePropagationStopped = returnTrue;

	            if ( e && e.stopImmediatePropagation ) {
	                e.stopImmediatePropagation();
	            }

	            this.stopPropagation();
	        }
	    };

	// Create mouseenter/leave events using mouseover/out and event-time checks
	    jQuery.each({
	        mouseenter: "mouseover",
	        mouseleave: "mouseout",
	        pointerenter: "pointerover",
	        pointerleave: "pointerout"
	    }, function( orig, fix ) {
	        jQuery.event.special[ orig ] = {
	            delegateType: fix,
	            bindType: fix,

	            handle: function( event ) {
	                var ret,
	                    target = this,
	                    related = event.relatedTarget,
	                    handleObj = event.handleObj;

	                // For mousenter/leave call the handler if related is outside the target.
	                // NB: No relatedTarget if the mouse left/entered the browser window
	                if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
	                    event.type = handleObj.origType;
	                    ret = handleObj.handler.apply( this, arguments );
	                    event.type = fix;
	                }
	                return ret;
	            }
	        };
	    });

	// IE submit delegation
	    if ( !support.submitBubbles ) {

	        jQuery.event.special.submit = {
	            setup: function() {
	                // Only need this for delegated form submit events
	                if ( jQuery.nodeName( this, "form" ) ) {
	                    return false;
	                }

	                // Lazy-add a submit handler when a descendant form may potentially be submitted
	                jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
	                    // Node name check avoids a VML-related crash in IE (#9807)
	                    var elem = e.target,
	                        form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
	                    if ( form && !jQuery._data( form, "submitBubbles" ) ) {
	                        jQuery.event.add( form, "submit._submit", function( event ) {
	                            event._submit_bubble = true;
	                        });
	                        jQuery._data( form, "submitBubbles", true );
	                    }
	                });
	                // return undefined since we don't need an event listener
	            },

	            postDispatch: function( event ) {
	                // If form was submitted by the user, bubble the event up the tree
	                if ( event._submit_bubble ) {
	                    delete event._submit_bubble;
	                    if ( this.parentNode && !event.isTrigger ) {
	                        jQuery.event.simulate( "submit", this.parentNode, event, true );
	                    }
	                }
	            },

	            teardown: function() {
	                // Only need this for delegated form submit events
	                if ( jQuery.nodeName( this, "form" ) ) {
	                    return false;
	                }

	                // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
	                jQuery.event.remove( this, "._submit" );
	            }
	        };
	    }

	// IE change delegation and checkbox/radio fix
	    if ( !support.changeBubbles ) {

	        jQuery.event.special.change = {

	            setup: function() {

	                if ( rformElems.test( this.nodeName ) ) {
	                    // IE doesn't fire change on a check/radio until blur; trigger it on click
	                    // after a propertychange. Eat the blur-change in special.change.handle.
	                    // This still fires onchange a second time for check/radio after blur.
	                    if ( this.type === "checkbox" || this.type === "radio" ) {
	                        jQuery.event.add( this, "propertychange._change", function( event ) {
	                            if ( event.originalEvent.propertyName === "checked" ) {
	                                this._just_changed = true;
	                            }
	                        });
	                        jQuery.event.add( this, "click._change", function( event ) {
	                            if ( this._just_changed && !event.isTrigger ) {
	                                this._just_changed = false;
	                            }
	                            // Allow triggered, simulated change events (#11500)
	                            jQuery.event.simulate( "change", this, event, true );
	                        });
	                    }
	                    return false;
	                }
	                // Delegated event; lazy-add a change handler on descendant inputs
	                jQuery.event.add( this, "beforeactivate._change", function( e ) {
	                    var elem = e.target;

	                    if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
	                        jQuery.event.add( elem, "change._change", function( event ) {
	                            if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
	                                jQuery.event.simulate( "change", this.parentNode, event, true );
	                            }
	                        });
	                        jQuery._data( elem, "changeBubbles", true );
	                    }
	                });
	            },

	            handle: function( event ) {
	                var elem = event.target;

	                // Swallow native change events from checkbox/radio, we already triggered them above
	                if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
	                    return event.handleObj.handler.apply( this, arguments );
	                }
	            },

	            teardown: function() {
	                jQuery.event.remove( this, "._change" );

	                return !rformElems.test( this.nodeName );
	            }
	        };
	    }

	// Create "bubbling" focus and blur events
	    if ( !support.focusinBubbles ) {
	        jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

	            // Attach a single capturing handler on the document while someone wants focusin/focusout
	            var handler = function( event ) {
	                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
	            };

	            jQuery.event.special[ fix ] = {
	                setup: function() {
	                    var doc = this.ownerDocument || this,
	                        attaches = jQuery._data( doc, fix );

	                    if ( !attaches ) {
	                        doc.addEventListener( orig, handler, true );
	                    }
	                    jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
	                },
	                teardown: function() {
	                    var doc = this.ownerDocument || this,
	                        attaches = jQuery._data( doc, fix ) - 1;

	                    if ( !attaches ) {
	                        doc.removeEventListener( orig, handler, true );
	                        jQuery._removeData( doc, fix );
	                    } else {
	                        jQuery._data( doc, fix, attaches );
	                    }
	                }
	            };
	        });
	    }

	    jQuery.fn.extend({

	        on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
	            var type, origFn;

	            // Types can be a map of types/handlers
	            if ( typeof types === "object" ) {
	                // ( types-Object, selector, data )
	                if ( typeof selector !== "string" ) {
	                    // ( types-Object, data )
	                    data = data || selector;
	                    selector = undefined;
	                }
	                for ( type in types ) {
	                    this.on( type, selector, data, types[ type ], one );
	                }
	                return this;
	            }

	            if ( data == null && fn == null ) {
	                // ( types, fn )
	                fn = selector;
	                data = selector = undefined;
	            } else if ( fn == null ) {
	                if ( typeof selector === "string" ) {
	                    // ( types, selector, fn )
	                    fn = data;
	                    data = undefined;
	                } else {
	                    // ( types, data, fn )
	                    fn = data;
	                    data = selector;
	                    selector = undefined;
	                }
	            }
	            if ( fn === false ) {
	                fn = returnFalse;
	            } else if ( !fn ) {
	                return this;
	            }

	            if ( one === 1 ) {
	                origFn = fn;
	                fn = function( event ) {
	                    // Can use an empty set, since event contains the info
	                    jQuery().off( event );
	                    return origFn.apply( this, arguments );
	                };
	                // Use same guid so caller can remove using origFn
	                fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	            }
	            return this.each( function() {
	                jQuery.event.add( this, types, fn, data, selector );
	            });
	        },
	        one: function( types, selector, data, fn ) {
	            return this.on( types, selector, data, fn, 1 );
	        },
	        off: function( types, selector, fn ) {
	            var handleObj, type;
	            if ( types && types.preventDefault && types.handleObj ) {
	                // ( event )  dispatched jQuery.Event
	                handleObj = types.handleObj;
	                jQuery( types.delegateTarget ).off(
	                    handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
	                    handleObj.selector,
	                    handleObj.handler
	                );
	                return this;
	            }
	            if ( typeof types === "object" ) {
	                // ( types-object [, selector] )
	                for ( type in types ) {
	                    this.off( type, selector, types[ type ] );
	                }
	                return this;
	            }
	            if ( selector === false || typeof selector === "function" ) {
	                // ( types [, fn] )
	                fn = selector;
	                selector = undefined;
	            }
	            if ( fn === false ) {
	                fn = returnFalse;
	            }
	            return this.each(function() {
	                jQuery.event.remove( this, types, fn, selector );
	            });
	        },

	        trigger: function( type, data ) {
	            return this.each(function() {
	                jQuery.event.trigger( type, data, this );
	            });
	        },
	        triggerHandler: function( type, data ) {
	            var elem = this[0];
	            if ( elem ) {
	                return jQuery.event.trigger( type, data, elem, true );
	            }
	        }
	    });


	    function createSafeFragment( document ) {
	        var list = nodeNames.split( "|" ),
	            safeFrag = document.createDocumentFragment();

	        if ( safeFrag.createElement ) {
	            while ( list.length ) {
	                safeFrag.createElement(
	                    list.pop()
	                );
	            }
	        }
	        return safeFrag;
	    }

	    var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
	            "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	        rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	        rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	        rleadingWhitespace = /^\s+/,
	        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	        rtagName = /<([\w:]+)/,
	        rtbody = /<tbody/i,
	        rhtml = /<|&#?\w+;/,
	        rnoInnerhtml = /<(?:script|style|link)/i,
	    // checked="checked" or checked
	        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	        rscriptType = /^$|\/(?:java|ecma)script/i,
	        rscriptTypeMasked = /^true\/(.*)/,
	        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	    // We have to close these tags to support XHTML (#13200)
	        wrapMap = {
	            option: [ 1, "<select multiple='multiple'>", "</select>" ],
	            legend: [ 1, "<fieldset>", "</fieldset>" ],
	            area: [ 1, "<map>", "</map>" ],
	            param: [ 1, "<object>", "</object>" ],
	            thead: [ 1, "<table>", "</table>" ],
	            tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	            col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
	            td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	            // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
	            // unless wrapped in a div with non-breaking characters in front of it.
	            _default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
	        },
	        safeFragment = createSafeFragment( document ),
	        fragmentDiv = safeFragment.appendChild( document.createElement("div") );

	    wrapMap.optgroup = wrapMap.option;
	    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	    wrapMap.th = wrapMap.td;

	    function getAll( context, tag ) {
	        var elems, elem,
	            i = 0,
	            found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || "*" ) :
	                typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || "*" ) :
	                    undefined;

	        if ( !found ) {
	            for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
	                if ( !tag || jQuery.nodeName( elem, tag ) ) {
	                    found.push( elem );
	                } else {
	                    jQuery.merge( found, getAll( elem, tag ) );
	                }
	            }
	        }

	        return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
	            jQuery.merge( [ context ], found ) :
	            found;
	    }

	// Used in buildFragment, fixes the defaultChecked property
	    function fixDefaultChecked( elem ) {
	        if ( rcheckableType.test( elem.type ) ) {
	            elem.defaultChecked = elem.checked;
	        }
	    }

	// Support: IE<8
	// Manipulating tables requires a tbody
	    function manipulationTarget( elem, content ) {
	        return jQuery.nodeName( elem, "table" ) &&
	        jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

	        elem.getElementsByTagName("tbody")[0] ||
	        elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
	            elem;
	    }

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	    function disableScript( elem ) {
	        elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
	        return elem;
	    }
	    function restoreScript( elem ) {
	        var match = rscriptTypeMasked.exec( elem.type );
	        if ( match ) {
	            elem.type = match[1];
	        } else {
	            elem.removeAttribute("type");
	        }
	        return elem;
	    }

	// Mark scripts as having already been evaluated
	    function setGlobalEval( elems, refElements ) {
	        var elem,
	            i = 0;
	        for ( ; (elem = elems[i]) != null; i++ ) {
	            jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
	        }
	    }

	    function cloneCopyEvent( src, dest ) {

	        if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
	            return;
	        }

	        var type, i, l,
	            oldData = jQuery._data( src ),
	            curData = jQuery._data( dest, oldData ),
	            events = oldData.events;

	        if ( events ) {
	            delete curData.handle;
	            curData.events = {};

	            for ( type in events ) {
	                for ( i = 0, l = events[ type ].length; i < l; i++ ) {
	                    jQuery.event.add( dest, type, events[ type ][ i ] );
	                }
	            }
	        }

	        // make the cloned public data object a copy from the original
	        if ( curData.data ) {
	            curData.data = jQuery.extend( {}, curData.data );
	        }
	    }

	    function fixCloneNodeIssues( src, dest ) {
	        var nodeName, e, data;

	        // We do not need to do anything for non-Elements
	        if ( dest.nodeType !== 1 ) {
	            return;
	        }

	        nodeName = dest.nodeName.toLowerCase();

	        // IE6-8 copies events bound via attachEvent when using cloneNode.
	        if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
	            data = jQuery._data( dest );

	            for ( e in data.events ) {
	                jQuery.removeEvent( dest, e, data.handle );
	            }

	            // Event data gets referenced instead of copied if the expando gets copied too
	            dest.removeAttribute( jQuery.expando );
	        }

	        // IE blanks contents when cloning scripts, and tries to evaluate newly-set text
	        if ( nodeName === "script" && dest.text !== src.text ) {
	            disableScript( dest ).text = src.text;
	            restoreScript( dest );

	            // IE6-10 improperly clones children of object elements using classid.
	            // IE10 throws NoModificationAllowedError if parent is null, #12132.
	        } else if ( nodeName === "object" ) {
	            if ( dest.parentNode ) {
	                dest.outerHTML = src.outerHTML;
	            }

	            // This path appears unavoidable for IE9. When cloning an object
	            // element in IE9, the outerHTML strategy above is not sufficient.
	            // If the src has innerHTML and the destination does not,
	            // copy the src.innerHTML into the dest.innerHTML. #10324
	            if ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
	                dest.innerHTML = src.innerHTML;
	            }

	        } else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
	            // IE6-8 fails to persist the checked state of a cloned checkbox
	            // or radio button. Worse, IE6-7 fail to give the cloned element
	            // a checked appearance if the defaultChecked value isn't also set

	            dest.defaultChecked = dest.checked = src.checked;

	            // IE6-7 get confused and end up setting the value of a cloned
	            // checkbox/radio button to an empty string instead of "on"
	            if ( dest.value !== src.value ) {
	                dest.value = src.value;
	            }

	            // IE6-8 fails to return the selected option to the default selected
	            // state when cloning options
	        } else if ( nodeName === "option" ) {
	            dest.defaultSelected = dest.selected = src.defaultSelected;

	            // IE6-8 fails to set the defaultValue to the correct value when
	            // cloning other types of input fields
	        } else if ( nodeName === "input" || nodeName === "textarea" ) {
	            dest.defaultValue = src.defaultValue;
	        }
	    }

	    jQuery.extend({
	        clone: function( elem, dataAndEvents, deepDataAndEvents ) {
	            var destElements, node, clone, i, srcElements,
	                inPage = jQuery.contains( elem.ownerDocument, elem );

	            if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
	                clone = elem.cloneNode( true );

	                // IE<=8 does not properly clone detached, unknown element nodes
	            } else {
	                fragmentDiv.innerHTML = elem.outerHTML;
	                fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
	            }

	            if ( (!support.noCloneEvent || !support.noCloneChecked) &&
	                (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

	                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
	                destElements = getAll( clone );
	                srcElements = getAll( elem );

	                // Fix all IE cloning issues
	                for ( i = 0; (node = srcElements[i]) != null; ++i ) {
	                    // Ensure that the destination node is not null; Fixes #9587
	                    if ( destElements[i] ) {
	                        fixCloneNodeIssues( node, destElements[i] );
	                    }
	                }
	            }

	            // Copy the events from the original to the clone
	            if ( dataAndEvents ) {
	                if ( deepDataAndEvents ) {
	                    srcElements = srcElements || getAll( elem );
	                    destElements = destElements || getAll( clone );

	                    for ( i = 0; (node = srcElements[i]) != null; i++ ) {
	                        cloneCopyEvent( node, destElements[i] );
	                    }
	                } else {
	                    cloneCopyEvent( elem, clone );
	                }
	            }

	            // Preserve script evaluation history
	            destElements = getAll( clone, "script" );
	            if ( destElements.length > 0 ) {
	                setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
	            }

	            destElements = srcElements = node = null;

	            // Return the cloned set
	            return clone;
	        },

	        buildFragment: function( elems, context, scripts, selection ) {
	            var j, elem, contains,
	                tmp, tag, tbody, wrap,
	                l = elems.length,

	            // Ensure a safe fragment
	                safe = createSafeFragment( context ),

	                nodes = [],
	                i = 0;

	            for ( ; i < l; i++ ) {
	                elem = elems[ i ];

	                if ( elem || elem === 0 ) {

	                    // Add nodes directly
	                    if ( jQuery.type( elem ) === "object" ) {
	                        jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

	                        // Convert non-html into a text node
	                    } else if ( !rhtml.test( elem ) ) {
	                        nodes.push( context.createTextNode( elem ) );

	                        // Convert html into DOM nodes
	                    } else {
	                        tmp = tmp || safe.appendChild( context.createElement("div") );

	                        // Deserialize a standard representation
	                        tag = (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();
	                        wrap = wrapMap[ tag ] || wrapMap._default;

	                        tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

	                        // Descend through wrappers to the right content
	                        j = wrap[0];
	                        while ( j-- ) {
	                            tmp = tmp.lastChild;
	                        }

	                        // Manually add leading whitespace removed by IE
	                        if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
	                            nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
	                        }

	                        // Remove IE's autoinserted <tbody> from table fragments
	                        if ( !support.tbody ) {

	                            // String was a <table>, *may* have spurious <tbody>
	                            elem = tag === "table" && !rtbody.test( elem ) ?
	                                tmp.firstChild :

	                                // String was a bare <thead> or <tfoot>
	                                wrap[1] === "<table>" && !rtbody.test( elem ) ?
	                                    tmp :
	                                    0;

	                            j = elem && elem.childNodes.length;
	                            while ( j-- ) {
	                                if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
	                                    elem.removeChild( tbody );
	                                }
	                            }
	                        }

	                        jQuery.merge( nodes, tmp.childNodes );

	                        // Fix #12392 for WebKit and IE > 9
	                        tmp.textContent = "";

	                        // Fix #12392 for oldIE
	                        while ( tmp.firstChild ) {
	                            tmp.removeChild( tmp.firstChild );
	                        }

	                        // Remember the top-level container for proper cleanup
	                        tmp = safe.lastChild;
	                    }
	                }
	            }

	            // Fix #11356: Clear elements from fragment
	            if ( tmp ) {
	                safe.removeChild( tmp );
	            }

	            // Reset defaultChecked for any radios and checkboxes
	            // about to be appended to the DOM in IE 6/7 (#8060)
	            if ( !support.appendChecked ) {
	                jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
	            }

	            i = 0;
	            while ( (elem = nodes[ i++ ]) ) {

	                // #4087 - If origin and destination elements are the same, and this is
	                // that element, do not do anything
	                if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
	                    continue;
	                }

	                contains = jQuery.contains( elem.ownerDocument, elem );

	                // Append to fragment
	                tmp = getAll( safe.appendChild( elem ), "script" );

	                // Preserve script evaluation history
	                if ( contains ) {
	                    setGlobalEval( tmp );
	                }

	                // Capture executables
	                if ( scripts ) {
	                    j = 0;
	                    while ( (elem = tmp[ j++ ]) ) {
	                        if ( rscriptType.test( elem.type || "" ) ) {
	                            scripts.push( elem );
	                        }
	                    }
	                }
	            }

	            tmp = null;

	            return safe;
	        },

	        cleanData: function( elems, /* internal */ acceptData ) {
	            var elem, type, id, data,
	                i = 0,
	                internalKey = jQuery.expando,
	                cache = jQuery.cache,
	                deleteExpando = support.deleteExpando,
	                special = jQuery.event.special;

	            for ( ; (elem = elems[i]) != null; i++ ) {
	                if ( acceptData || jQuery.acceptData( elem ) ) {

	                    id = elem[ internalKey ];
	                    data = id && cache[ id ];

	                    if ( data ) {
	                        if ( data.events ) {
	                            for ( type in data.events ) {
	                                if ( special[ type ] ) {
	                                    jQuery.event.remove( elem, type );

	                                    // This is a shortcut to avoid jQuery.event.remove's overhead
	                                } else {
	                                    jQuery.removeEvent( elem, type, data.handle );
	                                }
	                            }
	                        }

	                        // Remove cache only if it was not already removed by jQuery.event.remove
	                        if ( cache[ id ] ) {

	                            delete cache[ id ];

	                            // IE does not allow us to delete expando properties from nodes,
	                            // nor does it have a removeAttribute function on Document nodes;
	                            // we must handle all of these cases
	                            if ( deleteExpando ) {
	                                delete elem[ internalKey ];

	                            } else if ( typeof elem.removeAttribute !== strundefined ) {
	                                elem.removeAttribute( internalKey );

	                            } else {
	                                elem[ internalKey ] = null;
	                            }

	                            deletedIds.push( id );
	                        }
	                    }
	                }
	            }
	        }
	    });

	    jQuery.fn.extend({
	        text: function( value ) {
	            return access( this, function( value ) {
	                return value === undefined ?
	                    jQuery.text( this ) :
	                    this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
	            }, null, value, arguments.length );
	        },

	        append: function() {
	            return this.domManip( arguments, function( elem ) {
	                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
	                    var target = manipulationTarget( this, elem );
	                    target.appendChild( elem );
	                }
	            });
	        },

	        prepend: function() {
	            return this.domManip( arguments, function( elem ) {
	                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
	                    var target = manipulationTarget( this, elem );
	                    target.insertBefore( elem, target.firstChild );
	                }
	            });
	        },

	        before: function() {
	            return this.domManip( arguments, function( elem ) {
	                if ( this.parentNode ) {
	                    this.parentNode.insertBefore( elem, this );
	                }
	            });
	        },

	        after: function() {
	            return this.domManip( arguments, function( elem ) {
	                if ( this.parentNode ) {
	                    this.parentNode.insertBefore( elem, this.nextSibling );
	                }
	            });
	        },

	        remove: function( selector, keepData /* Internal Use Only */ ) {
	            var elem,
	                elems = selector ? jQuery.filter( selector, this ) : this,
	                i = 0;

	            for ( ; (elem = elems[i]) != null; i++ ) {

	                if ( !keepData && elem.nodeType === 1 ) {
	                    jQuery.cleanData( getAll( elem ) );
	                }

	                if ( elem.parentNode ) {
	                    if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
	                        setGlobalEval( getAll( elem, "script" ) );
	                    }
	                    elem.parentNode.removeChild( elem );
	                }
	            }

	            return this;
	        },

	        empty: function() {
	            var elem,
	                i = 0;

	            for ( ; (elem = this[i]) != null; i++ ) {
	                // Remove element nodes and prevent memory leaks
	                if ( elem.nodeType === 1 ) {
	                    jQuery.cleanData( getAll( elem, false ) );
	                }

	                // Remove any remaining nodes
	                while ( elem.firstChild ) {
	                    elem.removeChild( elem.firstChild );
	                }

	                // If this is a select, ensure that it displays empty (#12336)
	                // Support: IE<9
	                if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
	                    elem.options.length = 0;
	                }
	            }

	            return this;
	        },

	        clone: function( dataAndEvents, deepDataAndEvents ) {
	            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
	            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

	            return this.map(function() {
	                return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
	            });
	        },

	        html: function( value ) {
	            return access( this, function( value ) {
	                var elem = this[ 0 ] || {},
	                    i = 0,
	                    l = this.length;

	                if ( value === undefined ) {
	                    return elem.nodeType === 1 ?
	                        elem.innerHTML.replace( rinlinejQuery, "" ) :
	                        undefined;
	                }

	                // See if we can take a shortcut and just use innerHTML
	                if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
	                    ( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
	                    ( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
	                    !wrapMap[ (rtagName.exec( value ) || [ "", "" ])[ 1 ].toLowerCase() ] ) {

	                    value = value.replace( rxhtmlTag, "<$1></$2>" );

	                    try {
	                        for (; i < l; i++ ) {
	                            // Remove element nodes and prevent memory leaks
	                            elem = this[i] || {};
	                            if ( elem.nodeType === 1 ) {
	                                jQuery.cleanData( getAll( elem, false ) );
	                                elem.innerHTML = value;
	                            }
	                        }

	                        elem = 0;

	                        // If using innerHTML throws an exception, use the fallback method
	                    } catch(e) {}
	                }

	                if ( elem ) {
	                    this.empty().append( value );
	                }
	            }, null, value, arguments.length );
	        },

	        replaceWith: function() {
	            var arg = arguments[ 0 ];

	            // Make the changes, replacing each context element with the new content
	            this.domManip( arguments, function( elem ) {
	                arg = this.parentNode;

	                jQuery.cleanData( getAll( this ) );

	                if ( arg ) {
	                    arg.replaceChild( elem, this );
	                }
	            });

	            // Force removal if there was no new content (e.g., from empty arguments)
	            return arg && (arg.length || arg.nodeType) ? this : this.remove();
	        },

	        detach: function( selector ) {
	            return this.remove( selector, true );
	        },

	        domManip: function( args, callback ) {

	            // Flatten any nested arrays
	            args = concat.apply( [], args );

	            var first, node, hasScripts,
	                scripts, doc, fragment,
	                i = 0,
	                l = this.length,
	                set = this,
	                iNoClone = l - 1,
	                value = args[0],
	                isFunction = jQuery.isFunction( value );

	            // We can't cloneNode fragments that contain checked, in WebKit
	            if ( isFunction ||
	                ( l > 1 && typeof value === "string" &&
	                !support.checkClone && rchecked.test( value ) ) ) {
	                return this.each(function( index ) {
	                    var self = set.eq( index );
	                    if ( isFunction ) {
	                        args[0] = value.call( this, index, self.html() );
	                    }
	                    self.domManip( args, callback );
	                });
	            }

	            if ( l ) {
	                fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
	                first = fragment.firstChild;

	                if ( fragment.childNodes.length === 1 ) {
	                    fragment = first;
	                }

	                if ( first ) {
	                    scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
	                    hasScripts = scripts.length;

	                    // Use the original fragment for the last item instead of the first because it can end up
	                    // being emptied incorrectly in certain situations (#8070).
	                    for ( ; i < l; i++ ) {
	                        node = fragment;

	                        if ( i !== iNoClone ) {
	                            node = jQuery.clone( node, true, true );

	                            // Keep references to cloned scripts for later restoration
	                            if ( hasScripts ) {
	                                jQuery.merge( scripts, getAll( node, "script" ) );
	                            }
	                        }

	                        callback.call( this[i], node, i );
	                    }

	                    if ( hasScripts ) {
	                        doc = scripts[ scripts.length - 1 ].ownerDocument;

	                        // Reenable scripts
	                        jQuery.map( scripts, restoreScript );

	                        // Evaluate executable scripts on first document insertion
	                        for ( i = 0; i < hasScripts; i++ ) {
	                            node = scripts[ i ];
	                            if ( rscriptType.test( node.type || "" ) &&
	                                !jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

	                                if ( node.src ) {
	                                    // Optional AJAX dependency, but won't run scripts if not present
	                                    if ( jQuery._evalUrl ) {
	                                        jQuery._evalUrl( node.src );
	                                    }
	                                } else {
	                                    jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
	                                }
	                            }
	                        }
	                    }

	                    // Fix #11809: Avoid leaking memory
	                    fragment = first = null;
	                }
	            }

	            return this;
	        }
	    });

	    jQuery.each({
	        appendTo: "append",
	        prependTo: "prepend",
	        insertBefore: "before",
	        insertAfter: "after",
	        replaceAll: "replaceWith"
	    }, function( name, original ) {
	        jQuery.fn[ name ] = function( selector ) {
	            var elems,
	                i = 0,
	                ret = [],
	                insert = jQuery( selector ),
	                last = insert.length - 1;

	            for ( ; i <= last; i++ ) {
	                elems = i === last ? this : this.clone(true);
	                jQuery( insert[i] )[ original ]( elems );

	                // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
	                push.apply( ret, elems.get() );
	            }

	            return this.pushStack( ret );
	        };
	    });


	    var iframe,
	        elemdisplay = {};

	    /**
	     * Retrieve the actual display of a element
	     * @param {String} name nodeName of the element
	     * @param {Object} doc Document object
	     */
	// Called only from within defaultDisplay
	    function actualDisplay( name, doc ) {
	        var style,
	            elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

	        // getDefaultComputedStyle might be reliably used only on attached element
	            display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

	                // Use of this method is a temporary fix (more like optmization) until something better comes along,
	                // since it was removed from specification and supported only in FF
	                style.display : jQuery.css( elem[ 0 ], "display" );

	        // We don't have any data stored on the element,
	        // so use "detach" method as fast way to get rid of the element
	        elem.detach();

	        return display;
	    }

	    /**
	     * Try to determine the default display value of an element
	     * @param {String} nodeName
	     */
	    function defaultDisplay( nodeName ) {
	        var doc = document,
	            display = elemdisplay[ nodeName ];

	        if ( !display ) {
	            display = actualDisplay( nodeName, doc );

	            // If the simple way fails, read from inside an iframe
	            if ( display === "none" || !display ) {

	                // Use the already-created iframe if possible
	                iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

	                // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
	                doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

	                // Support: IE
	                doc.write();
	                doc.close();

	                display = actualDisplay( nodeName, doc );
	                iframe.detach();
	            }

	            // Store the correct default display
	            elemdisplay[ nodeName ] = display;
	        }

	        return display;
	    }


	    (function() {
	        var shrinkWrapBlocksVal;

	        support.shrinkWrapBlocks = function() {
	            if ( shrinkWrapBlocksVal != null ) {
	                return shrinkWrapBlocksVal;
	            }

	            // Will be changed later if needed.
	            shrinkWrapBlocksVal = false;

	            // Minified: var b,c,d
	            var div, body, container;

	            body = document.getElementsByTagName( "body" )[ 0 ];
	            if ( !body || !body.style ) {
	                // Test fired too early or in an unsupported environment, exit.
	                return;
	            }

	            // Setup
	            div = document.createElement( "div" );
	            container = document.createElement( "div" );
	            container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
	            body.appendChild( container ).appendChild( div );

	            // Support: IE6
	            // Check if elements with layout shrink-wrap their children
	            if ( typeof div.style.zoom !== strundefined ) {
	                // Reset CSS: box-sizing; display; margin; border
	                div.style.cssText =
	                    // Support: Firefox<29, Android 2.3
	                    // Vendor-prefix box-sizing
	                    "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
	                    "box-sizing:content-box;display:block;margin:0;border:0;" +
	                    "padding:1px;width:1px;zoom:1";
	                div.appendChild( document.createElement( "div" ) ).style.width = "5px";
	                shrinkWrapBlocksVal = div.offsetWidth !== 3;
	            }

	            body.removeChild( container );

	            return shrinkWrapBlocksVal;
	        };

	    })();
	    var rmargin = (/^margin/);

	    var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );



	    var getStyles, curCSS,
	        rposition = /^(top|right|bottom|left)$/;

	    if ( window.getComputedStyle ) {
	        getStyles = function( elem ) {
	            // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
	            // IE throws on elements created in popups
	            // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
	            if ( elem.ownerDocument.defaultView.opener ) {
	                return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
	            }

	            return window.getComputedStyle( elem, null );
	        };

	        curCSS = function( elem, name, computed ) {
	            var width, minWidth, maxWidth, ret,
	                style = elem.style;

	            computed = computed || getStyles( elem );

	            // getPropertyValue is only needed for .css('filter') in IE9, see #12537
	            ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

	            if ( computed ) {

	                if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
	                    ret = jQuery.style( elem, name );
	                }

	                // A tribute to the "awesome hack by Dean Edwards"
	                // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
	                // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
	                // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
	                if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

	                    // Remember the original values
	                    width = style.width;
	                    minWidth = style.minWidth;
	                    maxWidth = style.maxWidth;

	                    // Put in the new values to get a computed value out
	                    style.minWidth = style.maxWidth = style.width = ret;
	                    ret = computed.width;

	                    // Revert the changed values
	                    style.width = width;
	                    style.minWidth = minWidth;
	                    style.maxWidth = maxWidth;
	                }
	            }

	            // Support: IE
	            // IE returns zIndex value as an integer.
	            return ret === undefined ?
	                ret :
	            ret + "";
	        };
	    } else if ( document.documentElement.currentStyle ) {
	        getStyles = function( elem ) {
	            return elem.currentStyle;
	        };

	        curCSS = function( elem, name, computed ) {
	            var left, rs, rsLeft, ret,
	                style = elem.style;

	            computed = computed || getStyles( elem );
	            ret = computed ? computed[ name ] : undefined;

	            // Avoid setting ret to empty string here
	            // so we don't default to auto
	            if ( ret == null && style && style[ name ] ) {
	                ret = style[ name ];
	            }

	            // From the awesome hack by Dean Edwards
	            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

	            // If we're not dealing with a regular pixel number
	            // but a number that has a weird ending, we need to convert it to pixels
	            // but not position css attributes, as those are proportional to the parent element instead
	            // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
	            if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

	                // Remember the original values
	                left = style.left;
	                rs = elem.runtimeStyle;
	                rsLeft = rs && rs.left;

	                // Put in the new values to get a computed value out
	                if ( rsLeft ) {
	                    rs.left = elem.currentStyle.left;
	                }
	                style.left = name === "fontSize" ? "1em" : ret;
	                ret = style.pixelLeft + "px";

	                // Revert the changed values
	                style.left = left;
	                if ( rsLeft ) {
	                    rs.left = rsLeft;
	                }
	            }

	            // Support: IE
	            // IE returns zIndex value as an integer.
	            return ret === undefined ?
	                ret :
	            ret + "" || "auto";
	        };
	    }




	    function addGetHookIf( conditionFn, hookFn ) {
	        // Define the hook, we'll check on the first run if it's really needed.
	        return {
	            get: function() {
	                var condition = conditionFn();

	                if ( condition == null ) {
	                    // The test was not ready at this point; screw the hook this time
	                    // but check again when needed next time.
	                    return;
	                }

	                if ( condition ) {
	                    // Hook not needed (or it's not possible to use it due to missing dependency),
	                    // remove it.
	                    // Since there are no other hooks for marginRight, remove the whole object.
	                    delete this.get;
	                    return;
	                }

	                // Hook needed; redefine it so that the support test is not executed again.

	                return (this.get = hookFn).apply( this, arguments );
	            }
	        };
	    }


	    (function() {
	        // Minified: var b,c,d,e,f,g, h,i
	        var div, style, a, pixelPositionVal, boxSizingReliableVal,
	            reliableHiddenOffsetsVal, reliableMarginRightVal;

	        // Setup
	        div = document.createElement( "div" );
	        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	        a = div.getElementsByTagName( "a" )[ 0 ];
	        style = a && a.style;

	        // Finish early in limited (non-browser) environments
	        if ( !style ) {
	            return;
	        }

	        style.cssText = "float:left;opacity:.5";

	        // Support: IE<9
	        // Make sure that element opacity exists (as opposed to filter)
	        support.opacity = style.opacity === "0.5";

	        // Verify style float existence
	        // (IE uses styleFloat instead of cssFloat)
	        support.cssFloat = !!style.cssFloat;

	        div.style.backgroundClip = "content-box";
	        div.cloneNode( true ).style.backgroundClip = "";
	        support.clearCloneStyle = div.style.backgroundClip === "content-box";

	        // Support: Firefox<29, Android 2.3
	        // Vendor-prefix box-sizing
	        support.boxSizing = style.boxSizing === "" || style.MozBoxSizing === "" ||
	            style.WebkitBoxSizing === "";

	        jQuery.extend(support, {
	            reliableHiddenOffsets: function() {
	                if ( reliableHiddenOffsetsVal == null ) {
	                    computeStyleTests();
	                }
	                return reliableHiddenOffsetsVal;
	            },

	            boxSizingReliable: function() {
	                if ( boxSizingReliableVal == null ) {
	                    computeStyleTests();
	                }
	                return boxSizingReliableVal;
	            },

	            pixelPosition: function() {
	                if ( pixelPositionVal == null ) {
	                    computeStyleTests();
	                }
	                return pixelPositionVal;
	            },

	            // Support: Android 2.3
	            reliableMarginRight: function() {
	                if ( reliableMarginRightVal == null ) {
	                    computeStyleTests();
	                }
	                return reliableMarginRightVal;
	            }
	        });

	        function computeStyleTests() {
	            // Minified: var b,c,d,j
	            var div, body, container, contents;

	            body = document.getElementsByTagName( "body" )[ 0 ];
	            if ( !body || !body.style ) {
	                // Test fired too early or in an unsupported environment, exit.
	                return;
	            }

	            // Setup
	            div = document.createElement( "div" );
	            container = document.createElement( "div" );
	            container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
	            body.appendChild( container ).appendChild( div );

	            div.style.cssText =
	                // Support: Firefox<29, Android 2.3
	                // Vendor-prefix box-sizing
	                "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
	                "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
	                "border:1px;padding:1px;width:4px;position:absolute";

	            // Support: IE<9
	            // Assume reasonable values in the absence of getComputedStyle
	            pixelPositionVal = boxSizingReliableVal = false;
	            reliableMarginRightVal = true;

	            // Check for getComputedStyle so that this code is not run in IE<9.
	            if ( window.getComputedStyle ) {
	                pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
	                boxSizingReliableVal =
	                    ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

	                // Support: Android 2.3
	                // Div with explicit width and no margin-right incorrectly
	                // gets computed margin-right based on width of container (#3333)
	                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
	                contents = div.appendChild( document.createElement( "div" ) );

	                // Reset CSS: box-sizing; display; margin; border; padding
	                contents.style.cssText = div.style.cssText =
	                    // Support: Firefox<29, Android 2.3
	                    // Vendor-prefix box-sizing
	                    "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
	                    "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
	                contents.style.marginRight = contents.style.width = "0";
	                div.style.width = "1px";

	                reliableMarginRightVal =
	                    !parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight );

	                div.removeChild( contents );
	            }

	            // Support: IE8
	            // Check if table cells still have offsetWidth/Height when they are set
	            // to display:none and there are still other visible table cells in a
	            // table row; if so, offsetWidth/Height are not reliable for use when
	            // determining if an element has been hidden directly using
	            // display:none (it is still safe to use offsets if a parent element is
	            // hidden; don safety goggles and see bug #4512 for more information).
	            div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
	            contents = div.getElementsByTagName( "td" );
	            contents[ 0 ].style.cssText = "margin:0;border:0;padding:0;display:none";
	            reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
	            if ( reliableHiddenOffsetsVal ) {
	                contents[ 0 ].style.display = "";
	                contents[ 1 ].style.display = "none";
	                reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
	            }

	            body.removeChild( container );
	        }

	    })();


	// A method for quickly swapping in/out CSS properties to get correct calculations.
	    jQuery.swap = function( elem, options, callback, args ) {
	        var ret, name,
	            old = {};

	        // Remember the old values, and insert the new ones
	        for ( name in options ) {
	            old[ name ] = elem.style[ name ];
	            elem.style[ name ] = options[ name ];
	        }

	        ret = callback.apply( elem, args || [] );

	        // Revert the old values
	        for ( name in options ) {
	            elem.style[ name ] = old[ name ];
	        }

	        return ret;
	    };


	    var
	        ralpha = /alpha\([^)]*\)/i,
	        ropacity = /opacity\s*=\s*([^)]*)/,

	    // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	        rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	        rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	        rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	        cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	        cssNormalTransform = {
	            letterSpacing: "0",
	            fontWeight: "400"
	        },

	        cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];


	// return a css property mapped to a potentially vendor prefixed property
	    function vendorPropName( style, name ) {

	        // shortcut for names that are not vendor prefixed
	        if ( name in style ) {
	            return name;
	        }

	        // check for vendor prefixed names
	        var capName = name.charAt(0).toUpperCase() + name.slice(1),
	            origName = name,
	            i = cssPrefixes.length;

	        while ( i-- ) {
	            name = cssPrefixes[ i ] + capName;
	            if ( name in style ) {
	                return name;
	            }
	        }

	        return origName;
	    }

	    function showHide( elements, show ) {
	        var display, elem, hidden,
	            values = [],
	            index = 0,
	            length = elements.length;

	        for ( ; index < length; index++ ) {
	            elem = elements[ index ];
	            if ( !elem.style ) {
	                continue;
	            }

	            values[ index ] = jQuery._data( elem, "olddisplay" );
	            display = elem.style.display;
	            if ( show ) {
	                // Reset the inline display of this element to learn if it is
	                // being hidden by cascaded rules or not
	                if ( !values[ index ] && display === "none" ) {
	                    elem.style.display = "";
	                }

	                // Set elements which have been overridden with display: none
	                // in a stylesheet to whatever the default browser style is
	                // for such an element
	                if ( elem.style.display === "" && isHidden( elem ) ) {
	                    values[ index ] = jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
	                }
	            } else {
	                hidden = isHidden( elem );

	                if ( display && display !== "none" || !hidden ) {
	                    jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
	                }
	            }
	        }

	        // Set the display of most of the elements in a second loop
	        // to avoid the constant reflow
	        for ( index = 0; index < length; index++ ) {
	            elem = elements[ index ];
	            if ( !elem.style ) {
	                continue;
	            }
	            if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
	                elem.style.display = show ? values[ index ] || "" : "none";
	            }
	        }

	        return elements;
	    }

	    function setPositiveNumber( elem, value, subtract ) {
	        var matches = rnumsplit.exec( value );
	        return matches ?
	            // Guard against undefined "subtract", e.g., when used as in cssHooks
	        Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
	            value;
	    }

	    function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	        var i = extra === ( isBorderBox ? "border" : "content" ) ?
	                // If we already have the right measurement, avoid augmentation
	                4 :
	                // Otherwise initialize for horizontal or vertical properties
	                name === "width" ? 1 : 0,

	            val = 0;

	        for ( ; i < 4; i += 2 ) {
	            // both box models exclude margin, so add it if we want it
	            if ( extra === "margin" ) {
	                val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
	            }

	            if ( isBorderBox ) {
	                // border-box includes padding, so remove it if we want content
	                if ( extra === "content" ) {
	                    val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	                }

	                // at this point, extra isn't border nor margin, so remove border
	                if ( extra !== "margin" ) {
	                    val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
	                }
	            } else {
	                // at this point, extra isn't content, so add padding
	                val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

	                // at this point, extra isn't content nor padding, so add border
	                if ( extra !== "padding" ) {
	                    val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
	                }
	            }
	        }

	        return val;
	    }

	    function getWidthOrHeight( elem, name, extra ) {

	        // Start with offset property, which is equivalent to the border-box value
	        var valueIsBorderBox = true,
	            val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
	            styles = getStyles( elem ),
	            isBorderBox = support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	        // some non-html elements return undefined for offsetWidth, so check for null/undefined
	        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	        if ( val <= 0 || val == null ) {
	            // Fall back to computed then uncomputed css if necessary
	            val = curCSS( elem, name, styles );
	            if ( val < 0 || val == null ) {
	                val = elem.style[ name ];
	            }

	            // Computed unit is not pixels. Stop here and return.
	            if ( rnumnonpx.test(val) ) {
	                return val;
	            }

	            // we need the check for style in case a browser which returns unreliable values
	            // for getComputedStyle silently falls back to the reliable elem.style
	            valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );

	            // Normalize "", auto, and prepare for extra
	            val = parseFloat( val ) || 0;
	        }

	        // use the active box-sizing model to add/subtract irrelevant styles
	        return ( val +
	                augmentWidthOrHeight(
	                    elem,
	                    name,
	                    extra || ( isBorderBox ? "border" : "content" ),
	                    valueIsBorderBox,
	                    styles
	                )
	            ) + "px";
	    }

	    jQuery.extend({
	        // Add in style property hooks for overriding the default
	        // behavior of getting and setting a style property
	        cssHooks: {
	            opacity: {
	                get: function( elem, computed ) {
	                    if ( computed ) {
	                        // We should always get a number back from opacity
	                        var ret = curCSS( elem, "opacity" );
	                        return ret === "" ? "1" : ret;
	                    }
	                }
	            }
	        },

	        // Don't automatically add "px" to these possibly-unitless properties
	        cssNumber: {
	            "columnCount": true,
	            "fillOpacity": true,
	            "flexGrow": true,
	            "flexShrink": true,
	            "fontWeight": true,
	            "lineHeight": true,
	            "opacity": true,
	            "order": true,
	            "orphans": true,
	            "widows": true,
	            "zIndex": true,
	            "zoom": true
	        },

	        // Add in properties whose names you wish to fix before
	        // setting or getting the value
	        cssProps: {
	            // normalize float css property
	            "float": support.cssFloat ? "cssFloat" : "styleFloat"
	        },

	        // Get and set the style property on a DOM Node
	        style: function( elem, name, value, extra ) {
	            // Don't set styles on text and comment nodes
	            if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
	                return;
	            }

	            // Make sure that we're working with the right name
	            var ret, type, hooks,
	                origName = jQuery.camelCase( name ),
	                style = elem.style;

	            name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

	            // gets hook for the prefixed version
	            // followed by the unprefixed version
	            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

	            // Check if we're setting a value
	            if ( value !== undefined ) {
	                type = typeof value;

	                // convert relative number strings (+= or -=) to relative numbers. #7345
	                if ( type === "string" && (ret = rrelNum.exec( value )) ) {
	                    value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
	                    // Fixes bug #9237
	                    type = "number";
	                }

	                // Make sure that null and NaN values aren't set. See: #7116
	                if ( value == null || value !== value ) {
	                    return;
	                }

	                // If a number was passed in, add 'px' to the (except for certain CSS properties)
	                if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
	                    value += "px";
	                }

	                // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
	                // but it would mean to define eight (for every problematic property) identical functions
	                if ( !support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
	                    style[ name ] = "inherit";
	                }

	                // If a hook was provided, use that value, otherwise just set the specified value
	                if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

	                    // Support: IE
	                    // Swallow errors from 'invalid' CSS values (#5509)
	                    try {
	                        style[ name ] = value;
	                    } catch(e) {}
	                }

	            } else {
	                // If a hook was provided get the non-computed value from there
	                if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
	                    return ret;
	                }

	                // Otherwise just get the value from the style object
	                return style[ name ];
	            }
	        },

	        css: function( elem, name, extra, styles ) {
	            var num, val, hooks,
	                origName = jQuery.camelCase( name );

	            // Make sure that we're working with the right name
	            name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

	            // gets hook for the prefixed version
	            // followed by the unprefixed version
	            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

	            // If a hook was provided get the computed value from there
	            if ( hooks && "get" in hooks ) {
	                val = hooks.get( elem, true, extra );
	            }

	            // Otherwise, if a way to get the computed value exists, use that
	            if ( val === undefined ) {
	                val = curCSS( elem, name, styles );
	            }

	            //convert "normal" to computed value
	            if ( val === "normal" && name in cssNormalTransform ) {
	                val = cssNormalTransform[ name ];
	            }

	            // Return, converting to number if forced or a qualifier was provided and val looks numeric
	            if ( extra === "" || extra ) {
	                num = parseFloat( val );
	                return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
	            }
	            return val;
	        }
	    });

	    jQuery.each([ "height", "width" ], function( i, name ) {
	        jQuery.cssHooks[ name ] = {
	            get: function( elem, computed, extra ) {
	                if ( computed ) {
	                    // certain elements can have dimension info if we invisibly show them
	                    // however, it must have a current display style that would benefit from this
	                    return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
	                        jQuery.swap( elem, cssShow, function() {
	                            return getWidthOrHeight( elem, name, extra );
	                        }) :
	                        getWidthOrHeight( elem, name, extra );
	                }
	            },

	            set: function( elem, value, extra ) {
	                var styles = extra && getStyles( elem );
	                return setPositiveNumber( elem, value, extra ?
	                    augmentWidthOrHeight(
	                        elem,
	                        name,
	                        extra,
	                        support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
	                        styles
	                    ) : 0
	                );
	            }
	        };
	    });

	    if ( !support.opacity ) {
	        jQuery.cssHooks.opacity = {
	            get: function( elem, computed ) {
	                // IE uses filters for opacity
	                return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
	                ( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
	                    computed ? "1" : "";
	            },

	            set: function( elem, value ) {
	                var style = elem.style,
	                    currentStyle = elem.currentStyle,
	                    opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
	                    filter = currentStyle && currentStyle.filter || style.filter || "";

	                // IE has trouble with opacity if it does not have layout
	                // Force it by setting the zoom level
	                style.zoom = 1;

	                // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
	                // if value === "", then remove inline opacity #12685
	                if ( ( value >= 1 || value === "" ) &&
	                    jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
	                    style.removeAttribute ) {

	                    // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
	                    // if "filter:" is present at all, clearType is disabled, we want to avoid this
	                    // style.removeAttribute is IE Only, but so apparently is this code path...
	                    style.removeAttribute( "filter" );

	                    // if there is no filter style applied in a css rule or unset inline opacity, we are done
	                    if ( value === "" || currentStyle && !currentStyle.filter ) {
	                        return;
	                    }
	                }

	                // otherwise, set new filter values
	                style.filter = ralpha.test( filter ) ?
	                    filter.replace( ralpha, opacity ) :
	                filter + " " + opacity;
	            }
	        };
	    }

	    jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	        function( elem, computed ) {
	            if ( computed ) {
	                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
	                // Work around by temporarily setting element display to inline-block
	                return jQuery.swap( elem, { "display": "inline-block" },
	                    curCSS, [ elem, "marginRight" ] );
	            }
	        }
	    );

	// These hooks are used by animate to expand properties
	    jQuery.each({
	        margin: "",
	        padding: "",
	        border: "Width"
	    }, function( prefix, suffix ) {
	        jQuery.cssHooks[ prefix + suffix ] = {
	            expand: function( value ) {
	                var i = 0,
	                    expanded = {},

	                // assumes a single number if not a string
	                    parts = typeof value === "string" ? value.split(" ") : [ value ];

	                for ( ; i < 4; i++ ) {
	                    expanded[ prefix + cssExpand[ i ] + suffix ] =
	                        parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
	                }

	                return expanded;
	            }
	        };

	        if ( !rmargin.test( prefix ) ) {
	            jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	        }
	    });

	    jQuery.fn.extend({
	        css: function( name, value ) {
	            return access( this, function( elem, name, value ) {
	                var styles, len,
	                    map = {},
	                    i = 0;

	                if ( jQuery.isArray( name ) ) {
	                    styles = getStyles( elem );
	                    len = name.length;

	                    for ( ; i < len; i++ ) {
	                        map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
	                    }

	                    return map;
	                }

	                return value !== undefined ?
	                    jQuery.style( elem, name, value ) :
	                    jQuery.css( elem, name );
	            }, name, value, arguments.length > 1 );
	        },
	        show: function() {
	            return showHide( this, true );
	        },
	        hide: function() {
	            return showHide( this );
	        },
	        toggle: function( state ) {
	            if ( typeof state === "boolean" ) {
	                return state ? this.show() : this.hide();
	            }

	            return this.each(function() {
	                if ( isHidden( this ) ) {
	                    jQuery( this ).show();
	                } else {
	                    jQuery( this ).hide();
	                }
	            });
	        }
	    });


	    function Tween( elem, options, prop, end, easing ) {
	        return new Tween.prototype.init( elem, options, prop, end, easing );
	    }
	    jQuery.Tween = Tween;

	    Tween.prototype = {
	        constructor: Tween,
	        init: function( elem, options, prop, end, easing, unit ) {
	            this.elem = elem;
	            this.prop = prop;
	            this.easing = easing || "swing";
	            this.options = options;
	            this.start = this.now = this.cur();
	            this.end = end;
	            this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	        },
	        cur: function() {
	            var hooks = Tween.propHooks[ this.prop ];

	            return hooks && hooks.get ?
	                hooks.get( this ) :
	                Tween.propHooks._default.get( this );
	        },
	        run: function( percent ) {
	            var eased,
	                hooks = Tween.propHooks[ this.prop ];

	            if ( this.options.duration ) {
	                this.pos = eased = jQuery.easing[ this.easing ](
	                    percent, this.options.duration * percent, 0, 1, this.options.duration
	                );
	            } else {
	                this.pos = eased = percent;
	            }
	            this.now = ( this.end - this.start ) * eased + this.start;

	            if ( this.options.step ) {
	                this.options.step.call( this.elem, this.now, this );
	            }

	            if ( hooks && hooks.set ) {
	                hooks.set( this );
	            } else {
	                Tween.propHooks._default.set( this );
	            }
	            return this;
	        }
	    };

	    Tween.prototype.init.prototype = Tween.prototype;

	    Tween.propHooks = {
	        _default: {
	            get: function( tween ) {
	                var result;

	                if ( tween.elem[ tween.prop ] != null &&
	                    (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
	                    return tween.elem[ tween.prop ];
	                }

	                // passing an empty string as a 3rd parameter to .css will automatically
	                // attempt a parseFloat and fallback to a string if the parse fails
	                // so, simple values such as "10px" are parsed to Float.
	                // complex values such as "rotate(1rad)" are returned as is.
	                result = jQuery.css( tween.elem, tween.prop, "" );
	                // Empty strings, null, undefined and "auto" are converted to 0.
	                return !result || result === "auto" ? 0 : result;
	            },
	            set: function( tween ) {
	                // use step hook for back compat - use cssHook if its there - use .style if its
	                // available and use plain properties where available
	                if ( jQuery.fx.step[ tween.prop ] ) {
	                    jQuery.fx.step[ tween.prop ]( tween );
	                } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
	                    jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
	                } else {
	                    tween.elem[ tween.prop ] = tween.now;
	                }
	            }
	        }
	    };

	// Support: IE <=9
	// Panic based approach to setting things on disconnected nodes

	    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	        set: function( tween ) {
	            if ( tween.elem.nodeType && tween.elem.parentNode ) {
	                tween.elem[ tween.prop ] = tween.now;
	            }
	        }
	    };

	    jQuery.easing = {
	        linear: function( p ) {
	            return p;
	        },
	        swing: function( p ) {
	            return 0.5 - Math.cos( p * Math.PI ) / 2;
	        }
	    };

	    jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	    jQuery.fx.step = {};




	    var
	        fxNow, timerId,
	        rfxtypes = /^(?:toggle|show|hide)$/,
	        rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	        rrun = /queueHooks$/,
	        animationPrefilters = [ defaultPrefilter ],
	        tweeners = {
	            "*": [ function( prop, value ) {
	                var tween = this.createTween( prop, value ),
	                    target = tween.cur(),
	                    parts = rfxnum.exec( value ),
	                    unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

	                // Starting value computation is required for potential unit mismatches
	                    start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
	                        rfxnum.exec( jQuery.css( tween.elem, prop ) ),
	                    scale = 1,
	                    maxIterations = 20;

	                if ( start && start[ 3 ] !== unit ) {
	                    // Trust units reported by jQuery.css
	                    unit = unit || start[ 3 ];

	                    // Make sure we update the tween properties later on
	                    parts = parts || [];

	                    // Iteratively approximate from a nonzero starting point
	                    start = +target || 1;

	                    do {
	                        // If previous iteration zeroed out, double until we get *something*
	                        // Use a string for doubling factor so we don't accidentally see scale as unchanged below
	                        scale = scale || ".5";

	                        // Adjust and apply
	                        start = start / scale;
	                        jQuery.style( tween.elem, prop, start + unit );

	                        // Update scale, tolerating zero or NaN from tween.cur()
	                        // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
	                    } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
	                }

	                // Update tween properties
	                if ( parts ) {
	                    start = tween.start = +start || +target || 0;
	                    tween.unit = unit;
	                    // If a +=/-= token was provided, we're doing a relative animation
	                    tween.end = parts[ 1 ] ?
	                    start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
	                        +parts[ 2 ];
	                }

	                return tween;
	            } ]
	        };

	// Animations created synchronously will run synchronously
	    function createFxNow() {
	        setTimeout(function() {
	            fxNow = undefined;
	        });
	        return ( fxNow = jQuery.now() );
	    }

	// Generate parameters to create a standard animation
	    function genFx( type, includeWidth ) {
	        var which,
	            attrs = { height: type },
	            i = 0;

	        // if we include width, step value is 1 to do all cssExpand values,
	        // if we don't include width, step value is 2 to skip over Left and Right
	        includeWidth = includeWidth ? 1 : 0;
	        for ( ; i < 4 ; i += 2 - includeWidth ) {
	            which = cssExpand[ i ];
	            attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	        }

	        if ( includeWidth ) {
	            attrs.opacity = attrs.width = type;
	        }

	        return attrs;
	    }

	    function createTween( value, prop, animation ) {
	        var tween,
	            collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
	            index = 0,
	            length = collection.length;
	        for ( ; index < length; index++ ) {
	            if ( (tween = collection[ index ].call( animation, prop, value )) ) {

	                // we're done with this property
	                return tween;
	            }
	        }
	    }

	    function defaultPrefilter( elem, props, opts ) {
	        /* jshint validthis: true */
	        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
	            anim = this,
	            orig = {},
	            style = elem.style,
	            hidden = elem.nodeType && isHidden( elem ),
	            dataShow = jQuery._data( elem, "fxshow" );

	        // handle queue: false promises
	        if ( !opts.queue ) {
	            hooks = jQuery._queueHooks( elem, "fx" );
	            if ( hooks.unqueued == null ) {
	                hooks.unqueued = 0;
	                oldfire = hooks.empty.fire;
	                hooks.empty.fire = function() {
	                    if ( !hooks.unqueued ) {
	                        oldfire();
	                    }
	                };
	            }
	            hooks.unqueued++;

	            anim.always(function() {
	                // doing this makes sure that the complete handler will be called
	                // before this completes
	                anim.always(function() {
	                    hooks.unqueued--;
	                    if ( !jQuery.queue( elem, "fx" ).length ) {
	                        hooks.empty.fire();
	                    }
	                });
	            });
	        }

	        // height/width overflow pass
	        if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
	            // Make sure that nothing sneaks out
	            // Record all 3 overflow attributes because IE does not
	            // change the overflow attribute when overflowX and
	            // overflowY are set to the same value
	            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

	            // Set display property to inline-block for height/width
	            // animations on inline elements that are having width/height animated
	            display = jQuery.css( elem, "display" );

	            // Test default display if display is currently "none"
	            checkDisplay = display === "none" ?
	            jQuery._data( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

	            if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {

	                // inline-level elements accept inline-block;
	                // block-level elements need to be inline with layout
	                if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === "inline" ) {
	                    style.display = "inline-block";
	                } else {
	                    style.zoom = 1;
	                }
	            }
	        }

	        if ( opts.overflow ) {
	            style.overflow = "hidden";
	            if ( !support.shrinkWrapBlocks() ) {
	                anim.always(function() {
	                    style.overflow = opts.overflow[ 0 ];
	                    style.overflowX = opts.overflow[ 1 ];
	                    style.overflowY = opts.overflow[ 2 ];
	                });
	            }
	        }

	        // show/hide pass
	        for ( prop in props ) {
	            value = props[ prop ];
	            if ( rfxtypes.exec( value ) ) {
	                delete props[ prop ];
	                toggle = toggle || value === "toggle";
	                if ( value === ( hidden ? "hide" : "show" ) ) {

	                    // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
	                    if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
	                        hidden = true;
	                    } else {
	                        continue;
	                    }
	                }
	                orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

	                // Any non-fx value stops us from restoring the original display value
	            } else {
	                display = undefined;
	            }
	        }

	        if ( !jQuery.isEmptyObject( orig ) ) {
	            if ( dataShow ) {
	                if ( "hidden" in dataShow ) {
	                    hidden = dataShow.hidden;
	                }
	            } else {
	                dataShow = jQuery._data( elem, "fxshow", {} );
	            }

	            // store state if its toggle - enables .stop().toggle() to "reverse"
	            if ( toggle ) {
	                dataShow.hidden = !hidden;
	            }
	            if ( hidden ) {
	                jQuery( elem ).show();
	            } else {
	                anim.done(function() {
	                    jQuery( elem ).hide();
	                });
	            }
	            anim.done(function() {
	                var prop;
	                jQuery._removeData( elem, "fxshow" );
	                for ( prop in orig ) {
	                    jQuery.style( elem, prop, orig[ prop ] );
	                }
	            });
	            for ( prop in orig ) {
	                tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

	                if ( !( prop in dataShow ) ) {
	                    dataShow[ prop ] = tween.start;
	                    if ( hidden ) {
	                        tween.end = tween.start;
	                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
	                    }
	                }
	            }

	            // If this is a noop like .hide().hide(), restore an overwritten display value
	        } else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
	            style.display = display;
	        }
	    }

	    function propFilter( props, specialEasing ) {
	        var index, name, easing, value, hooks;

	        // camelCase, specialEasing and expand cssHook pass
	        for ( index in props ) {
	            name = jQuery.camelCase( index );
	            easing = specialEasing[ name ];
	            value = props[ index ];
	            if ( jQuery.isArray( value ) ) {
	                easing = value[ 1 ];
	                value = props[ index ] = value[ 0 ];
	            }

	            if ( index !== name ) {
	                props[ name ] = value;
	                delete props[ index ];
	            }

	            hooks = jQuery.cssHooks[ name ];
	            if ( hooks && "expand" in hooks ) {
	                value = hooks.expand( value );
	                delete props[ name ];

	                // not quite $.extend, this wont overwrite keys already present.
	                // also - reusing 'index' from above because we have the correct "name"
	                for ( index in value ) {
	                    if ( !( index in props ) ) {
	                        props[ index ] = value[ index ];
	                        specialEasing[ index ] = easing;
	                    }
	                }
	            } else {
	                specialEasing[ name ] = easing;
	            }
	        }
	    }

	    function Animation( elem, properties, options ) {
	        var result,
	            stopped,
	            index = 0,
	            length = animationPrefilters.length,
	            deferred = jQuery.Deferred().always( function() {
	                // don't match elem in the :animated selector
	                delete tick.elem;
	            }),
	            tick = function() {
	                if ( stopped ) {
	                    return false;
	                }
	                var currentTime = fxNow || createFxNow(),
	                    remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
	                // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
	                    temp = remaining / animation.duration || 0,
	                    percent = 1 - temp,
	                    index = 0,
	                    length = animation.tweens.length;

	                for ( ; index < length ; index++ ) {
	                    animation.tweens[ index ].run( percent );
	                }

	                deferred.notifyWith( elem, [ animation, percent, remaining ]);

	                if ( percent < 1 && length ) {
	                    return remaining;
	                } else {
	                    deferred.resolveWith( elem, [ animation ] );
	                    return false;
	                }
	            },
	            animation = deferred.promise({
	                elem: elem,
	                props: jQuery.extend( {}, properties ),
	                opts: jQuery.extend( true, { specialEasing: {} }, options ),
	                originalProperties: properties,
	                originalOptions: options,
	                startTime: fxNow || createFxNow(),
	                duration: options.duration,
	                tweens: [],
	                createTween: function( prop, end ) {
	                    var tween = jQuery.Tween( elem, animation.opts, prop, end,
	                        animation.opts.specialEasing[ prop ] || animation.opts.easing );
	                    animation.tweens.push( tween );
	                    return tween;
	                },
	                stop: function( gotoEnd ) {
	                    var index = 0,
	                    // if we are going to the end, we want to run all the tweens
	                    // otherwise we skip this part
	                        length = gotoEnd ? animation.tweens.length : 0;
	                    if ( stopped ) {
	                        return this;
	                    }
	                    stopped = true;
	                    for ( ; index < length ; index++ ) {
	                        animation.tweens[ index ].run( 1 );
	                    }

	                    // resolve when we played the last frame
	                    // otherwise, reject
	                    if ( gotoEnd ) {
	                        deferred.resolveWith( elem, [ animation, gotoEnd ] );
	                    } else {
	                        deferred.rejectWith( elem, [ animation, gotoEnd ] );
	                    }
	                    return this;
	                }
	            }),
	            props = animation.props;

	        propFilter( props, animation.opts.specialEasing );

	        for ( ; index < length ; index++ ) {
	            result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
	            if ( result ) {
	                return result;
	            }
	        }

	        jQuery.map( props, createTween, animation );

	        if ( jQuery.isFunction( animation.opts.start ) ) {
	            animation.opts.start.call( elem, animation );
	        }

	        jQuery.fx.timer(
	            jQuery.extend( tick, {
	                elem: elem,
	                anim: animation,
	                queue: animation.opts.queue
	            })
	        );

	        // attach callbacks from options
	        return animation.progress( animation.opts.progress )
	            .done( animation.opts.done, animation.opts.complete )
	            .fail( animation.opts.fail )
	            .always( animation.opts.always );
	    }

	    jQuery.Animation = jQuery.extend( Animation, {
	        tweener: function( props, callback ) {
	            if ( jQuery.isFunction( props ) ) {
	                callback = props;
	                props = [ "*" ];
	            } else {
	                props = props.split(" ");
	            }

	            var prop,
	                index = 0,
	                length = props.length;

	            for ( ; index < length ; index++ ) {
	                prop = props[ index ];
	                tweeners[ prop ] = tweeners[ prop ] || [];
	                tweeners[ prop ].unshift( callback );
	            }
	        },

	        prefilter: function( callback, prepend ) {
	            if ( prepend ) {
	                animationPrefilters.unshift( callback );
	            } else {
	                animationPrefilters.push( callback );
	            }
	        }
	    });

	    jQuery.speed = function( speed, easing, fn ) {
	        var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
	            complete: fn || !fn && easing ||
	            jQuery.isFunction( speed ) && speed,
	            duration: speed,
	            easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	        };

	        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
	            opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	        // normalize opt.queue - true/undefined/null -> "fx"
	        if ( opt.queue == null || opt.queue === true ) {
	            opt.queue = "fx";
	        }

	        // Queueing
	        opt.old = opt.complete;

	        opt.complete = function() {
	            if ( jQuery.isFunction( opt.old ) ) {
	                opt.old.call( this );
	            }

	            if ( opt.queue ) {
	                jQuery.dequeue( this, opt.queue );
	            }
	        };

	        return opt;
	    };

	    jQuery.fn.extend({
	        fadeTo: function( speed, to, easing, callback ) {

	            // show any hidden elements after setting opacity to 0
	            return this.filter( isHidden ).css( "opacity", 0 ).show()

	                // animate to the value specified
	                .end().animate({ opacity: to }, speed, easing, callback );
	        },
	        animate: function( prop, speed, easing, callback ) {
	            var empty = jQuery.isEmptyObject( prop ),
	                optall = jQuery.speed( speed, easing, callback ),
	                doAnimation = function() {
	                    // Operate on a copy of prop so per-property easing won't be lost
	                    var anim = Animation( this, jQuery.extend( {}, prop ), optall );

	                    // Empty animations, or finishing resolves immediately
	                    if ( empty || jQuery._data( this, "finish" ) ) {
	                        anim.stop( true );
	                    }
	                };
	            doAnimation.finish = doAnimation;

	            return empty || optall.queue === false ?
	                this.each( doAnimation ) :
	                this.queue( optall.queue, doAnimation );
	        },
	        stop: function( type, clearQueue, gotoEnd ) {
	            var stopQueue = function( hooks ) {
	                var stop = hooks.stop;
	                delete hooks.stop;
	                stop( gotoEnd );
	            };

	            if ( typeof type !== "string" ) {
	                gotoEnd = clearQueue;
	                clearQueue = type;
	                type = undefined;
	            }
	            if ( clearQueue && type !== false ) {
	                this.queue( type || "fx", [] );
	            }

	            return this.each(function() {
	                var dequeue = true,
	                    index = type != null && type + "queueHooks",
	                    timers = jQuery.timers,
	                    data = jQuery._data( this );

	                if ( index ) {
	                    if ( data[ index ] && data[ index ].stop ) {
	                        stopQueue( data[ index ] );
	                    }
	                } else {
	                    for ( index in data ) {
	                        if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
	                            stopQueue( data[ index ] );
	                        }
	                    }
	                }

	                for ( index = timers.length; index--; ) {
	                    if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
	                        timers[ index ].anim.stop( gotoEnd );
	                        dequeue = false;
	                        timers.splice( index, 1 );
	                    }
	                }

	                // start the next in the queue if the last step wasn't forced
	                // timers currently will call their complete callbacks, which will dequeue
	                // but only if they were gotoEnd
	                if ( dequeue || !gotoEnd ) {
	                    jQuery.dequeue( this, type );
	                }
	            });
	        },
	        finish: function( type ) {
	            if ( type !== false ) {
	                type = type || "fx";
	            }
	            return this.each(function() {
	                var index,
	                    data = jQuery._data( this ),
	                    queue = data[ type + "queue" ],
	                    hooks = data[ type + "queueHooks" ],
	                    timers = jQuery.timers,
	                    length = queue ? queue.length : 0;

	                // enable finishing flag on private data
	                data.finish = true;

	                // empty the queue first
	                jQuery.queue( this, type, [] );

	                if ( hooks && hooks.stop ) {
	                    hooks.stop.call( this, true );
	                }

	                // look for any active animations, and finish them
	                for ( index = timers.length; index--; ) {
	                    if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
	                        timers[ index ].anim.stop( true );
	                        timers.splice( index, 1 );
	                    }
	                }

	                // look for any animations in the old queue and finish them
	                for ( index = 0; index < length; index++ ) {
	                    if ( queue[ index ] && queue[ index ].finish ) {
	                        queue[ index ].finish.call( this );
	                    }
	                }

	                // turn off finishing flag
	                delete data.finish;
	            });
	        }
	    });

	    jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	        var cssFn = jQuery.fn[ name ];
	        jQuery.fn[ name ] = function( speed, easing, callback ) {
	            return speed == null || typeof speed === "boolean" ?
	                cssFn.apply( this, arguments ) :
	                this.animate( genFx( name, true ), speed, easing, callback );
	        };
	    });

	// Generate shortcuts for custom animations
	    jQuery.each({
	        slideDown: genFx("show"),
	        slideUp: genFx("hide"),
	        slideToggle: genFx("toggle"),
	        fadeIn: { opacity: "show" },
	        fadeOut: { opacity: "hide" },
	        fadeToggle: { opacity: "toggle" }
	    }, function( name, props ) {
	        jQuery.fn[ name ] = function( speed, easing, callback ) {
	            return this.animate( props, speed, easing, callback );
	        };
	    });

	    jQuery.timers = [];
	    jQuery.fx.tick = function() {
	        var timer,
	            timers = jQuery.timers,
	            i = 0;

	        fxNow = jQuery.now();

	        for ( ; i < timers.length; i++ ) {
	            timer = timers[ i ];
	            // Checks the timer has not already been removed
	            if ( !timer() && timers[ i ] === timer ) {
	                timers.splice( i--, 1 );
	            }
	        }

	        if ( !timers.length ) {
	            jQuery.fx.stop();
	        }
	        fxNow = undefined;
	    };

	    jQuery.fx.timer = function( timer ) {
	        jQuery.timers.push( timer );
	        if ( timer() ) {
	            jQuery.fx.start();
	        } else {
	            jQuery.timers.pop();
	        }
	    };

	    jQuery.fx.interval = 13;

	    jQuery.fx.start = function() {
	        if ( !timerId ) {
	            timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	        }
	    };

	    jQuery.fx.stop = function() {
	        clearInterval( timerId );
	        timerId = null;
	    };

	    jQuery.fx.speeds = {
	        slow: 600,
	        fast: 200,
	        // Default speed
	        _default: 400
	    };


	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	    jQuery.fn.delay = function( time, type ) {
	        time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	        type = type || "fx";

	        return this.queue( type, function( next, hooks ) {
	            var timeout = setTimeout( next, time );
	            hooks.stop = function() {
	                clearTimeout( timeout );
	            };
	        });
	    };


	    (function() {
	        // Minified: var a,b,c,d,e
	        var input, div, select, a, opt;

	        // Setup
	        div = document.createElement( "div" );
	        div.setAttribute( "className", "t" );
	        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	        a = div.getElementsByTagName("a")[ 0 ];

	        // First batch of tests.
	        select = document.createElement("select");
	        opt = select.appendChild( document.createElement("option") );
	        input = div.getElementsByTagName("input")[ 0 ];

	        a.style.cssText = "top:1px";

	        // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
	        support.getSetAttribute = div.className !== "t";

	        // Get the style information from getAttribute
	        // (IE uses .cssText instead)
	        support.style = /top/.test( a.getAttribute("style") );

	        // Make sure that URLs aren't manipulated
	        // (IE normalizes it by default)
	        support.hrefNormalized = a.getAttribute("href") === "/a";

	        // Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
	        support.checkOn = !!input.value;

	        // Make sure that a selected-by-default option has a working selected property.
	        // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
	        support.optSelected = opt.selected;

	        // Tests for enctype support on a form (#6743)
	        support.enctype = !!document.createElement("form").enctype;

	        // Make sure that the options inside disabled selects aren't marked as disabled
	        // (WebKit marks them as disabled)
	        select.disabled = true;
	        support.optDisabled = !opt.disabled;

	        // Support: IE8 only
	        // Check if we can trust getAttribute("value")
	        input = document.createElement( "input" );
	        input.setAttribute( "value", "" );
	        support.input = input.getAttribute( "value" ) === "";

	        // Check if an input maintains its value after becoming a radio
	        input.value = "t";
	        input.setAttribute( "type", "radio" );
	        support.radioValue = input.value === "t";
	    })();


	    var rreturn = /\r/g;

	    jQuery.fn.extend({
	        val: function( value ) {
	            var hooks, ret, isFunction,
	                elem = this[0];

	            if ( !arguments.length ) {
	                if ( elem ) {
	                    hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

	                    if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
	                        return ret;
	                    }

	                    ret = elem.value;

	                    return typeof ret === "string" ?
	                        // handle most common string cases
	                        ret.replace(rreturn, "") :
	                        // handle cases where value is null/undef or number
	                        ret == null ? "" : ret;
	                }

	                return;
	            }

	            isFunction = jQuery.isFunction( value );

	            return this.each(function( i ) {
	                var val;

	                if ( this.nodeType !== 1 ) {
	                    return;
	                }

	                if ( isFunction ) {
	                    val = value.call( this, i, jQuery( this ).val() );
	                } else {
	                    val = value;
	                }

	                // Treat null/undefined as ""; convert numbers to string
	                if ( val == null ) {
	                    val = "";
	                } else if ( typeof val === "number" ) {
	                    val += "";
	                } else if ( jQuery.isArray( val ) ) {
	                    val = jQuery.map( val, function( value ) {
	                        return value == null ? "" : value + "";
	                    });
	                }

	                hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

	                // If set returns undefined, fall back to normal setting
	                if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
	                    this.value = val;
	                }
	            });
	        }
	    });

	    jQuery.extend({
	        valHooks: {
	            option: {
	                get: function( elem ) {
	                    var val = jQuery.find.attr( elem, "value" );
	                    return val != null ?
	                        val :
	                        // Support: IE10-11+
	                        // option.text throws exceptions (#14686, #14858)
	                        jQuery.trim( jQuery.text( elem ) );
	                }
	            },
	            select: {
	                get: function( elem ) {
	                    var value, option,
	                        options = elem.options,
	                        index = elem.selectedIndex,
	                        one = elem.type === "select-one" || index < 0,
	                        values = one ? null : [],
	                        max = one ? index + 1 : options.length,
	                        i = index < 0 ?
	                            max :
	                            one ? index : 0;

	                    // Loop through all the selected options
	                    for ( ; i < max; i++ ) {
	                        option = options[ i ];

	                        // oldIE doesn't update selected after form reset (#2551)
	                        if ( ( option.selected || i === index ) &&
	                            // Don't return options that are disabled or in a disabled optgroup
	                            ( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
	                            ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

	                            // Get the specific value for the option
	                            value = jQuery( option ).val();

	                            // We don't need an array for one selects
	                            if ( one ) {
	                                return value;
	                            }

	                            // Multi-Selects return an array
	                            values.push( value );
	                        }
	                    }

	                    return values;
	                },

	                set: function( elem, value ) {
	                    var optionSet, option,
	                        options = elem.options,
	                        values = jQuery.makeArray( value ),
	                        i = options.length;

	                    while ( i-- ) {
	                        option = options[ i ];

	                        if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {

	                            // Support: IE6
	                            // When new option element is added to select box we need to
	                            // force reflow of newly added node in order to workaround delay
	                            // of initialization properties
	                            try {
	                                option.selected = optionSet = true;

	                            } catch ( _ ) {

	                                // Will be executed only in IE6
	                                option.scrollHeight;
	                            }

	                        } else {
	                            option.selected = false;
	                        }
	                    }

	                    // Force browsers to behave consistently when non-matching value is set
	                    if ( !optionSet ) {
	                        elem.selectedIndex = -1;
	                    }

	                    return options;
	                }
	            }
	        }
	    });

	// Radios and checkboxes getter/setter
	    jQuery.each([ "radio", "checkbox" ], function() {
	        jQuery.valHooks[ this ] = {
	            set: function( elem, value ) {
	                if ( jQuery.isArray( value ) ) {
	                    return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
	                }
	            }
	        };
	        if ( !support.checkOn ) {
	            jQuery.valHooks[ this ].get = function( elem ) {
	                // Support: Webkit
	                // "" is returned instead of "on" if a value isn't specified
	                return elem.getAttribute("value") === null ? "on" : elem.value;
	            };
	        }
	    });




	    var nodeHook, boolHook,
	        attrHandle = jQuery.expr.attrHandle,
	        ruseDefault = /^(?:checked|selected)$/i,
	        getSetAttribute = support.getSetAttribute,
	        getSetInput = support.input;

	    jQuery.fn.extend({
	        attr: function( name, value ) {
	            return access( this, jQuery.attr, name, value, arguments.length > 1 );
	        },

	        removeAttr: function( name ) {
	            return this.each(function() {
	                jQuery.removeAttr( this, name );
	            });
	        }
	    });

	    jQuery.extend({
	        attr: function( elem, name, value ) {
	            var hooks, ret,
	                nType = elem.nodeType;

	            // don't get/set attributes on text, comment and attribute nodes
	            if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
	                return;
	            }

	            // Fallback to prop when attributes are not supported
	            if ( typeof elem.getAttribute === strundefined ) {
	                return jQuery.prop( elem, name, value );
	            }

	            // All attributes are lowercase
	            // Grab necessary hook if one is defined
	            if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
	                name = name.toLowerCase();
	                hooks = jQuery.attrHooks[ name ] ||
	                    ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
	            }

	            if ( value !== undefined ) {

	                if ( value === null ) {
	                    jQuery.removeAttr( elem, name );

	                } else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
	                    return ret;

	                } else {
	                    elem.setAttribute( name, value + "" );
	                    return value;
	                }

	            } else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
	                return ret;

	            } else {
	                ret = jQuery.find.attr( elem, name );

	                // Non-existent attributes return null, we normalize to undefined
	                return ret == null ?
	                    undefined :
	                    ret;
	            }
	        },

	        removeAttr: function( elem, value ) {
	            var name, propName,
	                i = 0,
	                attrNames = value && value.match( rnotwhite );

	            if ( attrNames && elem.nodeType === 1 ) {
	                while ( (name = attrNames[i++]) ) {
	                    propName = jQuery.propFix[ name ] || name;

	                    // Boolean attributes get special treatment (#10870)
	                    if ( jQuery.expr.match.bool.test( name ) ) {
	                        // Set corresponding property to false
	                        if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
	                            elem[ propName ] = false;
	                            // Support: IE<9
	                            // Also clear defaultChecked/defaultSelected (if appropriate)
	                        } else {
	                            elem[ jQuery.camelCase( "default-" + name ) ] =
	                                elem[ propName ] = false;
	                        }

	                        // See #9699 for explanation of this approach (setting first, then removal)
	                    } else {
	                        jQuery.attr( elem, name, "" );
	                    }

	                    elem.removeAttribute( getSetAttribute ? name : propName );
	                }
	            }
	        },

	        attrHooks: {
	            type: {
	                set: function( elem, value ) {
	                    if ( !support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
	                        // Setting the type on a radio button after the value resets the value in IE6-9
	                        // Reset value to default in case type is set after value during creation
	                        var val = elem.value;
	                        elem.setAttribute( "type", value );
	                        if ( val ) {
	                            elem.value = val;
	                        }
	                        return value;
	                    }
	                }
	            }
	        }
	    });

	// Hook for boolean attributes
	    boolHook = {
	        set: function( elem, value, name ) {
	            if ( value === false ) {
	                // Remove boolean attributes when set to false
	                jQuery.removeAttr( elem, name );
	            } else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
	                // IE<8 needs the *property* name
	                elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

	                // Use defaultChecked and defaultSelected for oldIE
	            } else {
	                elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
	            }

	            return name;
	        }
	    };

	// Retrieve booleans specially
	    jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {

	        var getter = attrHandle[ name ] || jQuery.find.attr;

	        attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
	            function( elem, name, isXML ) {
	                var ret, handle;
	                if ( !isXML ) {
	                    // Avoid an infinite loop by temporarily removing this function from the getter
	                    handle = attrHandle[ name ];
	                    attrHandle[ name ] = ret;
	                    ret = getter( elem, name, isXML ) != null ?
	                        name.toLowerCase() :
	                        null;
	                    attrHandle[ name ] = handle;
	                }
	                return ret;
	            } :
	            function( elem, name, isXML ) {
	                if ( !isXML ) {
	                    return elem[ jQuery.camelCase( "default-" + name ) ] ?
	                        name.toLowerCase() :
	                        null;
	                }
	            };
	    });

	// fix oldIE attroperties
	    if ( !getSetInput || !getSetAttribute ) {
	        jQuery.attrHooks.value = {
	            set: function( elem, value, name ) {
	                if ( jQuery.nodeName( elem, "input" ) ) {
	                    // Does not return so that setAttribute is also used
	                    elem.defaultValue = value;
	                } else {
	                    // Use nodeHook if defined (#1954); otherwise setAttribute is fine
	                    return nodeHook && nodeHook.set( elem, value, name );
	                }
	            }
	        };
	    }

	// IE6/7 do not support getting/setting some attributes with get/setAttribute
	    if ( !getSetAttribute ) {

	        // Use this for any attribute in IE6/7
	        // This fixes almost every IE6/7 issue
	        nodeHook = {
	            set: function( elem, value, name ) {
	                // Set the existing or create a new attribute node
	                var ret = elem.getAttributeNode( name );
	                if ( !ret ) {
	                    elem.setAttributeNode(
	                        (ret = elem.ownerDocument.createAttribute( name ))
	                    );
	                }

	                ret.value = value += "";

	                // Break association with cloned elements by also using setAttribute (#9646)
	                if ( name === "value" || value === elem.getAttribute( name ) ) {
	                    return value;
	                }
	            }
	        };

	        // Some attributes are constructed with empty-string values when not defined
	        attrHandle.id = attrHandle.name = attrHandle.coords =
	            function( elem, name, isXML ) {
	                var ret;
	                if ( !isXML ) {
	                    return (ret = elem.getAttributeNode( name )) && ret.value !== "" ?
	                        ret.value :
	                        null;
	                }
	            };

	        // Fixing value retrieval on a button requires this module
	        jQuery.valHooks.button = {
	            get: function( elem, name ) {
	                var ret = elem.getAttributeNode( name );
	                if ( ret && ret.specified ) {
	                    return ret.value;
	                }
	            },
	            set: nodeHook.set
	        };

	        // Set contenteditable to false on removals(#10429)
	        // Setting to empty string throws an error as an invalid value
	        jQuery.attrHooks.contenteditable = {
	            set: function( elem, value, name ) {
	                nodeHook.set( elem, value === "" ? false : value, name );
	            }
	        };

	        // Set width and height to auto instead of 0 on empty string( Bug #8150 )
	        // This is for removals
	        jQuery.each([ "width", "height" ], function( i, name ) {
	            jQuery.attrHooks[ name ] = {
	                set: function( elem, value ) {
	                    if ( value === "" ) {
	                        elem.setAttribute( name, "auto" );
	                        return value;
	                    }
	                }
	            };
	        });
	    }

	    if ( !support.style ) {
	        jQuery.attrHooks.style = {
	            get: function( elem ) {
	                // Return undefined in the case of empty string
	                // Note: IE uppercases css property names, but if we were to .toLowerCase()
	                // .cssText, that would destroy case senstitivity in URL's, like in "background"
	                return elem.style.cssText || undefined;
	            },
	            set: function( elem, value ) {
	                return ( elem.style.cssText = value + "" );
	            }
	        };
	    }




	    var rfocusable = /^(?:input|select|textarea|button|object)$/i,
	        rclickable = /^(?:a|area)$/i;

	    jQuery.fn.extend({
	        prop: function( name, value ) {
	            return access( this, jQuery.prop, name, value, arguments.length > 1 );
	        },

	        removeProp: function( name ) {
	            name = jQuery.propFix[ name ] || name;
	            return this.each(function() {
	                // try/catch handles cases where IE balks (such as removing a property on window)
	                try {
	                    this[ name ] = undefined;
	                    delete this[ name ];
	                } catch( e ) {}
	            });
	        }
	    });

	    jQuery.extend({
	        propFix: {
	            "for": "htmlFor",
	            "class": "className"
	        },

	        prop: function( elem, name, value ) {
	            var ret, hooks, notxml,
	                nType = elem.nodeType;

	            // don't get/set properties on text, comment and attribute nodes
	            if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
	                return;
	            }

	            notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

	            if ( notxml ) {
	                // Fix name and attach hooks
	                name = jQuery.propFix[ name ] || name;
	                hooks = jQuery.propHooks[ name ];
	            }

	            if ( value !== undefined ) {
	                return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
	                    ret :
	                    ( elem[ name ] = value );

	            } else {
	                return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
	                    ret :
	                    elem[ name ];
	            }
	        },

	        propHooks: {
	            tabIndex: {
	                get: function( elem ) {
	                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
	                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
	                    // Use proper attribute retrieval(#12072)
	                    var tabindex = jQuery.find.attr( elem, "tabindex" );

	                    return tabindex ?
	                        parseInt( tabindex, 10 ) :
	                        rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
	                            0 :
	                            -1;
	                }
	            }
	        }
	    });

	// Some attributes require a special call on IE
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	    if ( !support.hrefNormalized ) {
	        // href/src property should get the full normalized URL (#10299/#12915)
	        jQuery.each([ "href", "src" ], function( i, name ) {
	            jQuery.propHooks[ name ] = {
	                get: function( elem ) {
	                    return elem.getAttribute( name, 4 );
	                }
	            };
	        });
	    }

	// Support: Safari, IE9+
	// mis-reports the default selected property of an option
	// Accessing the parent's selectedIndex property fixes it
	    if ( !support.optSelected ) {
	        jQuery.propHooks.selected = {
	            get: function( elem ) {
	                var parent = elem.parentNode;

	                if ( parent ) {
	                    parent.selectedIndex;

	                    // Make sure that it also works with optgroups, see #5701
	                    if ( parent.parentNode ) {
	                        parent.parentNode.selectedIndex;
	                    }
	                }
	                return null;
	            }
	        };
	    }

	    jQuery.each([
	        "tabIndex",
	        "readOnly",
	        "maxLength",
	        "cellSpacing",
	        "cellPadding",
	        "rowSpan",
	        "colSpan",
	        "useMap",
	        "frameBorder",
	        "contentEditable"
	    ], function() {
	        jQuery.propFix[ this.toLowerCase() ] = this;
	    });

	// IE6/7 call enctype encoding
	    if ( !support.enctype ) {
	        jQuery.propFix.enctype = "encoding";
	    }




	    var rclass = /[\t\r\n\f]/g;

	    jQuery.fn.extend({
	        addClass: function( value ) {
	            var classes, elem, cur, clazz, j, finalValue,
	                i = 0,
	                len = this.length,
	                proceed = typeof value === "string" && value;

	            if ( jQuery.isFunction( value ) ) {
	                return this.each(function( j ) {
	                    jQuery( this ).addClass( value.call( this, j, this.className ) );
	                });
	            }

	            if ( proceed ) {
	                // The disjunction here is for better compressibility (see removeClass)
	                classes = ( value || "" ).match( rnotwhite ) || [];

	                for ( ; i < len; i++ ) {
	                    elem = this[ i ];
	                    cur = elem.nodeType === 1 && ( elem.className ?
	                                ( " " + elem.className + " " ).replace( rclass, " " ) :
	                                " "
	                        );

	                    if ( cur ) {
	                        j = 0;
	                        while ( (clazz = classes[j++]) ) {
	                            if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
	                                cur += clazz + " ";
	                            }
	                        }

	                        // only assign if different to avoid unneeded rendering.
	                        finalValue = jQuery.trim( cur );
	                        if ( elem.className !== finalValue ) {
	                            elem.className = finalValue;
	                        }
	                    }
	                }
	            }

	            return this;
	        },

	        removeClass: function( value ) {
	            var classes, elem, cur, clazz, j, finalValue,
	                i = 0,
	                len = this.length,
	                proceed = arguments.length === 0 || typeof value === "string" && value;

	            if ( jQuery.isFunction( value ) ) {
	                return this.each(function( j ) {
	                    jQuery( this ).removeClass( value.call( this, j, this.className ) );
	                });
	            }
	            if ( proceed ) {
	                classes = ( value || "" ).match( rnotwhite ) || [];

	                for ( ; i < len; i++ ) {
	                    elem = this[ i ];
	                    // This expression is here for better compressibility (see addClass)
	                    cur = elem.nodeType === 1 && ( elem.className ?
	                                ( " " + elem.className + " " ).replace( rclass, " " ) :
	                                ""
	                        );

	                    if ( cur ) {
	                        j = 0;
	                        while ( (clazz = classes[j++]) ) {
	                            // Remove *all* instances
	                            while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
	                                cur = cur.replace( " " + clazz + " ", " " );
	                            }
	                        }

	                        // only assign if different to avoid unneeded rendering.
	                        finalValue = value ? jQuery.trim( cur ) : "";
	                        if ( elem.className !== finalValue ) {
	                            elem.className = finalValue;
	                        }
	                    }
	                }
	            }

	            return this;
	        },

	        toggleClass: function( value, stateVal ) {
	            var type = typeof value;

	            if ( typeof stateVal === "boolean" && type === "string" ) {
	                return stateVal ? this.addClass( value ) : this.removeClass( value );
	            }

	            if ( jQuery.isFunction( value ) ) {
	                return this.each(function( i ) {
	                    jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
	                });
	            }

	            return this.each(function() {
	                if ( type === "string" ) {
	                    // toggle individual class names
	                    var className,
	                        i = 0,
	                        self = jQuery( this ),
	                        classNames = value.match( rnotwhite ) || [];

	                    while ( (className = classNames[ i++ ]) ) {
	                        // check each className given, space separated list
	                        if ( self.hasClass( className ) ) {
	                            self.removeClass( className );
	                        } else {
	                            self.addClass( className );
	                        }
	                    }

	                    // Toggle whole class name
	                } else if ( type === strundefined || type === "boolean" ) {
	                    if ( this.className ) {
	                        // store className if set
	                        jQuery._data( this, "__className__", this.className );
	                    }

	                    // If the element has a class name or if we're passed "false",
	                    // then remove the whole classname (if there was one, the above saved it).
	                    // Otherwise bring back whatever was previously saved (if anything),
	                    // falling back to the empty string if nothing was stored.
	                    this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
	                }
	            });
	        },

	        hasClass: function( selector ) {
	            var className = " " + selector + " ",
	                i = 0,
	                l = this.length;
	            for ( ; i < l; i++ ) {
	                if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
	                    return true;
	                }
	            }

	            return false;
	        }
	    });




	// Return jQuery for attributes-only inclusion


	    jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	    "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	    "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	        // Handle event binding
	        jQuery.fn[ name ] = function( data, fn ) {
	            return arguments.length > 0 ?
	                this.on( name, null, data, fn ) :
	                this.trigger( name );
	        };
	    });

	    jQuery.fn.extend({
	        hover: function( fnOver, fnOut ) {
	            return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	        },

	        bind: function( types, data, fn ) {
	            return this.on( types, null, data, fn );
	        },
	        unbind: function( types, fn ) {
	            return this.off( types, null, fn );
	        },

	        delegate: function( selector, types, data, fn ) {
	            return this.on( types, selector, data, fn );
	        },
	        undelegate: function( selector, types, fn ) {
	            // ( namespace ) or ( selector, types [, fn] )
	            return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	        }
	    });


	    var nonce = jQuery.now();

	    var rquery = (/\?/);



	    var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

	    jQuery.parseJSON = function( data ) {
	        // Attempt to parse using the native JSON parser first
	        if ( window.JSON && window.JSON.parse ) {
	            // Support: Android 2.3
	            // Workaround failure to string-cast null input
	            return window.JSON.parse( data + "" );
	        }

	        var requireNonComma,
	            depth = null,
	            str = jQuery.trim( data + "" );

	        // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
	        // after removing valid tokens
	        return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

	            // Force termination if we see a misplaced comma
	            if ( requireNonComma && comma ) {
	                depth = 0;
	            }

	            // Perform no more replacements after returning to outermost depth
	            if ( depth === 0 ) {
	                return token;
	            }

	            // Commas must not follow "[", "{", or ","
	            requireNonComma = open || comma;

	            // Determine new depth
	            // array/object open ("[" or "{"): depth += true - false (increment)
	            // array/object close ("]" or "}"): depth += false - true (decrement)
	            // other cases ("," or primitive): depth += true - true (numeric cast)
	            depth += !close - !open;

	            // Remove this token
	            return "";
	        }) ) ?
	            ( Function( "return " + str ) )() :
	            jQuery.error( "Invalid JSON: " + data );
	    };


	// Cross-browser xml parsing
	    jQuery.parseXML = function( data ) {
	        var xml, tmp;
	        if ( !data || typeof data !== "string" ) {
	            return null;
	        }
	        try {
	            if ( window.DOMParser ) { // Standard
	                tmp = new DOMParser();
	                xml = tmp.parseFromString( data, "text/xml" );
	            } else { // IE
	                xml = new ActiveXObject( "Microsoft.XMLDOM" );
	                xml.async = "false";
	                xml.loadXML( data );
	            }
	        } catch( e ) {
	            xml = undefined;
	        }
	        if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
	            jQuery.error( "Invalid XML: " + data );
	        }
	        return xml;
	    };


	    var
	    // Document location
	        ajaxLocParts,
	        ajaxLocation,

	        rhash = /#.*$/,
	        rts = /([?&])_=[^&]*/,
	        rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	    // #7653, #8125, #8152: local protocol detection
	        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	        rnoContent = /^(?:GET|HEAD)$/,
	        rprotocol = /^\/\//,
	        rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	    /* Prefilters
	     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	     * 2) These are called:
	     *    - BEFORE asking for a transport
	     *    - AFTER param serialization (s.data is a string if s.processData is true)
	     * 3) key is the dataType
	     * 4) the catchall symbol "*" can be used
	     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	     */
	        prefilters = {},

	    /* Transports bindings
	     * 1) key is the dataType
	     * 2) the catchall symbol "*" can be used
	     * 3) selection will start with transport dataType and THEN go to "*" if needed
	     */
	        transports = {},

	    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	        allTypes = "*/".concat("*");

	// #8138, IE may throw an exception when accessing
	// a field from window.location if document.domain has been set
	    try {
	        ajaxLocation = location.href;
	    } catch( e ) {
	        // Use the href attribute of an A element
	        // since IE will modify it given document.location
	        ajaxLocation = document.createElement( "a" );
	        ajaxLocation.href = "";
	        ajaxLocation = ajaxLocation.href;
	    }

	// Segment location into parts
	    ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	    function addToPrefiltersOrTransports( structure ) {

	        // dataTypeExpression is optional and defaults to "*"
	        return function( dataTypeExpression, func ) {

	            if ( typeof dataTypeExpression !== "string" ) {
	                func = dataTypeExpression;
	                dataTypeExpression = "*";
	            }

	            var dataType,
	                i = 0,
	                dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

	            if ( jQuery.isFunction( func ) ) {
	                // For each dataType in the dataTypeExpression
	                while ( (dataType = dataTypes[i++]) ) {
	                    // Prepend if requested
	                    if ( dataType.charAt( 0 ) === "+" ) {
	                        dataType = dataType.slice( 1 ) || "*";
	                        (structure[ dataType ] = structure[ dataType ] || []).unshift( func );

	                        // Otherwise append
	                    } else {
	                        (structure[ dataType ] = structure[ dataType ] || []).push( func );
	                    }
	                }
	            }
	        };
	    }

	// Base inspection function for prefilters and transports
	    function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	        var inspected = {},
	            seekingTransport = ( structure === transports );

	        function inspect( dataType ) {
	            var selected;
	            inspected[ dataType ] = true;
	            jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
	                var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
	                if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
	                    options.dataTypes.unshift( dataTypeOrTransport );
	                    inspect( dataTypeOrTransport );
	                    return false;
	                } else if ( seekingTransport ) {
	                    return !( selected = dataTypeOrTransport );
	                }
	            });
	            return selected;
	        }

	        return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	    }

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	    function ajaxExtend( target, src ) {
	        var deep, key,
	            flatOptions = jQuery.ajaxSettings.flatOptions || {};

	        for ( key in src ) {
	            if ( src[ key ] !== undefined ) {
	                ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
	            }
	        }
	        if ( deep ) {
	            jQuery.extend( true, target, deep );
	        }

	        return target;
	    }

	    /* Handles responses to an ajax request:
	     * - finds the right dataType (mediates between content-type and expected dataType)
	     * - returns the corresponding response
	     */
	    function ajaxHandleResponses( s, jqXHR, responses ) {
	        var firstDataType, ct, finalDataType, type,
	            contents = s.contents,
	            dataTypes = s.dataTypes;

	        // Remove auto dataType and get content-type in the process
	        while ( dataTypes[ 0 ] === "*" ) {
	            dataTypes.shift();
	            if ( ct === undefined ) {
	                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
	            }
	        }

	        // Check if we're dealing with a known content-type
	        if ( ct ) {
	            for ( type in contents ) {
	                if ( contents[ type ] && contents[ type ].test( ct ) ) {
	                    dataTypes.unshift( type );
	                    break;
	                }
	            }
	        }

	        // Check to see if we have a response for the expected dataType
	        if ( dataTypes[ 0 ] in responses ) {
	            finalDataType = dataTypes[ 0 ];
	        } else {
	            // Try convertible dataTypes
	            for ( type in responses ) {
	                if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
	                    finalDataType = type;
	                    break;
	                }
	                if ( !firstDataType ) {
	                    firstDataType = type;
	                }
	            }
	            // Or just use first one
	            finalDataType = finalDataType || firstDataType;
	        }

	        // If we found a dataType
	        // We add the dataType to the list if needed
	        // and return the corresponding response
	        if ( finalDataType ) {
	            if ( finalDataType !== dataTypes[ 0 ] ) {
	                dataTypes.unshift( finalDataType );
	            }
	            return responses[ finalDataType ];
	        }
	    }

	    /* Chain conversions given the request and the original response
	     * Also sets the responseXXX fields on the jqXHR instance
	     */
	    function ajaxConvert( s, response, jqXHR, isSuccess ) {
	        var conv2, current, conv, tmp, prev,
	            converters = {},
	        // Work with a copy of dataTypes in case we need to modify it for conversion
	            dataTypes = s.dataTypes.slice();

	        // Create converters map with lowercased keys
	        if ( dataTypes[ 1 ] ) {
	            for ( conv in s.converters ) {
	                converters[ conv.toLowerCase() ] = s.converters[ conv ];
	            }
	        }

	        current = dataTypes.shift();

	        // Convert to each sequential dataType
	        while ( current ) {

	            if ( s.responseFields[ current ] ) {
	                jqXHR[ s.responseFields[ current ] ] = response;
	            }

	            // Apply the dataFilter if provided
	            if ( !prev && isSuccess && s.dataFilter ) {
	                response = s.dataFilter( response, s.dataType );
	            }

	            prev = current;
	            current = dataTypes.shift();

	            if ( current ) {

	                // There's only work to do if current dataType is non-auto
	                if ( current === "*" ) {

	                    current = prev;

	                    // Convert response if prev dataType is non-auto and differs from current
	                } else if ( prev !== "*" && prev !== current ) {

	                    // Seek a direct converter
	                    conv = converters[ prev + " " + current ] || converters[ "* " + current ];

	                    // If none found, seek a pair
	                    if ( !conv ) {
	                        for ( conv2 in converters ) {

	                            // If conv2 outputs current
	                            tmp = conv2.split( " " );
	                            if ( tmp[ 1 ] === current ) {

	                                // If prev can be converted to accepted input
	                                conv = converters[ prev + " " + tmp[ 0 ] ] ||
	                                    converters[ "* " + tmp[ 0 ] ];
	                                if ( conv ) {
	                                    // Condense equivalence converters
	                                    if ( conv === true ) {
	                                        conv = converters[ conv2 ];

	                                        // Otherwise, insert the intermediate dataType
	                                    } else if ( converters[ conv2 ] !== true ) {
	                                        current = tmp[ 0 ];
	                                        dataTypes.unshift( tmp[ 1 ] );
	                                    }
	                                    break;
	                                }
	                            }
	                        }
	                    }

	                    // Apply converter (if not an equivalence)
	                    if ( conv !== true ) {

	                        // Unless errors are allowed to bubble, catch and return them
	                        if ( conv && s[ "throws" ] ) {
	                            response = conv( response );
	                        } else {
	                            try {
	                                response = conv( response );
	                            } catch ( e ) {
	                                return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
	                            }
	                        }
	                    }
	                }
	            }
	        }

	        return { state: "success", data: response };
	    }

	    jQuery.extend({

	        // Counter for holding the number of active queries
	        active: 0,

	        // Last-Modified header cache for next request
	        lastModified: {},
	        etag: {},

	        ajaxSettings: {
	            url: ajaxLocation,
	            type: "GET",
	            isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
	            global: true,
	            processData: true,
	            async: true,
	            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
	            /*
	             timeout: 0,
	             data: null,
	             dataType: null,
	             username: null,
	             password: null,
	             cache: null,
	             throws: false,
	             traditional: false,
	             headers: {},
	             */

	            accepts: {
	                "*": allTypes,
	                text: "text/plain",
	                html: "text/html",
	                xml: "application/xml, text/xml",
	                json: "application/json, text/javascript"
	            },

	            contents: {
	                xml: /xml/,
	                html: /html/,
	                json: /json/
	            },

	            responseFields: {
	                xml: "responseXML",
	                text: "responseText",
	                json: "responseJSON"
	            },

	            // Data converters
	            // Keys separate source (or catchall "*") and destination types with a single space
	            converters: {

	                // Convert anything to text
	                "* text": String,

	                // Text to html (true = no transformation)
	                "text html": true,

	                // Evaluate text as a json expression
	                "text json": jQuery.parseJSON,

	                // Parse text as xml
	                "text xml": jQuery.parseXML
	            },

	            // For options that shouldn't be deep extended:
	            // you can add your own custom options here if
	            // and when you create one that shouldn't be
	            // deep extended (see ajaxExtend)
	            flatOptions: {
	                url: true,
	                context: true
	            }
	        },

	        // Creates a full fledged settings object into target
	        // with both ajaxSettings and settings fields.
	        // If target is omitted, writes into ajaxSettings.
	        ajaxSetup: function( target, settings ) {
	            return settings ?

	                // Building a settings object
	                ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

	                // Extending ajaxSettings
	                ajaxExtend( jQuery.ajaxSettings, target );
	        },

	        ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	        ajaxTransport: addToPrefiltersOrTransports( transports ),

	        // Main method
	        ajax: function( url, options ) {

	            // If url is an object, simulate pre-1.5 signature
	            if ( typeof url === "object" ) {
	                options = url;
	                url = undefined;
	            }

	            // Force options to be an object
	            options = options || {};

	            var // Cross-domain detection vars
	                parts,
	            // Loop variable
	                i,
	            // URL without anti-cache param
	                cacheURL,
	            // Response headers as string
	                responseHeadersString,
	            // timeout handle
	                timeoutTimer,

	            // To know if global events are to be dispatched
	                fireGlobals,

	                transport,
	            // Response headers
	                responseHeaders,
	            // Create the final options object
	                s = jQuery.ajaxSetup( {}, options ),
	            // Callbacks context
	                callbackContext = s.context || s,
	            // Context for global events is callbackContext if it is a DOM node or jQuery collection
	                globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
	                    jQuery( callbackContext ) :
	                    jQuery.event,
	            // Deferreds
	                deferred = jQuery.Deferred(),
	                completeDeferred = jQuery.Callbacks("once memory"),
	            // Status-dependent callbacks
	                statusCode = s.statusCode || {},
	            // Headers (they are sent all at once)
	                requestHeaders = {},
	                requestHeadersNames = {},
	            // The jqXHR state
	                state = 0,
	            // Default abort message
	                strAbort = "canceled",
	            // Fake xhr
	                jqXHR = {
	                    readyState: 0,

	                    // Builds headers hashtable if needed
	                    getResponseHeader: function( key ) {
	                        var match;
	                        if ( state === 2 ) {
	                            if ( !responseHeaders ) {
	                                responseHeaders = {};
	                                while ( (match = rheaders.exec( responseHeadersString )) ) {
	                                    responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
	                                }
	                            }
	                            match = responseHeaders[ key.toLowerCase() ];
	                        }
	                        return match == null ? null : match;
	                    },

	                    // Raw string
	                    getAllResponseHeaders: function() {
	                        return state === 2 ? responseHeadersString : null;
	                    },

	                    // Caches the header
	                    setRequestHeader: function( name, value ) {
	                        var lname = name.toLowerCase();
	                        if ( !state ) {
	                            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
	                            requestHeaders[ name ] = value;
	                        }
	                        return this;
	                    },

	                    // Overrides response content-type header
	                    overrideMimeType: function( type ) {
	                        if ( !state ) {
	                            s.mimeType = type;
	                        }
	                        return this;
	                    },

	                    // Status-dependent callbacks
	                    statusCode: function( map ) {
	                        var code;
	                        if ( map ) {
	                            if ( state < 2 ) {
	                                for ( code in map ) {
	                                    // Lazy-add the new callback in a way that preserves old ones
	                                    statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
	                                }
	                            } else {
	                                // Execute the appropriate callbacks
	                                jqXHR.always( map[ jqXHR.status ] );
	                            }
	                        }
	                        return this;
	                    },

	                    // Cancel the request
	                    abort: function( statusText ) {
	                        var finalText = statusText || strAbort;
	                        if ( transport ) {
	                            transport.abort( finalText );
	                        }
	                        done( 0, finalText );
	                        return this;
	                    }
	                };

	            // Attach deferreds
	            deferred.promise( jqXHR ).complete = completeDeferred.add;
	            jqXHR.success = jqXHR.done;
	            jqXHR.error = jqXHR.fail;

	            // Remove hash character (#7531: and string promotion)
	            // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
	            // Handle falsy url in the settings object (#10093: consistency with old signature)
	            // We also use the url parameter if available
	            s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

	            // Alias method option to type as per ticket #12004
	            s.type = options.method || options.type || s.method || s.type;

	            // Extract dataTypes list
	            s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

	            // A cross-domain request is in order when we have a protocol:host:port mismatch
	            if ( s.crossDomain == null ) {
	                parts = rurl.exec( s.url.toLowerCase() );
	                s.crossDomain = !!( parts &&
	                    ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
	                    ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
	                    ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
	                );
	            }

	            // Convert data if not already a string
	            if ( s.data && s.processData && typeof s.data !== "string" ) {
	                s.data = jQuery.param( s.data, s.traditional );
	            }

	            // Apply prefilters
	            inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

	            // If request was aborted inside a prefilter, stop there
	            if ( state === 2 ) {
	                return jqXHR;
	            }

	            // We can fire global events as of now if asked to
	            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
	            fireGlobals = jQuery.event && s.global;

	            // Watch for a new set of requests
	            if ( fireGlobals && jQuery.active++ === 0 ) {
	                jQuery.event.trigger("ajaxStart");
	            }

	            // Uppercase the type
	            s.type = s.type.toUpperCase();

	            // Determine if request has content
	            s.hasContent = !rnoContent.test( s.type );

	            // Save the URL in case we're toying with the If-Modified-Since
	            // and/or If-None-Match header later on
	            cacheURL = s.url;

	            // More options handling for requests with no content
	            if ( !s.hasContent ) {

	                // If data is available, append data to url
	                if ( s.data ) {
	                    cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
	                    // #9682: remove data so that it's not used in an eventual retry
	                    delete s.data;
	                }

	                // Add anti-cache in url if needed
	                if ( s.cache === false ) {
	                    s.url = rts.test( cacheURL ) ?

	                        // If there is already a '_' parameter, set its value
	                        cacheURL.replace( rts, "$1_=" + nonce++ ) :

	                        // Otherwise add one to the end
	                    cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
	                }
	            }

	            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
	            if ( s.ifModified ) {
	                if ( jQuery.lastModified[ cacheURL ] ) {
	                    jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
	                }
	                if ( jQuery.etag[ cacheURL ] ) {
	                    jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
	                }
	            }

	            // Set the correct header, if data is being sent
	            if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
	                jqXHR.setRequestHeader( "Content-Type", s.contentType );
	            }

	            // Set the Accepts header for the server, depending on the dataType
	            jqXHR.setRequestHeader(
	                "Accept",
	                s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
	                s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
	                    s.accepts[ "*" ]
	            );

	            // Check for headers option
	            for ( i in s.headers ) {
	                jqXHR.setRequestHeader( i, s.headers[ i ] );
	            }

	            // Allow custom headers/mimetypes and early abort
	            if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
	                // Abort if not done already and return
	                return jqXHR.abort();
	            }

	            // aborting is no longer a cancellation
	            strAbort = "abort";

	            // Install callbacks on deferreds
	            for ( i in { success: 1, error: 1, complete: 1 } ) {
	                jqXHR[ i ]( s[ i ] );
	            }

	            // Get transport
	            transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

	            // If no transport, we auto-abort
	            if ( !transport ) {
	                done( -1, "No Transport" );
	            } else {
	                jqXHR.readyState = 1;

	                // Send global event
	                if ( fireGlobals ) {
	                    globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
	                }
	                // Timeout
	                if ( s.async && s.timeout > 0 ) {
	                    timeoutTimer = setTimeout(function() {
	                        jqXHR.abort("timeout");
	                    }, s.timeout );
	                }

	                try {
	                    state = 1;
	                    transport.send( requestHeaders, done );
	                } catch ( e ) {
	                    // Propagate exception as error if not done
	                    if ( state < 2 ) {
	                        done( -1, e );
	                        // Simply rethrow otherwise
	                    } else {
	                        throw e;
	                    }
	                }
	            }

	            // Callback for when everything is done
	            function done( status, nativeStatusText, responses, headers ) {
	                var isSuccess, success, error, response, modified,
	                    statusText = nativeStatusText;

	                // Called once
	                if ( state === 2 ) {
	                    return;
	                }

	                // State is "done" now
	                state = 2;

	                // Clear timeout if it exists
	                if ( timeoutTimer ) {
	                    clearTimeout( timeoutTimer );
	                }

	                // Dereference transport for early garbage collection
	                // (no matter how long the jqXHR object will be used)
	                transport = undefined;

	                // Cache response headers
	                responseHeadersString = headers || "";

	                // Set readyState
	                jqXHR.readyState = status > 0 ? 4 : 0;

	                // Determine if successful
	                isSuccess = status >= 200 && status < 300 || status === 304;

	                // Get response data
	                if ( responses ) {
	                    response = ajaxHandleResponses( s, jqXHR, responses );
	                }

	                // Convert no matter what (that way responseXXX fields are always set)
	                response = ajaxConvert( s, response, jqXHR, isSuccess );

	                // If successful, handle type chaining
	                if ( isSuccess ) {

	                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
	                    if ( s.ifModified ) {
	                        modified = jqXHR.getResponseHeader("Last-Modified");
	                        if ( modified ) {
	                            jQuery.lastModified[ cacheURL ] = modified;
	                        }
	                        modified = jqXHR.getResponseHeader("etag");
	                        if ( modified ) {
	                            jQuery.etag[ cacheURL ] = modified;
	                        }
	                    }

	                    // if no content
	                    if ( status === 204 || s.type === "HEAD" ) {
	                        statusText = "nocontent";

	                        // if not modified
	                    } else if ( status === 304 ) {
	                        statusText = "notmodified";

	                        // If we have data, let's convert it
	                    } else {
	                        statusText = response.state;
	                        success = response.data;
	                        error = response.error;
	                        isSuccess = !error;
	                    }
	                } else {
	                    // We extract error from statusText
	                    // then normalize statusText and status for non-aborts
	                    error = statusText;
	                    if ( status || !statusText ) {
	                        statusText = "error";
	                        if ( status < 0 ) {
	                            status = 0;
	                        }
	                    }
	                }

	                // Set data for the fake xhr object
	                jqXHR.status = status;
	                jqXHR.statusText = ( nativeStatusText || statusText ) + "";

	                // Success/Error
	                if ( isSuccess ) {
	                    deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
	                } else {
	                    deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
	                }

	                // Status-dependent callbacks
	                jqXHR.statusCode( statusCode );
	                statusCode = undefined;

	                if ( fireGlobals ) {
	                    globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
	                        [ jqXHR, s, isSuccess ? success : error ] );
	                }

	                // Complete
	                completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

	                if ( fireGlobals ) {
	                    globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
	                    // Handle the global AJAX counter
	                    if ( !( --jQuery.active ) ) {
	                        jQuery.event.trigger("ajaxStop");
	                    }
	                }
	            }

	            return jqXHR;
	        },

	        getJSON: function( url, data, callback ) {
	            return jQuery.get( url, data, callback, "json" );
	        },

	        getScript: function( url, callback ) {
	            return jQuery.get( url, undefined, callback, "script" );
	        }
	    });

	    jQuery.each( [ "get", "post" ], function( i, method ) {
	        jQuery[ method ] = function( url, data, callback, type ) {
	            // shift arguments if data argument was omitted
	            if ( jQuery.isFunction( data ) ) {
	                type = type || callback;
	                callback = data;
	                data = undefined;
	            }

	            return jQuery.ajax({
	                url: url,
	                type: method,
	                dataType: type,
	                data: data,
	                success: callback
	            });
	        };
	    });


	    jQuery._evalUrl = function( url ) {
	        return jQuery.ajax({
	            url: url,
	            type: "GET",
	            dataType: "script",
	            async: false,
	            global: false,
	            "throws": true
	        });
	    };


	    jQuery.fn.extend({
	        wrapAll: function( html ) {
	            if ( jQuery.isFunction( html ) ) {
	                return this.each(function(i) {
	                    jQuery(this).wrapAll( html.call(this, i) );
	                });
	            }

	            if ( this[0] ) {
	                // The elements to wrap the target around
	                var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

	                if ( this[0].parentNode ) {
	                    wrap.insertBefore( this[0] );
	                }

	                wrap.map(function() {
	                    var elem = this;

	                    while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
	                        elem = elem.firstChild;
	                    }

	                    return elem;
	                }).append( this );
	            }

	            return this;
	        },

	        wrapInner: function( html ) {
	            if ( jQuery.isFunction( html ) ) {
	                return this.each(function(i) {
	                    jQuery(this).wrapInner( html.call(this, i) );
	                });
	            }

	            return this.each(function() {
	                var self = jQuery( this ),
	                    contents = self.contents();

	                if ( contents.length ) {
	                    contents.wrapAll( html );

	                } else {
	                    self.append( html );
	                }
	            });
	        },

	        wrap: function( html ) {
	            var isFunction = jQuery.isFunction( html );

	            return this.each(function(i) {
	                jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
	            });
	        },

	        unwrap: function() {
	            return this.parent().each(function() {
	                if ( !jQuery.nodeName( this, "body" ) ) {
	                    jQuery( this ).replaceWith( this.childNodes );
	                }
	            }).end();
	        }
	    });


	    jQuery.expr.filters.hidden = function( elem ) {
	        // Support: Opera <= 12.12
	        // Opera reports offsetWidths and offsetHeights less than zero on some elements
	        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
	            (!support.reliableHiddenOffsets() &&
	            ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	    };

	    jQuery.expr.filters.visible = function( elem ) {
	        return !jQuery.expr.filters.hidden( elem );
	    };




	    var r20 = /%20/g,
	        rbracket = /\[\]$/,
	        rCRLF = /\r?\n/g,
	        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	        rsubmittable = /^(?:input|select|textarea|keygen)/i;

	    function buildParams( prefix, obj, traditional, add ) {
	        var name;

	        if ( jQuery.isArray( obj ) ) {
	            // Serialize array item.
	            jQuery.each( obj, function( i, v ) {
	                if ( traditional || rbracket.test( prefix ) ) {
	                    // Treat each array item as a scalar.
	                    add( prefix, v );

	                } else {
	                    // Item is non-scalar (array or object), encode its numeric index.
	                    buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
	                }
	            });

	        } else if ( !traditional && jQuery.type( obj ) === "object" ) {
	            // Serialize object item.
	            for ( name in obj ) {
	                buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
	            }

	        } else {
	            // Serialize scalar item.
	            add( prefix, obj );
	        }
	    }

	// Serialize an array of form elements or a set of
	// key/values into a query string
	    jQuery.param = function( a, traditional ) {
	        var prefix,
	            s = [],
	            add = function( key, value ) {
	                // If value is a function, invoke it and return its value
	                value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
	                s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
	            };

	        // Set traditional to true for jQuery <= 1.3.2 behavior.
	        if ( traditional === undefined ) {
	            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	        }

	        // If an array was passed in, assume that it is an array of form elements.
	        if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
	            // Serialize the form elements
	            jQuery.each( a, function() {
	                add( this.name, this.value );
	            });

	        } else {
	            // If traditional, encode the "old" way (the way 1.3.2 or older
	            // did it), otherwise encode params recursively.
	            for ( prefix in a ) {
	                buildParams( prefix, a[ prefix ], traditional, add );
	            }
	        }

	        // Return the resulting serialization
	        return s.join( "&" ).replace( r20, "+" );
	    };

	    jQuery.fn.extend({
	        serialize: function() {
	            return jQuery.param( this.serializeArray() );
	        },
	        serializeArray: function() {
	            return this.map(function() {
	                    // Can add propHook for "elements" to filter or add form elements
	                    var elements = jQuery.prop( this, "elements" );
	                    return elements ? jQuery.makeArray( elements ) : this;
	                })
	                .filter(function() {
	                    var type = this.type;
	                    // Use .is(":disabled") so that fieldset[disabled] works
	                    return this.name && !jQuery( this ).is( ":disabled" ) &&
	                        rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
	                        ( this.checked || !rcheckableType.test( type ) );
	                })
	                .map(function( i, elem ) {
	                    var val = jQuery( this ).val();

	                    return val == null ?
	                        null :
	                        jQuery.isArray( val ) ?
	                            jQuery.map( val, function( val ) {
	                                return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
	                            }) :
	                        { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
	                }).get();
	        }
	    });


	// Create the request object
	// (This is still attached to ajaxSettings for backward compatibility)
	    jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
	        // Support: IE6+
	        function() {

	            // XHR cannot access local files, always use ActiveX for that case
	            return !this.isLocal &&

	                // Support: IE7-8
	                // oldIE XHR does not support non-RFC2616 methods (#13240)
	                // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
	                // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
	                // Although this check for six methods instead of eight
	                // since IE also does not support "trace" and "connect"
	                /^(get|post|head|put|delete|options)$/i.test( this.type ) &&

	                createStandardXHR() || createActiveXHR();
	        } :
	        // For all other browsers, use the standard XMLHttpRequest object
	        createStandardXHR;

	    var xhrId = 0,
	        xhrCallbacks = {},
	        xhrSupported = jQuery.ajaxSettings.xhr();

	// Support: IE<10
	// Open requests must be manually aborted on unload (#5280)
	// See https://support.microsoft.com/kb/2856746 for more info
	    if ( window.attachEvent ) {
	        window.attachEvent( "onunload", function() {
	            for ( var key in xhrCallbacks ) {
	                xhrCallbacks[ key ]( undefined, true );
	            }
	        });
	    }

	// Determine support properties
	    support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	    xhrSupported = support.ajax = !!xhrSupported;

	// Create transport if the browser can provide an xhr
	    if ( xhrSupported ) {

	        jQuery.ajaxTransport(function( options ) {
	            // Cross domain only allowed if supported through XMLHttpRequest
	            if ( !options.crossDomain || support.cors ) {

	                var callback;

	                return {
	                    send: function( headers, complete ) {
	                        var i,
	                            xhr = options.xhr(),
	                            id = ++xhrId;

	                        // Open the socket
	                        xhr.open( options.type, options.url, options.async, options.username, options.password );

	                        // Apply custom fields if provided
	                        if ( options.xhrFields ) {
	                            for ( i in options.xhrFields ) {
	                                xhr[ i ] = options.xhrFields[ i ];
	                            }
	                        }

	                        // Override mime type if needed
	                        if ( options.mimeType && xhr.overrideMimeType ) {
	                            xhr.overrideMimeType( options.mimeType );
	                        }

	                        // X-Requested-With header
	                        // For cross-domain requests, seeing as conditions for a preflight are
	                        // akin to a jigsaw puzzle, we simply never set it to be sure.
	                        // (it can always be set on a per-request basis or even using ajaxSetup)
	                        // For same-domain requests, won't change header if already provided.
	                        if ( !options.crossDomain && !headers["X-Requested-With"] ) {
	                            headers["X-Requested-With"] = "XMLHttpRequest";
	                        }

	                        // Set headers
	                        for ( i in headers ) {
	                            // Support: IE<9
	                            // IE's ActiveXObject throws a 'Type Mismatch' exception when setting
	                            // request header to a null-value.
	                            //
	                            // To keep consistent with other XHR implementations, cast the value
	                            // to string and ignore `undefined`.
	                            if ( headers[ i ] !== undefined ) {
	                                xhr.setRequestHeader( i, headers[ i ] + "" );
	                            }
	                        }

	                        // Do send the request
	                        // This may raise an exception which is actually
	                        // handled in jQuery.ajax (so no try/catch here)
	                        xhr.send( ( options.hasContent && options.data ) || null );

	                        // Listener
	                        callback = function( _, isAbort ) {
	                            var status, statusText, responses;

	                            // Was never called and is aborted or complete
	                            if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
	                                // Clean up
	                                delete xhrCallbacks[ id ];
	                                callback = undefined;
	                                xhr.onreadystatechange = jQuery.noop;

	                                // Abort manually if needed
	                                if ( isAbort ) {
	                                    if ( xhr.readyState !== 4 ) {
	                                        xhr.abort();
	                                    }
	                                } else {
	                                    responses = {};
	                                    status = xhr.status;

	                                    // Support: IE<10
	                                    // Accessing binary-data responseText throws an exception
	                                    // (#11426)
	                                    if ( typeof xhr.responseText === "string" ) {
	                                        responses.text = xhr.responseText;
	                                    }

	                                    // Firefox throws an exception when accessing
	                                    // statusText for faulty cross-domain requests
	                                    try {
	                                        statusText = xhr.statusText;
	                                    } catch( e ) {
	                                        // We normalize with Webkit giving an empty statusText
	                                        statusText = "";
	                                    }

	                                    // Filter status for non standard behaviors

	                                    // If the request is local and we have data: assume a success
	                                    // (success with no data won't get notified, that's the best we
	                                    // can do given current implementations)
	                                    if ( !status && options.isLocal && !options.crossDomain ) {
	                                        status = responses.text ? 200 : 404;
	                                        // IE - #1450: sometimes returns 1223 when it should be 204
	                                    } else if ( status === 1223 ) {
	                                        status = 204;
	                                    }
	                                }
	                            }

	                            // Call complete if needed
	                            if ( responses ) {
	                                complete( status, statusText, responses, xhr.getAllResponseHeaders() );
	                            }
	                        };

	                        if ( !options.async ) {
	                            // if we're in sync mode we fire the callback
	                            callback();
	                        } else if ( xhr.readyState === 4 ) {
	                            // (IE6 & IE7) if it's in cache and has been
	                            // retrieved directly we need to fire the callback
	                            setTimeout( callback );
	                        } else {
	                            // Add to the list of active xhr callbacks
	                            xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
	                        }
	                    },

	                    abort: function() {
	                        if ( callback ) {
	                            callback( undefined, true );
	                        }
	                    }
	                };
	            }
	        });
	    }

	// Functions to create xhrs
	    function createStandardXHR() {
	        try {
	            return new window.XMLHttpRequest();
	        } catch( e ) {}
	    }

	    function createActiveXHR() {
	        try {
	            return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	        } catch( e ) {}
	    }




	// Install script dataType
	    jQuery.ajaxSetup({
	        accepts: {
	            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	        },
	        contents: {
	            script: /(?:java|ecma)script/
	        },
	        converters: {
	            "text script": function( text ) {
	                jQuery.globalEval( text );
	                return text;
	            }
	        }
	    });

	// Handle cache's special case and global
	    jQuery.ajaxPrefilter( "script", function( s ) {
	        if ( s.cache === undefined ) {
	            s.cache = false;
	        }
	        if ( s.crossDomain ) {
	            s.type = "GET";
	            s.global = false;
	        }
	    });

	// Bind script tag hack transport
	    jQuery.ajaxTransport( "script", function(s) {

	        // This transport only deals with cross domain requests
	        if ( s.crossDomain ) {

	            var script,
	                head = document.head || jQuery("head")[0] || document.documentElement;

	            return {

	                send: function( _, callback ) {

	                    script = document.createElement("script");

	                    script.async = true;

	                    if ( s.scriptCharset ) {
	                        script.charset = s.scriptCharset;
	                    }

	                    script.src = s.url;

	                    // Attach handlers for all browsers
	                    script.onload = script.onreadystatechange = function( _, isAbort ) {

	                        if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

	                            // Handle memory leak in IE
	                            script.onload = script.onreadystatechange = null;

	                            // Remove the script
	                            if ( script.parentNode ) {
	                                script.parentNode.removeChild( script );
	                            }

	                            // Dereference the script
	                            script = null;

	                            // Callback if not abort
	                            if ( !isAbort ) {
	                                callback( 200, "success" );
	                            }
	                        }
	                    };

	                    // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
	                    // Use native DOM manipulation to avoid our domManip AJAX trickery
	                    head.insertBefore( script, head.firstChild );
	                },

	                abort: function() {
	                    if ( script ) {
	                        script.onload( undefined, true );
	                    }
	                }
	            };
	        }
	    });




	    var oldCallbacks = [],
	        rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	    jQuery.ajaxSetup({
	        jsonp: "callback",
	        jsonpCallback: function() {
	            var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
	            this[ callback ] = true;
	            return callback;
	        }
	    });

	// Detect, normalize options and install callbacks for jsonp requests
	    jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	        var callbackName, overwritten, responseContainer,
	            jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
	                        "url" :
	                    typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
	                );

	        // Handle iff the expected data type is "jsonp" or we have a parameter to set
	        if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

	            // Get callback name, remembering preexisting value associated with it
	            callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
	                s.jsonpCallback() :
	                s.jsonpCallback;

	            // Insert callback into url or form data
	            if ( jsonProp ) {
	                s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
	            } else if ( s.jsonp !== false ) {
	                s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
	            }

	            // Use data converter to retrieve json after script execution
	            s.converters["script json"] = function() {
	                if ( !responseContainer ) {
	                    jQuery.error( callbackName + " was not called" );
	                }
	                return responseContainer[ 0 ];
	            };

	            // force json dataType
	            s.dataTypes[ 0 ] = "json";

	            // Install callback
	            overwritten = window[ callbackName ];
	            window[ callbackName ] = function() {
	                responseContainer = arguments;
	            };

	            // Clean-up function (fires after converters)
	            jqXHR.always(function() {
	                // Restore preexisting value
	                window[ callbackName ] = overwritten;

	                // Save back as free
	                if ( s[ callbackName ] ) {
	                    // make sure that re-using the options doesn't screw things around
	                    s.jsonpCallback = originalSettings.jsonpCallback;

	                    // save the callback name for future use
	                    oldCallbacks.push( callbackName );
	                }

	                // Call if it was a function and we have a response
	                if ( responseContainer && jQuery.isFunction( overwritten ) ) {
	                    overwritten( responseContainer[ 0 ] );
	                }

	                responseContainer = overwritten = undefined;
	            });

	            // Delegate to script
	            return "script";
	        }
	    });




	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	    jQuery.parseHTML = function( data, context, keepScripts ) {
	        if ( !data || typeof data !== "string" ) {
	            return null;
	        }
	        if ( typeof context === "boolean" ) {
	            keepScripts = context;
	            context = false;
	        }
	        context = context || document;

	        var parsed = rsingleTag.exec( data ),
	            scripts = !keepScripts && [];

	        // Single tag
	        if ( parsed ) {
	            return [ context.createElement( parsed[1] ) ];
	        }

	        parsed = jQuery.buildFragment( [ data ], context, scripts );

	        if ( scripts && scripts.length ) {
	            jQuery( scripts ).remove();
	        }

	        return jQuery.merge( [], parsed.childNodes );
	    };


	// Keep a copy of the old load method
	    var _load = jQuery.fn.load;

	    /**
	     * Load a url into a page
	     */
	    jQuery.fn.load = function( url, params, callback ) {
	        if ( typeof url !== "string" && _load ) {
	            return _load.apply( this, arguments );
	        }

	        var selector, response, type,
	            self = this,
	            off = url.indexOf(" ");

	        if ( off >= 0 ) {
	            selector = jQuery.trim( url.slice( off, url.length ) );
	            url = url.slice( 0, off );
	        }

	        // If it's a function
	        if ( jQuery.isFunction( params ) ) {

	            // We assume that it's the callback
	            callback = params;
	            params = undefined;

	            // Otherwise, build a param string
	        } else if ( params && typeof params === "object" ) {
	            type = "POST";
	        }

	        // If we have elements to modify, make the request
	        if ( self.length > 0 ) {
	            jQuery.ajax({
	                url: url,

	                // if "type" variable is undefined, then "GET" method will be used
	                type: type,
	                dataType: "html",
	                data: params
	            }).done(function( responseText ) {

	                // Save response for use in complete callback
	                response = arguments;

	                self.html( selector ?

	                    // If a selector was specified, locate the right elements in a dummy div
	                    // Exclude scripts to avoid IE 'Permission Denied' errors
	                    jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

	                    // Otherwise use the full result
	                    responseText );

	            }).complete( callback && function( jqXHR, status ) {
	                    self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
	                });
	        }

	        return this;
	    };




	// Attach a bunch of functions for handling common AJAX events
	    jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	        jQuery.fn[ type ] = function( fn ) {
	            return this.on( type, fn );
	        };
	    });




	    jQuery.expr.filters.animated = function( elem ) {
	        return jQuery.grep(jQuery.timers, function( fn ) {
	            return elem === fn.elem;
	        }).length;
	    };





	    var docElem = window.document.documentElement;

	    /**
	     * Gets a window from an element
	     */
	    function getWindow( elem ) {
	        return jQuery.isWindow( elem ) ?
	            elem :
	            elem.nodeType === 9 ?
	            elem.defaultView || elem.parentWindow :
	                false;
	    }

	    jQuery.offset = {
	        setOffset: function( elem, options, i ) {
	            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
	                position = jQuery.css( elem, "position" ),
	                curElem = jQuery( elem ),
	                props = {};

	            // set position first, in-case top/left are set even on static elem
	            if ( position === "static" ) {
	                elem.style.position = "relative";
	            }

	            curOffset = curElem.offset();
	            curCSSTop = jQuery.css( elem, "top" );
	            curCSSLeft = jQuery.css( elem, "left" );
	            calculatePosition = ( position === "absolute" || position === "fixed" ) &&
	                jQuery.inArray("auto", [ curCSSTop, curCSSLeft ] ) > -1;

	            // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
	            if ( calculatePosition ) {
	                curPosition = curElem.position();
	                curTop = curPosition.top;
	                curLeft = curPosition.left;
	            } else {
	                curTop = parseFloat( curCSSTop ) || 0;
	                curLeft = parseFloat( curCSSLeft ) || 0;
	            }

	            if ( jQuery.isFunction( options ) ) {
	                options = options.call( elem, i, curOffset );
	            }

	            if ( options.top != null ) {
	                props.top = ( options.top - curOffset.top ) + curTop;
	            }
	            if ( options.left != null ) {
	                props.left = ( options.left - curOffset.left ) + curLeft;
	            }

	            if ( "using" in options ) {
	                options.using.call( elem, props );
	            } else {
	                curElem.css( props );
	            }
	        }
	    };

	    jQuery.fn.extend({
	        offset: function( options ) {
	            if ( arguments.length ) {
	                return options === undefined ?
	                    this :
	                    this.each(function( i ) {
	                        jQuery.offset.setOffset( this, options, i );
	                    });
	            }

	            var docElem, win,
	                box = { top: 0, left: 0 },
	                elem = this[ 0 ],
	                doc = elem && elem.ownerDocument;

	            if ( !doc ) {
	                return;
	            }

	            docElem = doc.documentElement;

	            // Make sure it's not a disconnected DOM node
	            if ( !jQuery.contains( docElem, elem ) ) {
	                return box;
	            }

	            // If we don't have gBCR, just use 0,0 rather than error
	            // BlackBerry 5, iOS 3 (original iPhone)
	            if ( typeof elem.getBoundingClientRect !== strundefined ) {
	                box = elem.getBoundingClientRect();
	            }
	            win = getWindow( doc );
	            return {
	                top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
	                left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
	            };
	        },

	        position: function() {
	            if ( !this[ 0 ] ) {
	                return;
	            }

	            var offsetParent, offset,
	                parentOffset = { top: 0, left: 0 },
	                elem = this[ 0 ];

	            // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
	            if ( jQuery.css( elem, "position" ) === "fixed" ) {
	                // we assume that getBoundingClientRect is available when computed position is fixed
	                offset = elem.getBoundingClientRect();
	            } else {
	                // Get *real* offsetParent
	                offsetParent = this.offsetParent();

	                // Get correct offsets
	                offset = this.offset();
	                if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
	                    parentOffset = offsetParent.offset();
	                }

	                // Add offsetParent borders
	                parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
	                parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
	            }

	            // Subtract parent offsets and element margins
	            // note: when an element has margin: auto the offsetLeft and marginLeft
	            // are the same in Safari causing offset.left to incorrectly be 0
	            return {
	                top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
	                left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
	            };
	        },

	        offsetParent: function() {
	            return this.map(function() {
	                var offsetParent = this.offsetParent || docElem;

	                while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
	                    offsetParent = offsetParent.offsetParent;
	                }
	                return offsetParent || docElem;
	            });
	        }
	    });

	// Create scrollLeft and scrollTop methods
	    jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	        var top = /Y/.test( prop );

	        jQuery.fn[ method ] = function( val ) {
	            return access( this, function( elem, method, val ) {
	                var win = getWindow( elem );

	                if ( val === undefined ) {
	                    return win ? (prop in win) ? win[ prop ] :
	                        win.document.documentElement[ method ] :
	                        elem[ method ];
	                }

	                if ( win ) {
	                    win.scrollTo(
	                        !top ? val : jQuery( win ).scrollLeft(),
	                        top ? val : jQuery( win ).scrollTop()
	                    );

	                } else {
	                    elem[ method ] = val;
	                }
	            }, method, val, arguments.length, null );
	        };
	    });

	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// getComputedStyle returns percent when specified for top/left/bottom/right
	// rather than make the css module depend on the offset module, we just check for it here
	    jQuery.each( [ "top", "left" ], function( i, prop ) {
	        jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
	            function( elem, computed ) {
	                if ( computed ) {
	                    computed = curCSS( elem, prop );
	                    // if curCSS returns percentage, fallback to offset
	                    return rnumnonpx.test( computed ) ?
	                    jQuery( elem ).position()[ prop ] + "px" :
	                        computed;
	                }
	            }
	        );
	    });


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	    jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	        jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
	            // margin is only for outerHeight, outerWidth
	            jQuery.fn[ funcName ] = function( margin, value ) {
	                var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
	                    extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

	                return access( this, function( elem, type, value ) {
	                    var doc;

	                    if ( jQuery.isWindow( elem ) ) {
	                        // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
	                        // isn't a whole lot we can do. See pull request at this URL for discussion:
	                        // https://github.com/jquery/jquery/pull/764
	                        return elem.document.documentElement[ "client" + name ];
	                    }

	                    // Get document width or height
	                    if ( elem.nodeType === 9 ) {
	                        doc = elem.documentElement;

	                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
	                        // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
	                        return Math.max(
	                            elem.body[ "scroll" + name ], doc[ "scroll" + name ],
	                            elem.body[ "offset" + name ], doc[ "offset" + name ],
	                            doc[ "client" + name ]
	                        );
	                    }

	                    return value === undefined ?
	                        // Get width or height on the element, requesting but not forcing parseFloat
	                        jQuery.css( elem, type, extra ) :

	                        // Set width or height on the element
	                        jQuery.style( elem, type, value, extra );
	                }, type, chainable ? margin : undefined, chainable, null );
	            };
	        });
	    });


	// The number of elements contained in the matched element set
	    jQuery.fn.size = function() {
	        return this.length;
	    };

	    jQuery.fn.andSelf = jQuery.fn.addBack;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	    if ( true ) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	            return jQuery;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }




	    var
	    // Map over jQuery in case of overwrite
	        _jQuery = window.jQuery,

	    // Map over the $ in case of overwrite
	        _$ = window.$;

	    jQuery.noConflict = function( deep ) {
	        if ( window.$ === jQuery ) {
	            window.$ = _$;
	        }

	        if ( deep && window.jQuery === jQuery ) {
	            window.jQuery = _jQuery;
	        }

	        return jQuery;
	    };

	// Expose jQuery and $ identifiers, even in
	// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	    if ( typeof noGlobal === strundefined ) {
	        window.jQuery = window.$ = jQuery;
	    }




	    return jQuery;

	}));


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * built in 2016-8-8:11 version 2.110 by 司徒正美
	 * 修正 ms-click 在 ms-if 下失效的问题 #1652
	 * 修正 limitBy BUG
	 * 修正 节点对齐算法 BUG
	 * 优化 mediatorFactory
	 * 修正 data-for-rendered BUG
	 */
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["avalon"] = factory();
		else
			root["avalon"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {

		var avalon = __webpack_require__(82) 

		__webpack_require__(8)
		__webpack_require__(84)
		__webpack_require__(86)
		__webpack_require__(94)
		__webpack_require__(66)
		__webpack_require__(99)
		avalon.onComponentDispose = __webpack_require__(101)

		module.exports = avalon


	/***/ },
	/* 1 */,
	/* 2 */,
	/* 3 */
	/***/ function(module, exports) {

		/* WEBPACK VAR INJECTION */(function(global) {//avalon的核心,这里都是一些不存在异议的*核心*方法与属性
		function avalon(el) {
		    return new avalon.init(el)
		}

		global.avalon = avalon
		if(typeof window !== 'undefined'){
		    window.avalon = avalon
		}

		avalon.init = function (el) {
		    this[0] = this.element = el
		}

		avalon.fn = avalon.prototype = avalon.init.prototype


		avalon.shadowCopy = function (destination, source) {
		    for (var property in source) {
		        destination[property] = source[property]
		    }
		    return destination
		}

		var rword = /[^, ]+/g

		var hasConsole = global.console

		avalon.shadowCopy(avalon, {
		    noop: function () {
		    },
		    //切割字符串为一个个小块，以空格或逗号分开它们，结合replace实现字符串的forEach
		    rword: rword,
		    inspect: ({}).toString,
		    ohasOwn: ({}).hasOwnProperty,
		    log: function () {
		        if (hasConsole && avalon.config.debug) {
		            // http://stackoverflow.com/questions/8785624/how-to-safely-wrap-console-log
		            Function.apply.call(console.log, console, arguments)
		        }
		    },
		    warn: function () {
		        if (hasConsole && avalon.config.debug) {
		            var method = console.warn || console.log
		            // http://qiang106.iteye.com/blog/1721425
		            Function.apply.call(method, console, arguments)
		        }
		    },
		    error: function (str, e) {
		        throw (e || Error)(str)
		    },
		    //将一个以空格或逗号隔开的字符串或数组,转换成一个键值都为1的对象
		    oneObject: function (array, val) {
		        if (typeof array === 'string') {
		            array = array.match(rword) || []
		        }
		        var result = {},
		                value = val !== void 0 ? val : 1
		        for (var i = 0, n = array.length; i < n; i++) {
		            result[array[i]] = value
		        }
		        return result
		    }

		})

		module.exports = avalon
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

	/***/ },
	/* 4 */
	/***/ function(module, exports) {

		/* WEBPACK VAR INJECTION */(function(global) {var window = global
		var browser = {
		    window: window,
		    document: {//方便在nodejs环境不会报错
		        createElement: function () {
		            return {}
		        },
		        createElementNS: function(){
		            return {}
		        },
		        contains: Boolean
		    },
		    root: {
		        outerHTML: 'x'
		    },
		    msie: NaN,
		    modern: true,
		    avalonDiv: {},
		    avalonFragment: null
		}

		if(window.location && window.navigator && window.window){
		    var document = window.document
		    browser.document = document
		    browser.modern = window.dispatchEvent
		    browser.root = document.documentElement
		    browser.avalonDiv = document.createElement('div')
		    browser.avalonFragment = document.createDocumentFragment()
		    if (window.VBArray) {
		        browser.msie = document.documentMode || (window.XMLHttpRequest ? 7 : 6)
		    }
		}


		module.exports = browser
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

	/***/ },
	/* 5 */,
	/* 6 */
	/***/ function(module, exports) {

		var cssHooks = {}
		var rhyphen = /([a-z\d])([A-Z]+)/g
		var rcamelize = /[-_][^-_]/g
		var rhashcode = /\d\.\d{4}/
		var rescape = /[-.*+?^${}()|[\]\/\\]/g

		var _slice = [].slice
		function defaultParse(cur, pre, binding) {
		       cur[binding.name] = avalon.parseExpr(binding)
		}
		avalon.shadowCopy(avalon, {
		    caches: {}, //avalon2.0 新增
		    vmodels: {},
		    filters: {},
		    components: {},//放置组件的类
		    directives: {},
		    eventHooks: {},
		    eventListeners: {},
		    validators: {},
		    scopes: {},
		    cssHooks: cssHooks,
		    parsers: {
		        number: function (a) {
		            return a === '' ? '' : /\d\.$/.test(a) ? a : parseFloat(a) || 0
		        },
		        string: function (a) {
		            return a === null || a === void 0 ? '' : a + ''
		        },
		        boolean: function (a) {
		            if(a === '')
		                return a
		            return a === 'true'|| a == '1'
		        }
		    },
		    version: "2.110",
		    slice: function (nodes, start, end) {
		        return _slice.call(nodes, start, end)
		    },
		    css: function (node, name, value, fn) {
		        //读写删除元素节点的样式
		        if (node instanceof avalon) {
		            node = node[0]
		        }
		        if(node.nodeType !==1){
		            return
		        }
		        var prop = avalon.camelize(name)
		        name = avalon.cssName(prop) || prop
		        if (value === void 0 || typeof value === 'boolean') { //获取样式
		            fn = cssHooks[prop + ':get'] || cssHooks['@:get']
		            if (name === 'background') {
		                name = 'backgroundColor'
		            }
		            var val = fn(node, name)
		            return value === true ? parseFloat(val) || 0 : val
		        } else if (value === '') { //请除样式
		            node.style[name] = ''
		        } else { //设置样式
		            if (value == null || value !== value) {
		                return
		            }
		            if (isFinite(value) && !avalon.cssNumber[prop]) {
		                value += 'px'
		            }
		            fn = cssHooks[prop + ':set'] || cssHooks['@:set']
		            fn(node, name, value)
		        }
		    },
		    directive: function (name, definition) {
		        definition.parse = definition.parse || defaultParse
		        return this.directives[name] = definition
		    },
		    isObject: function (a) {//1.6新增
		        return a !== null && typeof a === 'object'
		    },
		    /* avalon.range(10)
		     => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
		     avalon.range(1, 11)
		     => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
		     avalon.range(0, 30, 5)
		     => [0, 5, 10, 15, 20, 25]
		     avalon.range(0, -10, -1)
		     => [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
		     avalon.range(0)
		     => []*/
		    range: function (start, end, step) { // 用于生成整数数组
		        step || (step = 1)
		        if (end == null) {
		            end = start || 0
		            start = 0
		        }
		        var index = -1,
		                length = Math.max(0, Math.ceil((end - start) / step)),
		                result = new Array(length)
		        while (++index < length) {
		            result[index] = start
		            start += step
		        }
		        return result
		    },
		    hyphen: function (target) {
		        //转换为连字符线风格
		        return target.replace(rhyphen, '$1-$2').toLowerCase()
		    },
		    camelize: function (target) {
		        //提前判断，提高getStyle等的效率
		        if (!target || target.indexOf('-') < 0 && target.indexOf('_') < 0) {
		            return target
		        }
		        //转换为驼峰风格
		        return target.replace(rcamelize, function (match) {
		            return match.charAt(1).toUpperCase()
		        })
		    },
		    //生成UUID http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
		    makeHashCode: function (prefix) {
		        prefix = prefix || 'avalon'
		        return String(Math.random() + Math.random()).replace(rhashcode, prefix)
		    },
		    escapeRegExp: function (target) {
		        //http://stevenlevithan.com/regex/xregexp/
		        //将字符串安全格式化为正则表达式的源码
		        return (target + '').replace(rescape, '\\$&')
		    },
		    Array: {
		        merge: function (target, other) {
		            //合并两个数组 avalon2新增
		            target.push.apply(target, other)
		        },
		        ensure: function (target, item) {
		            //只有当前数组不存在此元素时只添加它
		            if (target.indexOf(item) === -1) {
		                return target.push(item)
		            }
		        },
		        removeAt: function (target, index) {
		            //移除数组中指定位置的元素，返回布尔表示成功与否
		            return !!target.splice(index, 1).length
		        },
		        remove: function (target, item) {
		            //移除数组中第一个匹配传参的那个元素，返回布尔表示成功与否
		            var index = target.indexOf(item)
		            if (~index)
		                return avalon.Array.removeAt(target, index)
		            return false
		        }
		    }
		})

		if(typeof performance !== 'undefined' && performance.now){
		    avalon.makeHashCode = function (prefix) {
		        prefix = prefix || 'avalon'
		        return (prefix + performance.now()).replace('.', '')
		    }
		}

		var UUID = 1
		module.exports = {
		    //生成事件回调的UUID(用户通过ms-on指令)
		    avalon: avalon,
		    getLongID: function (fn) {
		        return fn.uuid || (fn.uuid = avalon.makeHashCode('e'))
		    },
		    //生成事件回调的UUID(用户通过avalon.bind)
		    getShortID: function (fn) {
		        return fn.uuid || (fn.uuid = '_' + (++UUID))
		    }
		}


	/***/ },
	/* 7 */
	/***/ function(module, exports) {

		
		function kernel(settings) {
		    for (var p in settings) {
		        if (!avalon.ohasOwn.call(settings, p))
		            continue
		        var val = settings[p]
		        if (typeof kernel.plugins[p] === 'function') {
		            kernel.plugins[p](val)
		        } else if (typeof kernel[p] === 'object') {
		            avalon.shadowCopy(kernel[p], val)
		        } else {
		            kernel[p] = val
		        }
		    }
		    return this
		}

		avalon.config = kernel

		var plugins = {
		    interpolate: function (array) {
		        var openTag = array[0]
		        var closeTag = array[1]
		        /*eslint-disable */
		        if (openTag === closeTag) {
		            throw new SyntaxError('openTag!==closeTag')
		        }
		        var test = openTag + 'test' + closeTag
		        var div = avalon.avalonDiv
		        div.innerHTML = test
		        if (div.innerHTML !== test && div.innerHTML.indexOf('&lt;') > -1) {
		            throw new SyntaxError('此定界符不合法')
		        }
		        div.innerHTML = ''
		        /*eslint-enable */
		        kernel.openTag = openTag
		        kernel.closeTag = closeTag
		        var o = avalon.escapeRegExp(openTag)
		        var c = avalon.escapeRegExp(closeTag)
		        kernel.rexpr = new RegExp(o + '([\\s\\S]*)' + c)
		        kernel.rexprg = new RegExp(o + '([\\s\\S]*)' + c, 'g')
		        kernel.rbind = new RegExp(o + '[\\s\\S]*' + c + '|\\bms-|\\bslot\\b')
		    }
		}
		kernel.plugins = plugins
		avalon.config({
		    interpolate: ['{{', '}}'],
		    debug: true
		})


	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {

		
		var number = __webpack_require__(9)
		var sanitize = __webpack_require__(10)
		var date = __webpack_require__(11)
		var arrayFilters = __webpack_require__(12)
		var eventFilters = __webpack_require__(13)
		var filters = avalon.filters

		function K(a) {
		    return a
		}

		avalon.__format__ = function (name) {
		    var fn = filters[name]
		    if (fn) {
		        return fn.get ? fn.get : fn
		    }
		    return K
		}


		avalon.mix(filters, {
		    uppercase: function (str) {
		        return String(str).toUpperCase()
		    },
		    lowercase: function (str) {
		        return String(str).toLowerCase()
		    },
		    truncate: function (str, length, truncation) {
		        //length，新字符串长度，truncation，新字符串的结尾的字段,返回新字符串
		        length = length || 30
		        truncation = typeof truncation === "string" ? truncation : "..."
		        return str.length > length ?
		                str.slice(0, length - truncation.length) + truncation :
		                String(str)
		    },
		    camelize: avalon.camelize,
		    date: date,
		    escape: avalon.escapeHtml,
		    sanitize: sanitize,
		    number: number,
		    currency: function (amount, symbol, fractionSize) {
		        return (symbol || "\uFFE5") +
		                number(amount,
		                        isFinite(fractionSize) ? fractionSize : 2)
		    }
		}, arrayFilters, eventFilters)


		module.exports = avalon

	/***/ },
	/* 9 */
	/***/ function(module, exports) {

		function number(number, decimals, point, thousands) {
		    //form http://phpjs.org/functions/number_format/
		    //number 必需，要格式化的数字
		    //decimals 可选，规定多少个小数位。
		    //point 可选，规定用作小数点的字符串（默认为 . ）。
		    //thousands 可选，规定用作千位分隔符的字符串（默认为 , ），如果设置了该参数，那么所有其他参数都是必需的。
		    number = (number + '')
		            .replace(/[^0-9+\-Ee.]/g, '')
		    var n = !isFinite(+number) ? 0 : +number,
		            prec = !isFinite(+decimals) ? 3 : Math.abs(decimals),
		            sep = thousands || ",",
		            dec = point || ".",
		            s = '',
		            toFixedFix = function (n, prec) {
		                var k = Math.pow(10, prec)
		                return '' + (Math.round(n * k) / k)
		                        .toFixed(prec)
		            }
		    // Fix for IE parseFloat(0.55).toFixed(0) = 0;
		    s = (prec ? toFixedFix(n, prec) : '' + Math.round(n))
		            .split('.')
		    if (s[0].length > 3) {
		        s[0] = s[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, sep)
		    }
		    if ((s[1] || '')
		            .length < prec) {
		        s[1] = s[1] || ''
		        s[1] += new Array(prec - s[1].length + 1)
		                .join('0')
		    }
		    return s.join(dec)
		}

		module.exports = number

		//处理 货币 http://openexchangerates.github.io/accounting.js/

	/***/ },
	/* 10 */
	/***/ function(module, exports) {

		var rscripts = /<script[^>]*>([\S\s]*?)<\/script\s*>/gim
		var ron = /\s+(on[^=\s]+)(?:=("[^"]*"|'[^']*'|[^\s>]+))?/g
		var ropen = /<\w+\b(?:(["'])[^"]*?(\1)|[^>])*>/ig
		var rsanitize = {
		    a: /\b(href)\=("javascript[^"]*"|'javascript[^']*')/ig,
		    img: /\b(src)\=("javascript[^"]*"|'javascript[^']*')/ig,
		    form: /\b(action)\=("javascript[^"]*"|'javascript[^']*')/ig
		}


		//https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
		//    <a href="javasc&NewLine;ript&colon;alert('XSS')">chrome</a> 
		//    <a href="data:text/html;base64, PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==">chrome</a>
		//    <a href="jav	ascript:alert('XSS');">IE67chrome</a>
		//    <a href="jav&#x09;ascript:alert('XSS');">IE67chrome</a>
		//    <a href="jav&#x0A;ascript:alert('XSS');">IE67chrome</a>
		module.exports = function sanitize(str) {
		    return str.replace(rscripts, "").replace(ropen, function (a, b) {
		        var match = a.toLowerCase().match(/<(\w+)\s/)
		        if (match) { //处理a标签的href属性，img标签的src属性，form标签的action属性
		            var reg = rsanitize[match[1]]
		            if (reg) {
		                a = a.replace(reg, function (s, name, value) {
		                    var quote = value.charAt(0)
		                    return name + "=" + quote + "javascript:void(0)" + quote// jshint ignore:line
		                })
		            }
		        }
		        return a.replace(ron, " ").replace(/\s+/g, " ") //移除onXXX事件
		    })
		}


	/***/ },
	/* 11 */
	/***/ function(module, exports) {

		/*
		 'yyyy': 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)
		 'yy': 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)
		 'y': 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)
		 'MMMM': Month in year (January-December)
		 'MMM': Month in year (Jan-Dec)
		 'MM': Month in year, padded (01-12)
		 'M': Month in year (1-12)
		 'dd': Day in month, padded (01-31)
		 'd': Day in month (1-31)
		 'EEEE': Day in Week,(Sunday-Saturday)
		 'EEE': Day in Week, (Sun-Sat)
		 'HH': Hour in day, padded (00-23)
		 'H': Hour in day (0-23)
		 'hh': Hour in am/pm, padded (01-12)
		 'h': Hour in am/pm, (1-12)
		 'mm': Minute in hour, padded (00-59)
		 'm': Minute in hour (0-59)
		 'ss': Second in minute, padded (00-59)
		 's': Second in minute (0-59)
		 'a': am/pm marker
		 'Z': 4 digit (+sign) representation of the timezone offset (-1200-+1200)
		 format string can also be one of the following predefined localizable formats:
		 
		 'medium': equivalent to 'MMM d, y h:mm:ss a' for en_US locale (e.g. Sep 3, 2010 12:05:08 pm)
		 'short': equivalent to 'M/d/yy h:mm a' for en_US locale (e.g. 9/3/10 12:05 pm)
		 'fullDate': equivalent to 'EEEE, MMMM d,y' for en_US locale (e.g. Friday, September 3, 2010)
		 'longDate': equivalent to 'MMMM d, y' for en_US locale (e.g. September 3, 2010
		 'mediumDate': equivalent to 'MMM d, y' for en_US locale (e.g. Sep 3, 2010)
		 'shortDate': equivalent to 'M/d/yy' for en_US locale (e.g. 9/3/10)
		 'mediumTime': equivalent to 'h:mm:ss a' for en_US locale (e.g. 12:05:08 pm)
		 'shortTime': equivalent to 'h:mm a' for en_US locale (e.g. 12:05 pm)
		 */

		function toInt(str) {
		    return parseInt(str, 10) || 0
		}

		function padNumber(num, digits, trim) {
		    var neg = ''
		    if (num < 0) {
		        neg = '-'
		        num = -num
		    }
		    num = '' + num
		    while (num.length < digits)
		        num = '0' + num
		    if (trim)
		        num = num.substr(num.length - digits)
		    return neg + num
		}

		function dateGetter(name, size, offset, trim) {
		    return function (date) {
		        var value = date["get" + name]()
		        if (offset > 0 || value > -offset)
		            value += offset
		        if (value === 0 && offset === -12) {
		            value = 12
		        }
		        return padNumber(value, size, trim)
		    }
		}

		function dateStrGetter(name, shortForm) {
		    return function (date, formats) {
		        var value = date["get" + name]()
		        var get = (shortForm ? ("SHORT" + name) : name).toUpperCase()
		        return formats[get][value]
		    }
		}

		function timeZoneGetter(date) {
		    var zone = -1 * date.getTimezoneOffset()
		    var paddedZone = (zone >= 0) ? "+" : ""
		    paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2)
		    return paddedZone
		}
		//取得上午下午

		function ampmGetter(date, formats) {
		    return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1]
		}
		var DATE_FORMATS = {
		    yyyy: dateGetter("FullYear", 4),
		    yy: dateGetter("FullYear", 2, 0, true),
		    y: dateGetter("FullYear", 1),
		    MMMM: dateStrGetter("Month"),
		    MMM: dateStrGetter("Month", true),
		    MM: dateGetter("Month", 2, 1),
		    M: dateGetter("Month", 1, 1),
		    dd: dateGetter("Date", 2),
		    d: dateGetter("Date", 1),
		    HH: dateGetter("Hours", 2),
		    H: dateGetter("Hours", 1),
		    hh: dateGetter("Hours", 2, -12),
		    h: dateGetter("Hours", 1, -12),
		    mm: dateGetter("Minutes", 2),
		    m: dateGetter("Minutes", 1),
		    ss: dateGetter("Seconds", 2),
		    s: dateGetter("Seconds", 1),
		    sss: dateGetter("Milliseconds", 3),
		    EEEE: dateStrGetter("Day"),
		    EEE: dateStrGetter("Day", true),
		    a: ampmGetter,
		    Z: timeZoneGetter
		}
		var rdateFormat = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/
		var raspnetjson = /^\/Date\((\d+)\)\/$/
		function dateFilter(date, format) {
		    var locate = dateFilter.locate,
		            text = "",
		            parts = [],
		            fn, match
		    format = format || "mediumDate"
		    format = locate[format] || format
		    if (typeof date === "string") {
		        if (/^\d+$/.test(date)) {
		            date = toInt(date)
		        } else if (raspnetjson.test(date)) {
		            date = +RegExp.$1
		        } else {
		            var trimDate = date.trim()
		            var dateArray = [0, 0, 0, 0, 0, 0, 0]
		            var oDate = new Date(0)
		            //取得年月日
		            trimDate = trimDate.replace(/^(\d+)\D(\d+)\D(\d+)/, function (_, a, b, c) {
		                var array = c.length === 4 ? [c, a, b] : [a, b, c]
		                dateArray[0] = toInt(array[0])     //年
		                dateArray[1] = toInt(array[1]) - 1 //月
		                dateArray[2] = toInt(array[2])     //日
		                return ""
		            })
		            var dateSetter = oDate.setFullYear
		            var timeSetter = oDate.setHours
		            trimDate = trimDate.replace(/[T\s](\d+):(\d+):?(\d+)?\.?(\d)?/, function (_, a, b, c, d) {
		                dateArray[3] = toInt(a) //小时
		                dateArray[4] = toInt(b) //分钟
		                dateArray[5] = toInt(c) //秒
		                if (d) {                //毫秒
		                    dateArray[6] = Math.round(parseFloat("0." + d) * 1000)
		                }
		                return ""
		            })
		            var tzHour = 0
		            var tzMin = 0
		            trimDate = trimDate.replace(/Z|([+-])(\d\d):?(\d\d)/, function (z, symbol, c, d) {
		                dateSetter = oDate.setUTCFullYear
		                timeSetter = oDate.setUTCHours
		                if (symbol) {
		                    tzHour = toInt(symbol + c)
		                    tzMin = toInt(symbol + d)
		                }
		                return ''
		            })

		            dateArray[3] -= tzHour
		            dateArray[4] -= tzMin
		            dateSetter.apply(oDate, dateArray.slice(0, 3))
		            timeSetter.apply(oDate, dateArray.slice(3))
		            date = oDate
		        }
		    }
		    if (typeof date === 'number') {
		        date = new Date(date)
		    }
		    if (avalon.type(date) !== 'date') {
		        return
		    }
		    while (format) {
		        match = rdateFormat.exec(format)
		        if (match) {
		            parts = parts.concat(match.slice(1))
		            format = parts.pop()
		        } else {
		            parts.push(format)
		            format = null
		        }
		    }
		    parts.forEach(function (value) {
		        fn = DATE_FORMATS[value]
		        text += fn ? fn(date, locate) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'")
		    })
		    return text
		}


		var locate = {
		    AMPMS: {
		        0: '上午',
		        1: '下午'
		    },
		    DAY: {
		        0: '星期日',
		        1: '星期一',
		        2: '星期二',
		        3: '星期三',
		        4: '星期四',
		        5: '星期五',
		        6: '星期六'
		    },
		    MONTH: {
		        0: '1月',
		        1: '2月',
		        2: '3月',
		        3: '4月',
		        4: '5月',
		        5: '6月',
		        6: '7月',
		        7: '8月',
		        8: '9月',
		        9: '10月',
		        10: '11月',
		        11: '12月'
		    },
		    SHORTDAY: {
		        '0': '周日',
		        '1': '周一',
		        '2': '周二',
		        '3': '周三',
		        '4': '周四',
		        '5': '周五',
		        '6': '周六'
		    },
		    fullDate: 'y年M月d日EEEE',
		    longDate: 'y年M月d日',
		    medium: 'yyyy-M-d H:mm:ss',
		    mediumDate: 'yyyy-M-d',
		    mediumTime: 'H:mm:ss',
		    'short': 'yy-M-d ah:mm',
		    shortDate: 'yy-M-d',
		    shortTime: 'ah:mm'
		}
		locate.SHORTMONTH = locate.MONTH
		dateFilter.locate = locate

		module.exports = dateFilter

	/***/ },
	/* 12 */
	/***/ function(module, exports) {

		
		function orderBy(array, criteria, reverse) {
		    var type = avalon.type(array)
		    if (type !== 'array' && type !== 'object')
		        throw 'orderBy只能处理对象或数组'
		    var order = (reverse && reverse < 0) ? -1 : 1

		    if (typeof criteria === 'string') {
		        var key = criteria
		        criteria = function (a) {
		            return a && a[key]
		        }
		    }
		    array = convertArray(array)
		    array.forEach(function (el) {
		        el.order = criteria(el.value, el.key)
		    })
		    array.sort(function (left, right) {
		        var a = left.order
		        var b = right.order
		        if (Number.isNaN(a) && Number.isNaN(b)) {
		            return 0
		        }
		        return a === b ? 0 : a > b ? order : -order
		    })
		    var isArray = type === 'array'
		    var target = isArray ? [] : {}
		    return recovery(target, array, function (el) {
		        if (isArray) {
		            target.push(el.value)
		        } else {
		            target[el.key] = el.value
		        }
		    })
		}

		function filterBy(array, search) {
		    var type = avalon.type(array)
		    if (type !== 'array' && type !== 'object')
		        throw 'filterBy只能处理对象或数组'
		    var args = avalon.slice(arguments, 2)
		    var stype = avalon.type(search)
		    if (stype === 'function') {
		        var criteria = search
		    } else if (stype === 'string' || stype === 'number') {
		        if (search === '') {
		            return array
		        } else {
		            var reg = new RegExp(avalon.escapeRegExp(search), 'i')
		            criteria = function (el) {
		                return reg.test(el)
		            }
		        }
		    } else {
		        return array
		    }

		    array = convertArray(array).filter(function (el, i) {
		        return !!criteria.apply(el, [el.value, i].concat(args))
		    })
		    var isArray = type === 'array'
		    var target = isArray ? [] : {}
		    return recovery(target, array, function (el) {
		        if (isArray) {
		            target.push(el.value)
		        } else {
		            target[el.key] = el.value
		        }
		    })
		}

		function selectBy(data, array, defaults) {
		    if (avalon.isObject(data) && !Array.isArray(data)) {
		        var target = []
		        return recovery(target, array, function (name) {
		            target.push(data.hasOwnProperty(name) ? data[name] : defaults ? defaults[name] : '')
		        })
		    } else {
		        return data
		    }
		}

		Number.isNaN = Number.isNaN || function (a) {
		    return a !== a
		}

		function limitBy(input, limit, begin) {
		    var type = avalon.type(input)
		    if (type !== 'array' && type !== 'object')
		        throw 'limitBy只能处理对象或数组'
		    //必须是数值
		    if (typeof limit !== 'number') {
		        return input
		    }
		    //不能为NaN
		    if (Number.isNaN(limit)) {
		        return input
		    }
		    //将目标转换为数组
		    if (type === 'object') {
		        input = convertArray(input)
		    }
		    var n = input.length
		    limit = Math.min(n, limit)
		    begin = typeof begin === 'number' ? begin : 0
		    if (begin < 0) {
		        begin = Math.max(0, n + begin)
		    }

		    var data = []
		    for (var i = begin; i < n; i++) {
		        data.push(input[i])
		        if (data.length === limit) {
		            break
		        }
		    }
		    var isArray = type === 'array'
		    if (isArray) {
		        return data
		    }
		    var target = {}
		    return recovery(target, data, function (el) {
		        target[el.key] = el.value
		    })
		}

		function recovery(ret, array, callback) {
		    for (var i = 0, n = array.length; i < n; i++) {
		        callback(array[i])
		    }
		    return ret
		}


		function convertArray(array) {
		    var ret = [], i = 0
		    avalon.each(array, function (key, value) {
		        ret[i++] = {
		            value: value,
		            key: key
		        }
		    })
		    return ret
		}

		module.exports = {
		    limitBy: limitBy,
		    orderBy: orderBy,
		    selectBy: selectBy,
		    filterBy: filterBy
		}

	/***/ },
	/* 13 */
	/***/ function(module, exports) {

		
		var eventFilters = {
		    stop: function (e) {
		        e.stopPropagation()
		        return e
		    },
		    prevent: function (e) {
		        e.preventDefault()
		        return e
		    }
		}
		var keyCode = {
		    esc: 27,
		    tab: 9,
		    enter: 13,
		    space: 32,
		    del: 46,
		    up: 38,
		    left: 37,
		    right: 39,
		    down: 40
		}

		avalon.each(keyCode, function (name, keyCode) {
		    eventFilters[name] = function (e) {
		        if (e.which !== keyCode) {
		            e.$return = true
		        }
		        return e
		    }
		})

		module.exports = eventFilters

	/***/ },
	/* 14 */,
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {

		var rexpr = avalon.config.rexpr
		var decode = __webpack_require__(16)
		function VText(text) {
		    if (typeof text === 'string') {
		        this.type = '#text'
		        this.nodeValue = text
		        this.skipContent = !rexpr.test(text)
		        this.nodeType = 3
		    } else {
		        for (var i in text) {
		            this[i] = text[i]
		        }
		    }
		}

		VText.prototype = {
		    constructor: VText,
		    toDOM: function () {
		       var v = decode(this.nodeValue)
		       return document.createTextNode(v)
		    },
		    toHTML: function () {
		        return this.nodeValue
		    }
		}

		module.exports = VText

	/***/ },
	/* 16 */
	/***/ function(module, exports) {

		/* 
		 * 对html实体进行转义
		 * https://github.com/substack/node-ent
		 * http://www.cnblogs.com/xdp-gacl/p/3722642.html
		 * http://www.stefankrause.net/js-frameworks-benchmark2/webdriver-java/table.html
		 */

		var rentities = /&[a-z0-9#]{2,10};/
		var temp = avalon.avalonDiv
		module.exports = function (str) {
		    if (rentities.test(str)) {
		        temp.innerHTML = str
		        return temp.innerText || temp.textContent
		    }
		    return str
		}

	/***/ },
	/* 17 */
	/***/ function(module, exports) {

		
		function VComment(text) {
		    if (typeof text === 'string') {
		        this.type = '#comment'
		        this.nodeValue = text
		        this.skipContent = true
		        this.nodeType = 8
		    } else {
		        for (var i in text) {
		            this[i] = text[i]
		        }
		    }
		}
		VComment.prototype = {
		    constructor: VComment,
		    toDOM: function () {
		        return document.createComment(this.nodeValue)
		    },
		    toHTML: function () {
		        return '<!--' + this.nodeValue + '-->'+(this.template||"")
		    }
		}

		module.exports = VComment

	/***/ },
	/* 18 */,
	/* 19 */,
	/* 20 */,
	/* 21 */,
	/* 22 */,
	/* 23 */
	/***/ function(module, exports) {

		var propMap = {//不规则的属性名映射
		    'accept-charset': 'acceptCharset',
		    'char': 'ch',
		    charoff: 'chOff',
		    'class': 'className',
		    'for': 'htmlFor',
		    'http-equiv': 'httpEquiv'
		}
		/*
		contenteditable不是布尔属性
		http://www.zhangxinxu.com/wordpress/2016/01/contenteditable-plaintext-only/
		contenteditable=''
		contenteditable='events'
		contenteditable='caret'
		contenteditable='plaintext-only'
		contenteditable='true'
		contenteditable='false'
		 */
		var bools = ['autofocus,autoplay,async,allowTransparency,checked,controls',
		    'declare,disabled,defer,defaultChecked,defaultSelected,',
		    'isMap,loop,multiple,noHref,noResize,noShade',
		    'open,readOnly,selected'
		].join(',')

		bools.replace(/\w+/g, function (name) {
		    propMap[name.toLowerCase()] = name
		})

		var anomaly = ['accessKey,bgColor,cellPadding,cellSpacing,codeBase,codeType,colSpan',
		    'dateTime,defaultValue,contentEditable,frameBorder,longDesc,maxLength,'+
		    'marginWidth,marginHeight,rowSpan,tabIndex,useMap,vSpace,valueType,vAlign'
		].join(',')

		anomaly.replace(/\w+/g, function (name) {
		    propMap[name.toLowerCase()] = name
		})

		module.exports = propMap


	/***/ },
	/* 24 */,
	/* 25 */,
	/* 26 */,
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {

		var Cache = __webpack_require__(28)

		var fixCloneNode = __webpack_require__(29)

		var rhtml = /<|&#?\w+;/
		var htmlCache = new Cache(128)
		var rxhtml = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig

		avalon.parseHTML = function (html) {
		    var fragment = avalon.avalonFragment.cloneNode(false)
		    //处理非字符串
		    if (typeof html !== 'string') {
		        return fragment
		    }
		    //处理非HTML字符串
		    if (!rhtml.test(html)) {
		        return document.createTextNode(html)
		    }

		    html = html.replace(rxhtml, '<$1></$2>').trim()
		    var hasCache = htmlCache.get(html)
		    if (hasCache) {
		        return fixCloneNode(hasCache)
		    }
		    var vnodes = avalon.lexer(html)
		    for (var i = 0, el; el = vnodes[i++]; ) {
		        fragment.appendChild(avalon.vdomAdaptor(el, 'toDOM'))
		    }
		    if (html.length < 1024) {
		        htmlCache.put(html, fixCloneNode(fragment))
		    }
		    return fragment
		}

		avalon.innerHTML = function (node, html) {
		    if (!avalon.modern && (!rcreate.test(html) && !rnest.test(html))) {
		        try {
		            node.innerHTML = html
		            return
		        } catch (e) {
		        }
		    }
		    var parsed = this.parseHTML(html)
		    this.clearHTML(node).appendChild(parsed)
		}

		var reunescapeHTML = /&(?:amp|lt|gt|quot|#39|#96);/g
		var htmlUnescapes = {
		    '&amp;': '&',
		    '&lt;': '<',
		    '&gt;': '>',
		    '&quot;': '"',
		    '&#39;': "'",
		    '&#96;': '`'
		}
		avalon.unescapeHTML = function (string) {
		    var str = '' + string
		    return str.replace(reunescapeHTML, function (c) {
		        return htmlUnescapes[c]
		    })
		}

		var rescapeHTML = /["'&<>]/
		//https://github.com/nthtran/vdom-to-html
		//将字符串经过 str 转义得到适合在页面中显示的内容, 例如替换 < 为 &lt 
		avalon.escapeHTML = function (string) {
		    var str = '' + string
		    var match = rescapeHTML.exec(str)

		    if (!match) {
		        return str
		    }

		    var escape
		    var html = ''
		    var index = 0
		    var lastIndex = 0

		    for (index = match.index; index < str.length; index++) {
		        switch (str.charCodeAt(index)) {
		            case 34: // "
		                escape = '&quot;'
		                break
		            case 38: // &
		                escape = '&amp;'
		                break
		            case 39: // '
		                escape = '&#39;'
		                break
		            case 60: // <
		                escape = '&lt;'
		                break
		            case 62: // >
		                escape = '&gt;'
		                break
		            default:
		                continue
		        }

		        if (lastIndex !== index) {
		            html += str.substring(lastIndex, index)
		        }

		        lastIndex = index + 1
		        html += escape
		    }

		    return lastIndex !== index
		            ? html + str.substring(lastIndex, index)
		            : html
		}

		avalon.clearHTML = function (node) {
		    node.textContent = ''
		    while (node.lastChild) {
		        node.removeChild(node.lastChild)
		    }
		    return node
		}


	/***/ },
	/* 28 */
	/***/ function(module, exports) {

		// https://github.com/rsms/js-lru
		function LRU(maxLength) {
		    this.size = 0
		    this.limit = maxLength
		    this.head = this.tail = void 0
		    this._keymap = {}
		}

		var p = LRU.prototype

		p.put = function (key, value) {
		    var entry = {
		        key: key,
		        value: value
		    }
		    this._keymap[key] = entry
		    if (this.tail) {
		        this.tail.newer = entry
		        entry.older = this.tail
		    } else {
		        this.head = entry
		    }
		    this.tail = entry
		    if (this.size === this.limit) {
		        this.shift()
		    } else {
		        this.size++
		    }
		    return value
		}

		p.shift = function () {
		    var entry = this.head
		    if (entry) {
		        this.head = this.head.newer
		        this.head.older =
		                entry.newer =
		                entry.older =
		                this._keymap[entry.key] = void 0
		        delete this._keymap[entry.key] //#1029
		    }
		}
		p.get = function (key) {
		    var entry = this._keymap[key]
		    if (entry === void 0)
		        return
		    if (entry === this.tail) {
		        return  entry.value
		    }
		    // HEAD--------------TAIL
		    //   <.older   .newer>
		    //  <--- add direction --
		    //   A  B  C  <D>  E
		    if (entry.newer) {
		        if (entry === this.head) {
		            this.head = entry.newer
		        }
		        entry.newer.older = entry.older // C <-- E.
		    }
		    if (entry.older) {
		        entry.older.newer = entry.newer // C. --> E
		    }
		    entry.newer = void 0 // D --x
		    entry.older = this.tail // D. --> E
		    if (this.tail) {
		        this.tail.newer = entry // E. <-- D
		    }
		    this.tail = entry
		    return entry.value
		}

		module.exports = LRU


	/***/ },
	/* 29 */
	/***/ function(module, exports) {

		var rcheckedType = /radio|checkbox/

		function fix(dest, src) {
		    if (dest.nodeType !== 1) {
		        return
		    }
		    var nodeName = dest.nodeName.toLowerCase()
		    if (nodeName === 'object') {
		        if (dest.parentNode) {
		            dest.outerHTML = src.outerHTML
		        }

		    } else if (nodeName === 'input' && rcheckedType.test(src.type)) {

		        dest.defaultChecked = dest.checked = src.checked

		        if (dest.value !== src.value) {
		            dest.value = src.value
		        }

		    } else if (nodeName === 'option') {
		        dest.defaultSelected = dest.selected = src.defaultSelected
		    } else if (nodeName === 'input' || nodeName === 'textarea') {
		        dest.defaultValue = src.defaultValue
		    }
		}


		function getAll(context) {
		    return typeof context.getElementsByTagName !== "undefined" ?
		            context.getElementsByTagName("*") :
		            typeof context.querySelectorAll !== "undefined" ?
		            context.querySelectorAll("*") : []
		}

		function fixCloneNode(src) {
		    var target = src.cloneNode(true)
		    if (avalon.modern)
		        return target
		    var t = getAll(target)
		    var s = getAll(src)
		    avalon.each(s, function (i) {
		        fix(t[i], s[i])
		    })
		    return target
		}

		module.exports = fixCloneNode

	/***/ },
	/* 30 */,
	/* 31 */
	/***/ function(module, exports) {

		//http://www.feiesoft.com/html/events.html
		//http://segmentfault.com/q/1010000000687977/a-1020000000688757
		module.exports = {
		    click: true,
		    dblclick: true,
		    keydown: true,
		    keypress: true,
		    keyup: true,
		    mousedown: true,
		    mousemove: true,
		    mouseup: true,
		    mouseover: true,
		    mouseout: true,
		    wheel: true,
		    mousewheel: true,
		    input: true,
		    change: true,
		    beforeinput: true,
		    compositionstart: true,
		    compositionupdate: true,
		    compositionend: true,
		    select: true,
		    //http://blog.csdn.net/lee_magnum/article/details/17761441
		    cut: true,
		    copy: true,
		    paste: true,
		    beforecut: true,
		    beforecopy: true,
		    beforepaste: true,
		    focusin: true,
		    focusout: true,
		    DOMFocusIn: true,
		    DOMFocusOut: true,
		    DOMActivate: true,
		    dragend: true,
		    datasetchanged: true
		}

	/***/ },
	/* 32 */,
	/* 33 */
	/***/ function(module, exports) {

		var onceWarn = true //只警告一次
		function scan(nodes) {
		    var getHTML = avalon.scan.htmlfy
		    for (var i = 0, elem; elem = nodes[i++]; ) {
		        if (elem.nodeType === 1) {
		            var $id = getController(elem)

		            var vm = avalon.vmodels[$id]
		            if (vm && !vm.$element) {
		                avalon(elem).removeClass('ms-controller')
		                vm.$element = elem
		             
		                //IE6-8下元素的outerHTML前面会有空白
		                var text = getHTML(elem)//elem.outerHTML
		  
		                var now = new Date()
		                elem.vtree = avalon.speedUp(avalon.lexer(text)) 
		             
		                var now2 = new Date()
		                onceWarn && avalon.log('构建虚拟DOM耗时', now2 - now, 'ms')
		                vm.$render = avalon.render(elem.vtree)
		                avalon.scopes[vm.$id] = {
		                    vmodel: vm,
		                    local: {},
		                    isTemp: true
		                }
		                var now3 = new Date()
		                onceWarn && avalon.log('构建当前vm的$render方法耗时 ', now3 - now2, 'ms\n',
		                        '如果此时间太长,达100ms以上\n',
		                        '建议将当前ms-controller拆分成多个ms-controller,减少每个vm管辖的区域')
		                avalon.rerenderStart = now3
		                onceWarn = false
		                avalon.batch($id)

		            } else if (!$id) {
		                scan(elem.childNodes)
		            }
		        }
		    }
		}

		module.exports = avalon.scan = function (a) {
		    if (!a || !a.nodeType) {
		        avalon.warn('[avalon.scan] first argument must be element , documentFragment, or document')
		        return
		    }
		    scan([a])
		}

		function getController(a) {
		    return a.getAttribute('ms-controller') || 
		            a.getAttribute(':controller') 
		}

	/***/ },
	/* 34 */,
	/* 35 */,
	/* 36 */
	/***/ function(module, exports, __webpack_require__) {

		// 抽离出来公用
		var update = __webpack_require__(37)

		avalon.directive('important', {
		    priority: 1,
		    parse: function (copy, src, binding) {
		        var quoted = avalon.quote(binding.expr)
		        copy[binding.name] = quoted
		        copy.local = '{}'
		        copy.vmodel = '(function(){ return __vmodel__ = avalon.vmodels[' + quoted + ']})()'
		        src.$prepend = ['(function(__vmodel__){',
		            'var important = avalon.scopes[' + quoted + ']',
		            'if(important){avalon.log("不进入"+' + quoted + ');return }',
		        ].join('\n') + '\n'
		        src.$append = '\n})();'
		    },
		    diff: function (copy, src, name) {
		        if (copy === src || src.vmodel !== copy.vmodel) {
		            src['ms-controller'] = copy[name]
		            src.local = copy.local
		            src.vmodel = copy.vmodel
		            update(src, this.update)
		        }
		    },
		    update: function (dom, vdom, parent) {
		        avalon.directives.controller.update(dom, vdom, parent, 'important')
		    }
		})


	/***/ },
	/* 37 */
	/***/ function(module, exports) {

		module.exports = function (vdom, update, hookName) {
		    if (hookName) {
		        vdom.afterChange = vdom.afterChange || []
		        avalon.Array.ensure(vdom.afterChange, update)
		    } else {
		        var dom = vdom.dom
		        update(vdom.dom, vdom, dom && dom.parentNode)
		    }
		}


	/***/ },
	/* 38 */
	/***/ function(module, exports, __webpack_require__) {

		// 抽离出来公用
		var update = __webpack_require__(37)
		var reconcile = __webpack_require__(39)

		var cache = {}
		avalon.mediatorFactoryCache = function (__vmodel__, __present__) {
		    var a = __vmodel__.$hashcode
		    var b = __present__.$hashcode
		    var id = a + b
		    if (cache[id]) {
		        return cache[id]
		    }
		    var c = avalon.mediatorFactory(__vmodel__, __present__)
		    return  cache[id] = c
		}
		avalon.directive('controller', {
		    priority: 2,
		    parse: function (copy, src, binding) {
		        var quoted = avalon.quote(binding.expr)
		        copy[binding.name] = quoted
		        copy.local = '__local__'
		        copy.vmodel = [
		            '(function(){',
		            'var vm = avalon.vmodels[' + quoted + ']',
		            'if(vm && __vmodel__&& vm !== __vmodel__){',
		            'return __vmodel__ = avalon.mediatorFactoryCache(__vmodel__, vm)',
		            '}else if(vm){',
		            'return __vmodel__ = vm',
		            '}',
		            '})()'
		        ].join('\n')

		        src.$prepend = '(function(__vmodel__){'
		        src.$append = '\n})(__vmodel__);'
		    },
		    diff: function (copy, src, name) {
		        if (copy === src || src[name] !== copy[name]) {
		            src[name] = copy[name]
		            src.local = copy.local
		            src.vmodel = copy.vmodel
		            update(src, this.update)
		        }
		    },
		    update: function (dom, vdom, parent, important) {
		        var vmodel = vdom.vmodel
		        var local = vdom.local
		        var id = vdom['ms-controller']
		        var scope = avalon.scopes[id]
		        if (scope) {
		            return
		        }
		        delete vdom.vmodel
		        delete vdom.local
		        var top = avalon.vmodels[id]
		        if (vmodel.$element && vmodel.$element.vtree[0] === vdom) {
		            var render = vmodel.$render
		        } else {
		            render = avalon.render([vdom], local)
		        }
		        vmodel.$render = render
		        vmodel.$element = dom
		      
		        reconcile([dom], [vdom], parent)
		        dom.vtree = [vdom]
		        if (top !== vmodel) {
		            top.$render = top.$render || render
		            top.$element = top.$element || dom
		        }
		        var needFire = important ? vmodel : top
		        var scope = avalon.scopes[id] = {
		            vmodel: vmodel,
		            local: local
		        }
		        update(vdom, function () {
		            var events = needFire.$events["onReady"]
		            if (events) {
		                needFire.$fire('onReady')
		                delete needFire.$events.onReady
		            }
		            scope.isMount = true
		        }, 'afterChange')

		    }
		})


	/***/ },
	/* 39 */
	/***/ function(module, exports) {

		/*
		 * 
		 节点对齐算法
		 元素节点是1＋其类型
		 文本节点是3＋其是否能移除
		 注释节点是8＋其内容
		 发现不一样，就对真实DOM树添加或删除
		 添加的是 ms-for,ms-for-end占位的注释节点
		 删除的是多余的空白文本节点,与IE6-8私下添加的奇怪节点
		 */
		var rforHolder = /^ms\-for/
		var rwhiteRetain = /[\S\xA0]/
		var plainTag = avalon.oneObject('script,style,xmp,template,noscript,textarea')

		function reconcile(nodes, vnodes, parent) {
		    //遍平化虚拟DOM树
		    vnodes = flatten(vnodes)
		    var map = {}
		    var vn = vnodes.length
		    if (vn === 0)
		        return

		    vnodes.forEach(function (el, index) {
		        map[index] = getType(el)
		    })
		    var newNodes = [], change = false, el, i = 0
		    var breakLoop = 0
		    while (true) {
		        el = nodes[i++]
		        if (breakLoop++ > 5000) {
		            break
		        }
		        var vtype = el && getType(el)
		        var v = newNodes.length, check
		        if (map[v] === vtype) {
		            if (check && el.nodeType === 1 && (el.getAttribute(':for')||el.getAttribute('ms-for'))) {
		                check = false
		                continue
		            }
		            newNodes.push(el)
		            var vnode = vnodes[v]

		            if (vnode.dynamic) {
		                vnode.dom = el
		            }

		            if (el.nodeType === 1 && !vnode.isVoidTag && !plainTag[vnode.type]) {
		                if (el.type === 'select-one') {
		                    //在chrome与firefox下删掉select中的空白节点，会影响到selectedIndex
		                    var fixIndex = el.selectedIndex
		                }
		                reconcile(el.childNodes, vnode.children, el)
		                if (el.type === 'select-one') {
		                    el.selectedIndex = fixIndex
		                }
		            }
		        } else {
		            change = true
		            if (map[v] === '8true') {
		                var vv = vnodes[v]
		                var nn = document.createComment(vv.nodeValue)
		                vv.dom = nn
		                newNodes.push(nn)
		                if (vv.dynamic === 'for') {
		                    check = true
		                }
		                i = Math.max(0, --i)
		            }
		        }
		        if (newNodes.length === vn) {
		            break
		        }
		    }
		    if (change) {
		        var f = document.createDocumentFragment(), i = 0
		        while (el = newNodes[i++]) {
		            f.appendChild(el)
		        }
		        while (parent.firstChild) {
		            parent.removeChild(parent.firstChild)
		        }
		        parent.appendChild(f)
		    }
		}

		module.exports = reconcile


		function getType(node) {
		    switch (node.nodeType) {
		        case 3:
		            return '3' + rwhiteRetain.test(node.nodeValue)
		        case 1:
		            return '1' + (node.nodeName || node.type).toLowerCase()
		        case 8:
		            return '8' + rforHolder.test(node.nodeValue)
		    }
		}

		function flatten(nodes) {
		    var arr = []
		    for (var i = 0, el; el = nodes[i]; i++) {
		        if (Array.isArray(el)) {
		            arr = arr.concat(flatten(el))
		        } else {
		            arr.push(el)
		        }
		    }
		    return arr
		}



	/***/ },
	/* 40 */,
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {

		
		var update = __webpack_require__(37)

		avalon.directive('css', {
		    diff: function (copy, src, name) {
		        var a = copy[name]
		        var p = src[name]
		        if (Object(a) === a) {
		            a = a.$model || a//安全的遍历VBscript
		            if (Array.isArray(a)) {//转换成对象
		                a = avalon.mix.apply({}, a)
		            }
		            if (copy === src || typeof p !== 'object') {//如果一开始为空
		                src.changeStyle = src[name] = a
		            } else {
		                var patch = {}
		                var hasChange = false
		                for (var i in a) {//diff差异点
		                    if (a[i] !== p[i]) {
		                        hasChange = true
		                        patch[i] = a[i]
		                    }
		                }
		                if (hasChange) {
		                    src[name] = a
		                    src.changeStyle = patch
		                }
		            }
		            if (src.changeStyle) {
		                update(src, this.update)
		            }
		        }
		        delete copy[name]//释放内存
		    },
		    update: function (dom, vdom) {
		        var change = vdom.changeStyle
		        var wrap = avalon(dom)
		        for (var name in change) {
		            wrap.css(name, change[name])
		        }
		        delete vdom.changeStyle
		    }
		})


	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {

		var update = __webpack_require__(37)

		var none = 'none'
		function parseDisplay(elem, val) {
		    //用于取得此类标签的默认display值
		    var doc = elem.ownerDocument
		    var nodeName = elem.nodeName
		    var key = '_' + nodeName
		    if (!parseDisplay[key]) {
		        var temp = doc.body.appendChild(doc.createElement(nodeName))
		        if (avalon.modern) {
		            val = getComputedStyle(temp, null).display
		        } else {
		            val = temp.currentStyle.display
		        }
		        doc.body.removeChild(temp)
		        if (val === none) {
		            val = 'block'
		        }
		        parseDisplay[key] = val
		    }
		    return parseDisplay[key]
		}

		avalon.parseDisplay = parseDisplay

		avalon.directive('visible', {
		    diff: function (copy, src, name) {
		        var c = !!copy[name]
		        if (copy === src || c !== src[name]) {
		            src[name] = c
		            update(src, this.update )
		        }
		    },
		    update: function (dom, vdom) { 
		        if(!dom || dom.nodeType !== 1){
		            return
		        }
		        var show = vdom['ms-visible']
		        var display = dom.style.display
		        var value
		        if (show) {
		            if (display === none) {
		                value = vdom.displayValue
		                if (!value) {
		                    dom.style.display = ''
		                }
		            }
		            if (dom.style.display === '' && avalon(dom).css('display') === none &&
		                    // fix firefox BUG,必须挂到页面上
		                    avalon.contains(dom.ownerDocument, dom)) {

		                value = parseDisplay(dom)
		            }
		        } else {
		            if (display !== none) {
		                value = none
		                vdom.displayValue = display
		            }
		        }
		        function cb(){
		           if (value !== void 0) {
		              dom.style.display = value
		           }
		        }
		        avalon.applyEffect(dom, vdom, {
		            hook: show ? 'onEnterDone': 'onLeaveDone',
		            cb: cb
		        })
		    }
		})



	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {

		var update = __webpack_require__(37)

		avalon.directive('expr', {
		    parse: avalon.noop,
		    diff: function (copy, src) {
		        var copyValue = copy.nodeValue + ''
		        if (copy === src || copyValue !== src.nodeValue) {
		            src.nodeValue = copyValue
		            update(src, this.update)
		        }
		    },
		    update: function (dom, vdom) {
		        if (dom) {
		            dom.nodeValue = vdom.nodeValue
		        } else {
		            avalon.warn('[', vdom.nodeValue, ']找不到对应的文本节点赋值')
		        }
		    }
		})




	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {

		//此指令实际上不会操作DOM,交由expr指令处理
		var update = __webpack_require__(37)

		avalon.directive('text', {
		    parse: function (copy, src, binding) {
		        copy[binding.name] = 1
		        src.children = []
		        copy.children = '[{\nnodeType:3,\ntype:"#text",\ndynamic:true,' +
		                '\nnodeValue:avalon.parsers.string(' +
		                avalon.parseExpr(binding) + ')}]'
		    },
		    diff: function (copy, src) {
		        if(!src.children.length){
		           update(src, this.update)
		        }
		    },
		    update: function(dom, vdom){
		        if (dom && !vdom.isVoidTag ) {
		            var parent = dom
		            while (parent.firstChild) {
		                parent.removeChild(parent.firstChild)
		            }
		            var dom = document.createTextNode('x')
		            parent.appendChild(dom)
		            var a = {nodeType: 3, type:'#text', dom: dom}
		            vdom.children.push(a)
		        }
		    }
		})

	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {

		var update = __webpack_require__(37)
		var reconcile = __webpack_require__(39)

		avalon.directive('html', {
		    parse: function (copy, src, binding) {
		        if (!src.isVoidTag) {
		            //将渲染函数的某一部分存起来,渲在c方法中转换为函数
		            copy[binding.name] = avalon.parseExpr(binding)
		            copy.vmodel = '__vmodel__'
		            copy.local = '__local__'
		        } else {
		            copy.children = '[]'
		        }
		    },
		    diff: function (copy, src, name) {
		        var copyValue = copy[name] + ''
		        if (copy === src || !src.render || copyValue !== src[name]) {
		            src[name] = copyValue
		            var oldTree = avalon.speedUp(avalon.lexer(copyValue))
		            src.children = oldTree
		            var render = avalon.render(oldTree, copy.local)
		            src.render = render
		            var newTree = render(copy.vmodel, copy.local)
		            copy.children = newTree
		            update(src, this.update)
		        } else {
		            var newTree = src.render(copy.vmodel, copy.local)
		          copy.children = newTree
		        }
		    },
		    update: function (dom, vdom, parent) {
		        avalon.clearHTML(dom)
		        var f = avalon.vdomAdaptor(vdom.children)
		        reconcile(f.childNodes, vdom.children, f)
		        dom.appendChild(f)
		    }
		})


	/***/ },
	/* 46 */
	/***/ function(module, exports, __webpack_require__) {

		//根据VM的属性值或表达式的值切换类名，ms-class='xxx yyy zzz:flag'
		//http://www.cnblogs.com/rubylouvre/archive/2012/12/17/2818540.html
		var markID = __webpack_require__(6).getLongID
		var update = __webpack_require__(37)

		function classNames() {
		    var classes = []
		    for (var i = 0; i < arguments.length; i++) {
		        var arg = arguments[i]
		        var argType = typeof arg
		        if (argType === 'string' || argType === 'number' || arg === true) {
		            classes.push(arg)
		        } else if (Array.isArray(arg)) {
		            classes.push(classNames.apply(null, arg))
		        } else if (argType === 'object') {
		            for (var key in arg) {
		                if (arg.hasOwnProperty(key) && arg[key]) {
		                    classes.push(key)
		                }
		            }
		        }
		    }

		    return classes.join(' ')
		}



		var directives = avalon.directives
		avalon.directive('class', {
		    diff: function (copy, src, name) {
		        var type = name.slice(3)
		        var copyValue = copy[name]
		        var srcValue = src[name] || ''
		        var classEvent = src.classEvent || {}
		        if (type === 'hover') {//在移出移入时切换类名
		            classEvent.mouseenter = activateClass
		            classEvent.mouseleave = abandonClass
		        } else if (type === 'active') {//在获得焦点时切换类名
		            src.props.tabindex = copy.props.tabindex || -1
		            classEvent.tabIndex = src.props.tabindex
		            classEvent.mousedown = activateClass
		            classEvent.mouseup = abandonClass
		            classEvent.mouseleave = abandonClass
		        }
		        src.classEvent = classEvent

		        var className = classNames(copyValue)
		       
		        if (copy === src || srcValue !== className) {
		            src[name] = className
		            src['change-' + type] = className
		            update(src, this.update, type)
		        }
		    },
		    update: function (dom, vdom) {
		        if (!dom || dom.nodeType !== 1)
		            return
		        var classEvent = vdom.classEvent
		        if (classEvent) {
		            for (var i in classEvent) {
		                if (i === 'tabIndex') {
		                    dom[i] = classEvent[i]
		                } else {
		                    avalon.bind(dom, i, classEvent[i])
		                }
		            }
		            vdom.classEvent = {}
		        }
		        var names = ['class', 'hover', 'active']
		        names.forEach(function (type) {
		            var name = 'change-' + type
		            var value = vdom[name]
		            if (value === void 0)
		                return
		            if (type === 'class') {
		                dom && setClass(dom, vdom)
		            } else {
		                var oldType = dom.getAttribute('change-' + type)
		                if (oldType) {
		                    avalon(dom).removeClass(oldType)
		                }
		                dom.setAttribute(name, value)
		            }
		        })
		    }
		})

		directives.active = directives.hover = directives['class']


		var classMap = {
		    mouseenter: 'change-hover',
		    mouseleave: 'change-hover',
		    mousedown: 'change-active',
		    mouseup: 'change-active'
		}

		function activateClass(e) {
		    var elem = e.target
		    avalon(elem).addClass(elem.getAttribute(classMap[e.type]) || '')
		}

		function abandonClass(e) {
		    var elem = e.target
		    var name = classMap[e.type]
		    avalon(elem).removeClass(elem.getAttribute(name) || '')
		    if (name !== 'change-active') {
		        avalon(elem).removeClass(elem.getAttribute('change-active') || '')
		    }
		}

		function setClass(dom, vdom) {
		    var old = dom.getAttribute('old-change-class')
		    var neo = vdom['ms-class']
		    if (old !== neo) {
		        avalon(dom).removeClass(old).addClass(neo)
		        dom.setAttribute('old-change-class', neo)
		    }

		}

		markID(activateClass)
		markID(abandonClass)




	/***/ },
	/* 47 */
	/***/ function(module, exports, __webpack_require__) {

		var Cache = __webpack_require__(28)
		var eventCache = new Cache(128)
		var update = __webpack_require__(37)
		var markID = __webpack_require__(6).getLongID

		var rfilters = /\|.+/g
		//Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes
		// The assumption is that future DOM event attribute names will begin with
		// 'on' and be composed of only English letters.
		var rfilters = /\|.+/g
		var rvar = /((?:\@|\$|\#\#)?\w+)/g
		var rstring = /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/g

		//基于事件代理的高性能事件绑定
		avalon.directive('on', {
		    priority: 3000,
		    parse: function (copy, src, binding) {
		        var underline = binding.name.replace('ms-on-', 'e').replace('-', '_')
		        var uuid = underline + '_' + binding.expr.
		                replace(/\s/g, '').
		                replace(/[^$a-z]/ig, function (e) {
		                    return e.charCodeAt(0)
		                })

		        var quoted = avalon.quote(uuid)
		        var fn = '(function(){\n' +
		                'var fn610 = ' +
		                avalon.parseExpr(binding, 'on') +
		                '\nfn610.uuid =' + quoted + ';\nreturn fn610})()'
		        copy.vmodel = '__vmodel__'
		        copy.local = '__local__'
		        copy[binding.name] = fn

		    },
		    diff: function (copy, src, name) {
		        var fn = copy[name]
		        var uuid = fn.uuid
		        var type = uuid.split('_').shift()
		        var search = type.slice(1) + ':' + uuid
		        var srcFn = src[name]
		        var hasChange = false
		        var init = copy === src
		        if (init || !srcFn || srcFn.uuid !== uuid) {
		            src[name] = fn
		            src.addEvents = src.addEvents || {}
		            src.addEvents[search] = fn
		            avalon.eventListeners.uuid = fn
		            hasChange = true
		        }
		        if (diffObj(src.local|| {}, copy.local)) {
		            hasChange = true
		        }
		        if (hasChange) {
		            src.local = copy.local
		            src.vmodel = copy.vmodel
		            update(src, this.update)
		        }
		    },
		    update: function (dom, vdom) {
		        if (!dom || dom.nodeType > 1) //在循环绑定中，这里为null
		            return
		        var key, type, listener
		        dom._ms_context_ = vdom.vmodel
		        dom._ms_local = vdom.local
		        for (key in vdom.addEvents) {
		            type = key.split(':').shift()
		            listener = vdom.addEvents[key]
		            avalon.bind(dom, type, listener)
		        }
		        delete vdom.addEvents
		    }
		})

		function diffObj(a, b) {
		    for (var i in a) {//diff差异点
		        if (a[i] !== b[i]) {
		            return true
		        }
		    }
		    return false
		}

	/***/ },
	/* 48 */,
	/* 49 */
	/***/ function(module, exports, __webpack_require__) {

		
		var Cache = __webpack_require__(28)
		//缓存求值函数，以便多次利用
		module.exports = new Cache(512)


	/***/ },
	/* 50 */
	/***/ function(module, exports) {

		var keyMap = avalon.oneObject("break,case,catch,continue,debugger,default,delete,do,else,false," +
		        "finally,for,function,if,in,instanceof,new,null,return,switch,this," +
		        "throw,true,try,typeof,var,void,while,with," + /* 关键字*/
		        "abstract,boolean,byte,char,class,const,double,enum,export,extends," +
		        "final,float,goto,implements,import,int,interface,long,native," +
		        "package,private,protected,public,short,static,super,synchronized," +
		        "throws,transient,volatile")
		avalon.keyMap = keyMap
		var quoted = {
		    type: 1,
		    template: 1,
		    order: 1,
		    nodeValue: 1,
		    dynamic: 1,
		    signature: 1,
		    wid: 1
		}

		var rneedQuote = /[W-]/
		var quote = avalon.quote
		function fixKey(k) {
		    return (rneedQuote.test(k) || keyMap[k]) ? quote(k) : k
		}

		function stringify(obj) {
		    var arr1 = []
		//字符不用东西包起来就变成变量
		    for (var i in obj) {
		        if (i === 'props') {
		            var arr2 = []
		            for (var k in obj.props) {
		                var kv = obj.props[k]
		                if (typeof kv === 'string') {
		                    kv = quote(kv)
		                }
		                arr2.push(fixKey(k) + ': ' + kv)
		            }
		            arr1.push('props: {' + arr2.join(',\n') + '}')
		        } else if (obj.hasOwnProperty(i) && i !== 'dom') {
		            var v = obj[i]
		            if (typeof v === 'string') {
		                v = quoted[i] ? quote(v) : v
		            }
		            arr1.push(fixKey(i) + ':' + v)
		        }
		    }
		    return '{\n' + arr1.join(',\n') + '}'
		}

		module.exports = stringify


	/***/ },
	/* 51 */,
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {

		var updateModelMethods = __webpack_require__(53)

		function updateModelHandle(e) {
		    var elem = this
		    var field = this.__ms_duplex__
		    if (elem.composing || field.parse(elem.value) === field.lastViewValue){
		        //防止onpropertychange引发爆栈
		        return
		    }
		   if (elem.caret) {
		        try {
		            var pos = field.getCaret(elem)
		            field.pos = pos
		        } catch (e) {
		            avalon.warn('fixCaret error', e)
		        }
		    }
		    if (field.debounceTime > 4) {
		        var timestamp = new Date()
		        var left = timestamp - field.time || 0
		        field.time = timestamp
		        if (left >= field.debounceTime) {
		            updateModelMethods[field.type].call(field)
		        } else {
		            clearTimeout(field.debounceID)
		            field.debounceID = setTimeout(function () {
		                updateModelMethods[field.type].call(field)
		            }, left)
		        }
		    } else {
		        updateModelMethods[field.type].call(field)
		    }
		}

		module.exports = updateModelHandle

	/***/ },
	/* 53 */
	/***/ function(module, exports) {

		var updateModelMethods = {
		    input: function (prop) {//处理单个value值处理
		        var data = this
		        prop = prop || 'value'
		        var dom = data.dom
		        var rawValue = dom[prop]
		        var parsedValue = data.parse(rawValue)
		        var formatedValue = data.format(data.vmodel, parsedValue)
		        data.lastViewValue = formatedValue
		        //有时候parse后一致,vm不会改变,但input里面的值
		        if (parsedValue !== data.modelValue) {
		            data.set(data.vmodel, parsedValue)
		            callback(data)
		        }
		       
		        dom[prop] = formatedValue
		      
		        var pos = data.pos
		        if (dom.caret ) {
		            data.setCaret(dom, pos)
		         }
		        //vm.aaa = '1234567890'
		        //处理 <input ms-duplex='@aaa|limitBy(8)'/>{{@aaa}} 这种格式化同步不一致的情况 

		    },
		    radio: function () {
		        var data = this
		        if (data.isChecked) {
		            var val = !data.modelValue
		            data.set(data.vmodel, val)
		            callback(data)
		        } else {
		            updateModelMethods.input.call(data)
		            data.lastViewValue = NaN
		        }
		    },
		    checkbox: function () {
		        var data = this
		        var array = data.modelValue
		        if (!Array.isArray(array)) {
		            avalon.warn('ms-duplex应用于checkbox上要对应一个数组')
		            array = [array]
		        }
		        var method = data.dom.checked ? 'ensure' : 'remove'
		        
		        if (array[method]) {
		            var val = data.parse(data.dom.value)
		            array[method](val)
		            callback(data)
		        }

		    },
		    select: function () {
		        var data = this
		        var val = avalon(data.dom).val() //字符串或字符串数组
		        if (val + '' !== this.modelValue + '') {
		            if (Array.isArray(val)) { //转换布尔数组或其他
		                val = val.map(function (v) {
		                    return data.parse(v)
		                })
		            } else {
		                val = data.parse(val)
		            }
		            data.set(data.vmodel, val)
		            callback(data)
		        }
		    },
		    contenteditable: function () {
		        updateModelMethods.input.call(this, 'innerHTML')
		    }
		}

		function callback(data) {
		    if (data.callback) {
		        data.callback.call(data.vmodel, {
		            type: 'changed',
		            target: data.dom
		        })
		    }
		}



		module.exports = updateModelMethods


	/***/ },
	/* 54 */
	/***/ function(module, exports) {

		var valueHijack = false
		try { //#272 IE9-IE11, firefox
		    var setters = {}
		    var aproto = HTMLInputElement.prototype
		    var bproto = HTMLTextAreaElement.prototype
		    function newSetter(value) { // jshint ignore:line
		        setters[this.tagName].call(this, value)
		        if (!this.caret && this.__ms_duplex__) {
		            this.__ms_duplex__.update.call(this)
		        }
		    }
		    var inputProto = HTMLInputElement.prototype
		    Object.getOwnPropertyNames(inputProto) //故意引发IE6-8等浏览器报错
		    setters['INPUT'] = Object.getOwnPropertyDescriptor(aproto, 'value').set

		    Object.defineProperty(aproto, 'value', {
		        set: newSetter
		    })
		    setters['TEXTAREA'] = Object.getOwnPropertyDescriptor(bproto, 'value').set
		    Object.defineProperty(bproto, 'value', {
		        set: newSetter
		    })
		    valueHijack = true
		} catch (e) {
		    //在chrome 43中 ms-duplex终于不需要使用定时器实现双向绑定了
		    // http://updates.html5rocks.com/2015/04/DOM-attributes-now-on-the-prototype
		    // https://docs.google.com/document/d/1jwA8mtClwxI-QJuHT7872Z0pxpZz8PBkf2bGAbsUtqs/edit?pli=1
		}
		module.exports = valueHijack

	/***/ },
	/* 55 */,
	/* 56 */
	/***/ function(module, exports) {

		
		module.exports = function addField(node, vnode) {
		    var field = node.__ms_duplex__
		    var rules = vnode['ms-rules']
		    if (rules && !field.validator) {
		        while (node && node.nodeType === 1) {
		            var validator = node._ms_validator_
		            if (validator) {
		                field.rules = rules
		                field.validator = validator
		                if(avalon.Array.ensure(validator.fields, field)){
		                    validator.addField(field)
		                }
		                break
		            }
		            node = node.parentNode
		        }
		    }
		}


	/***/ },
	/* 57 */
	/***/ function(module, exports, __webpack_require__) {

		var update = __webpack_require__(37)

		var dir = avalon.directive('validate', {
		//验证单个表单元素
		    diff: function (copy, src, name) {
		        var validator = copy[name]
		        var p = src[name]
		        if (p && p.onError && p.addField) {
		            return
		        } else if (Object(validator) === validator) {
		            src.vmValidator = validator
		            if (validator.$id) {//转换为普通对象
		                validator = validator.$model
		            }
		           
		            src[name] = validator
		            for (var name in dir.defaults) {
		                if (!validator.hasOwnProperty(name)) {
		                    validator[name] = dir.defaults[name]
		                }
		            }
		            validator.fields = validator.fields || []
		            update(src, this.update)

		        }
		    },
		    update: function (dom, vdom) {
		        var validator = vdom['ms-validate']
		        dom._ms_validator_ = validator
		        validator.dom = dom
		        var v = vdom.vmValidator 
		        try{
		           v.onManual = onManual
		        }catch(e){}
		        delete vdom.vmValidator 
		        dom.setAttribute("novalidate", "novalidate")
		        function onManual() {
		            dir.validateAll.call(validator, validator.onValidateAll)
		        }
		        if (validator.validateAllInSubmit) {
		            avalon.bind(dom, "submit", function (e) {
		                e.preventDefault()
		                onManual()
		            })
		        }
		       
		        if (typeof validator.onInit === "function") { //vmodels是不包括vmodel的
		            validator.onInit.call(dom, {
		                type: 'init',
		                target: dom,
		                validator: validator
		            })
		        }
		    },
		    validateAll: function (callback) {
		        var validator = this
		        var fn = typeof callback === "function" ? callback : validator.onValidateAll
		        var promise = validator.fields.filter(function (field) {
		            var el = field.dom
		            return el && !el.disabled && validator.dom.contains(el)
		        }).map(function (field) {
		            return dir.validate(field, true)
		        })
		        var reasons = []
		        Promise.all(promise).then(function (array) {
		            for (var i = 0, el; el = array[i++]; ) {
		                reasons = reasons.concat(el)
		            }
		            if (validator.deduplicateInValidateAll) {
		                var uniq = {}
		                reasons = reasons.filter(function (field) {
		                    var el = field.dom
		                    var uuid = el.uniqueID || (el.uniqueID = setTimeout("1"))
		                    if (uniq[uuid]) {
		                        return false
		                    } else {
		                        uniq[uuid] = true
		                        return true
		                    }
		                })
		            }
		            fn.call(validator.dom, reasons) //这里只放置未通过验证的组件
		        })
		    },
		    addField: function (field) {
		        var validator = this
		        var node = field.dom
		        if (validator.validateInKeyup && (!field.isChanged && !field.debounceTime)) {
		            avalon.bind(node, 'keyup', function (e) {
		                dir.validate(field, 0, e)
		            })
		        }
		        if (validator.validateInBlur) {
		            avalon.bind(node, 'blur', function (e) {
		                dir.validate(field, 0, e)
		            })
		        }
		        if (validator.resetInFocus) {
		            avalon.bind(node, 'focus', function (e) {
		                validator.onReset.call(node, e, field)
		            })
		        }
		    },
		    validate: function (field, isValidateAll, event) {
		        var promises = []
		        var value = field.modelValue
		        var elem = field.dom
		        var validator = field.validator
		        if (elem.disabled)
		            return
		        for (var ruleName in field.rules) {
		            var ruleValue = field.rules[ruleName]
		            if (ruleValue === false)
		                continue
		            var hook = avalon.validators[ruleName]
		            var resolve, reject
		            promises.push(new Promise(function (a, b) {
		                resolve = a
		                reject = b
		            }))
		            var next = function (a) {
		                if (field.norequired && value === "") {
		                    a = true
		                }
		                if (a) {
		                    resolve(true)
		                } else {
		                    var reason = {
		                        element: elem,
		                        data: field.data,
		                        message: elem.getAttribute("data-" + ruleName + "-message") || elem.getAttribute("data-message") || hook.message,
		                        validateRule: ruleName,
		                        getMessage: getMessage
		                    }
		                    resolve(reason)
		                }
		            }
		            field.data = {}
		            field.data[ruleName] = ruleValue
		            hook.get(value, field, next)
		        }
		        var reasons = []
		        //如果promises不为空，说明经过验证拦截器
		        var lastPromise = Promise.all(promises).then(function (array) {
		            for (var i = 0, el; el = array[i++]; ) {
		                if (typeof el === "object") {
		                    reasons.push(el)
		                }
		            }
		            if (!isValidateAll) {
		                if (reasons.length) {
		                    validator.onError.call(elem, reasons, event)
		                } else {
		                    validator.onSuccess.call(elem, reasons, event)
		                }
		                validator.onComplete.call(elem, reasons, event)
		            }
		            return reasons
		        })
		        return lastPromise
		    }
		})

		var rformat = /\\?{{([^{}]+)\}}/gm

		function getMessage() {
		    var data = this.data || {}
		    return this.message.replace(rformat, function (_, name) {
		        return data[name] == null ? "" : data[name]
		    })
		}
		dir.defaults = {
		    addField: dir.addField,//供内部使用,收集此元素底下的所有ms-duplex的域对象
		    onError: avalon.noop,
		    onSuccess: avalon.noop,
		    onComplete: avalon.noop,
		    onManual: avalon.noop,
		    onReset: avalon.noop,
		    onValidateAll: avalon.noop,
		    validateInBlur: true, //@config {Boolean} true，在blur事件中进行验证,触发onSuccess, onError, onComplete回调
		    validateInKeyup: true, //@config {Boolean} true，在keyup事件中进行验证,触发onSuccess, onError, onComplete回调
		    validateAllInSubmit: true, //@config {Boolean} true，在submit事件中执行onValidateAll回调
		    resetInFocus: true, //@config {Boolean} true，在focus事件中执行onReset回调,
		    deduplicateInValidateAll: false //@config {Boolean} false，在validateAll回调中对reason数组根据元素节点进行去重
		}

	/***/ },
	/* 58 */
	/***/ function(module, exports) {

		avalon.directive('rules', {
		    parse: function (copy, src, binding) {
		        var rules = binding.expr
		        if (/{.+}/.test(rules)) {
		            copy[binding.name] = avalon.parseExpr(binding)
		        }
		    },
		    diff: function (copy, src, name) {
		        src[name] = copy[name]
		        var field = src.dom && src.dom.__ms_duplex__
		        if (field) {
		            field.rules = copy[name]
		        }
		    }
		})
		function isRegExp(value) {
		    return avalon.type(value) === 'regexp'
		}
		var rmail = /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/i
		var rurl = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/
		function isCorrectDate(value) {
		    if (typeof value === "string" && value) { //是字符串但不能是空字符
		        var arr = value.split("-") //可以被-切成3份，并且第1个是4个字符
		        if (arr.length === 3 && arr[0].length === 4) {
		            var year = ~~arr[0] //全部转换为非负整数
		            var month = ~~arr[1] - 1
		            var date = ~~arr[2]
		            var d = new Date(year, month, date)
		            return d.getFullYear() === year && d.getMonth() === month && d.getDate() === date
		        }
		    }
		    return false
		}
		avalon.shadowCopy(avalon.validators, {
		    pattern: {
		        message: '必须匹配{{pattern}}这样的格式',
		        get: function (value, field, next) {
		            var elem = field.element
		            var data = field.data
		            if (!isRegExp(data.pattern)) {
		                var h5pattern = elem.getAttribute("pattern")
		                data.pattern = new RegExp('^(?:' + h5pattern + ')$')
		            }
		            next(data.pattern.test(value))
		            return value
		        }
		    },
		    digits: {
		        message: '必须整数',
		        get: function (value, field, next) {//整数
		            next(/^\-?\d+$/.test(value))
		            return value
		        }
		    },
		    number: {
		        message: '必须数字',
		        get: function (value, field, next) {//数值
		            next(isFinite(value))
		            return value
		        }
		    },
		    required: {
		        message: '必须填写',
		        get: function (value, field, next) {
		            next(value !== "")
		            return value
		        }
		    },
		    equalto: {
		        message: '密码输入不一致',
		        get: function (value, field, next) {
		            var id = String(field.data.equalto)
		            var other = avalon(document.getElementById(id)).val() || ""
		            next(value === other)
		            return value
		        }
		    },
		    date: {
		        message: '日期格式不正确',
		        get: function (value, field, next) {
		            var data = field.data
		            if (avalon.type(data.date) === 'regexp') {
		                next(data.date.test(value))
		            } else {
		                next(isCorrectDate(value))
		            }
		            return value
		        }
		    },
		    url: {
		        message: 'URL格式不正确',
		        get: function (value, field, next) {
		            next(rurl.test(value))
		            return value
		        }
		    },
		    email: {
		        message: 'email格式不正确',
		        get: function (value, field, next) {
		            next(rmail.test(value))
		            return value
		        }
		    },
		    minlength: {
		        message: '最少输入{{minlength}}个字',
		        get: function (value, field, next) {
		            var num = parseInt(field.data.minlength, 10)
		            next(value.length >= num)
		            return value
		        }
		    },
		    maxlength: {
		        message: '最多输入{{maxlength}}个字',
		        get: function (value, field, next) {
		            var num = parseInt(field.data.maxlength, 10)
		            next(value.length <= num)
		            return value
		        }
		    },
		    min: {
		        message: '输入值不能小于{{min}}',
		        get: function (value, field, next) {
		            var num = parseInt(field.data.min, 10)
		            next(parseFloat(value) >= num)
		            return value
		        }
		    },
		    max: {
		        message: '输入值不能大于{{max}}',
		        get: function (value, field, next) {
		            var num = parseInt(field.data.max, 10)
		            next(parseFloat(value) <= num)
		            return value
		        }
		    },
		    chs: {
		        message: '必须是中文字符',
		        get: function (value, field, next) {
		            next(/^[\u4e00-\u9fa5]+$/.test(value))
		            return value
		        }
		    }
		})

	/***/ },
	/* 59 */
	/***/ function(module, exports, __webpack_require__) {

		var update = __webpack_require__(37)
		//ms-imporant ms-controller ms-for ms-widget ms-effect ms-if   ...
		avalon.directive('if', {
		    priority: 6,
		    diff: function (copy, src, name) {
		        var cur = !!copy[name]
		        var old = src[name]
		        src[name] = cur
		        if (src.execIf) {
		            if (!cur) {
		                copy.nodeType = 8
		                copy.order = '' //不再执行子孙节点的操作
		            }
		            if (copy === src || cur !== old) {
		                update(src, this.update)
		            }
		        } else {
		            update(src, this.update, 'afterChange')
		        }
		    },
		    update: function (dom, vdom, parent) {
		        var show = vdom['ms-if']
		        vdom.execIf = true
		        if (show) {
		            //要移除元素节点,在对应位置上插入注释节点
		            vdom.nodeType = 1
		            vdom.nodeValue = null
		            var comment = vdom.comment
		            if (!comment) {
		                return
		            }
		            parent = comment.parentNode
		            parent.replaceChild(dom, comment)
		            avalon.applyEffect(dom, vdom, {
		                hook: 'onEnterDone'
		            })
		        } else {
		            avalon.applyEffect(dom, vdom, {
		                hook: 'onLeaveDone',
		                cb: function () {
		                    var comment = document.createComment('ms-if')
		                    //去掉注释节点临时添加的ms-effect
		                    //https://github.com/RubyLouvre/avalon/issues/1577
		                    //这里必须设置nodeValue为ms-if,否则会在节点对齐算法中出现乱删节点的BUG
		                    parent = parent || dom.parentNode
		                    vdom.nodeValue = 'ms-if'
		                    parent.replaceChild(comment, dom)
		                    vdom.nodeType = 8
		                    vdom.comment = comment
		                }
		            })
		        }
		    }
		})



	/***/ },
	/* 60 */
	/***/ function(module, exports, __webpack_require__) {

		var update = __webpack_require__(37)

		var rforPrefix = /ms-for\:\s*/
		var rforLeft = /^\s*\(\s*/
		var rforRight = /\s*\)\s*$/
		var rforSplit = /\s*,\s*/
		var rforAs = /\s+as\s+([$\w]+)/
		var rident = /^[$a-zA-Z_][$a-zA-Z0-9_]*$/
		var rinvalid = /^(null|undefined|NaN|window|this|\$index|\$id)$/
		var reconcile = __webpack_require__(39)
		var stringify = __webpack_require__(50)

		//var Cache = require('../seed/cache')
		//var cache = new Cache(312)


		function getTraceKey(item) {
		    var type = typeof item
		    return item && type === 'object' ? item.$hashcode : type + ':' + item
		}
		//IE6-8,function后面没有空格
		var rfunction = /^\s*function\s*\(([^\)]+)\)/
		avalon._each = function (obj, fn, local, vnodes) {
		    var repeat = []
		    vnodes.push(repeat)
		    var str = (fn + "").match(rfunction)
		    var args = str[1]
		    var arr = args.match(avalon.rword)
		    if (Array.isArray(obj)) {
		        for (var i = 0; i < obj.length; i++) {
		            iterator(i, obj[i], local, fn, arr[0], arr[1], repeat, true)
		        }
		    } else {
		        for (var i in obj) {
		            if (obj.hasOwnProperty(i)) {
		                iterator(i, obj[i], local, fn, arr[0], arr[1], repeat)
		            }
		        }
		    }
		}

		function iterator(index, item, vars, fn, k1, k2, repeat, isArray) {
		    var key = isArray ? getTraceKey(item) : index
		    var local = {}
		    local[k1] = index
		    local[k2] = item
		    for (var k in vars) {
		        if (!(k in local)) {
		            local[k] = vars[k]
		        }
		    }
		    fn(index, item, key, local, repeat)
		}


		avalon.directive('for', {
		    priority: 3,
		    parse: function (copy, src, binding) {
		        var str = src.nodeValue, aliasAs
		        str = str.replace(rforAs, function (a, b) {
		            if (!rident.test(b) || rinvalid.test(b)) {
		                avalon.error('alias ' + b + ' is invalid --- must be a valid JS identifier which is not a reserved name.')
		            } else {
		                aliasAs = b
		            }
		            return ''
		        })

		        var arr = str.replace(rforPrefix, '').split(' in ')
		        var assign = 'var loop = ' + avalon.parseExpr(arr[1]) + ' \n'
		        var alias = aliasAs ? 'var ' + aliasAs + ' = loop\n' : ''
		        var kv = arr[0].replace(rforLeft, '').replace(rforRight, '').split(rforSplit)

		        if (kv.length === 1) {//确保avalon._each的回调有三个参数
		            kv.unshift('$key')
		        }
		        kv.push('traceKey')
		        kv.push('__local__')
		        kv.push('vnodes')
		        src.$append = assign + alias + 'avalon._each(loop,function('
		                + kv.join(', ') + '){\n'
		                + (aliasAs ? '__local__[' + avalon.quote(aliasAs) + ']=loop\n' : '')

		    },
		    diff: function (copy, src, cpList, spList, index) {
		        //将curRepeat转换成一个个可以比较的component,并求得compareText
		        var preRepeat = spList[index + 1]
		        var curPepeat = cpList[index + 1]
		        var end = spList[index + 2]
		        //preRepeat不为空时
		        src.preRepeat = preRepeat
		        var cache = src.cache

		        if (cache && src === copy) {
		            return
		        }
		        //将循环区域转换为一个个组件
		        var coms = prepareCompare(curPepeat, copy)
		        if (cache && src.compareText === copy.compareText) {
		            //如果个数与key一致,那么说明此数组没有发生排序,立即返回
		            return
		        }


		        src.compareText = copy.compareText
		        //for指令只做添加删除操作

		        var i, c, p
		        var removes = []
		        if (!preRepeat.length) {//一维数组最开始初始化时
		            /* eslint-disable no-cond-assign */
		            cache = {}
		            src.coms = coms
		            spList[index + 1] = curPepeat
		            for (i = 0; c = coms[i]; i++) {
		                c.action = 'enter'
		                saveInCache(cache, c)
		            }

		            src.cache = cache
		            /* eslint-enable no-cond-assign */
		        } else if (!cache) {//二维数组最开始初始化时
		            var cache = {}
		            src.coms = coms
		            for (i = 0; i < coms.length; i++) {
		                saveInCache(cache, coms[i])
		            }
		            src.cache = cache
		            return
		        } else {
		            var newCache = {}
		            /* eslint-disable no-cond-assign */
		            var fuzzy = []
		            for (i = 0; c = coms[i++]; ) {
		                var p = isInCache(cache, c.key)
		                if (p) {
		                    p.action = 'move'
		                    p.oldIndex = p.index
		                    p.index = c.index
		                    saveInCache(newCache, p)
		                } else {
		                    //如果找不到就进行模糊搜索
		                    fuzzy.push(c)
		                }

		            }
		            if (!src.coms) {
		                src.coms = prepareCompare(preRepeat, src)
		            }
		            for (var i = 0, c; c = fuzzy[i++]; ) {
		                p = fuzzyMatchCache(cache, c.key)
		                if (p) {
		                    p.action = 'move'
		                    p.oldIndex = p.index
		                    p.index = c.index
		                } else {
		                    p = c
		                    p.action = 'enter'
		                    src.coms.push(p)
		                }
		                saveInCache(newCache, p)
		            }
		            src.coms.sort(function (a, b) {
		                return a.index - b.index
		            })

		            /* eslint-enable no-cond-assign */
		            src.cache = newCache
		            for (var i in cache) {
		                p = cache[i]
		                p.action = 'leave'
		                removes.push(p)
		                if (p.arr) {
		                    p.arr.forEach(function (m) {
		                        m.action = 'leave'
		                        removes.push(m)
		                    })
		                    delete p.arr
		                }
		            }

		        }
		        src.removes = removes
		        var cb = avalon.caches[src.wid]
		        var vm = copy.vmodel
		        if (end && cb) {
		            end.afterChange = [function (dom) {
		                    cb.call(vm, {
		                        type: 'rendered',
		                        target: dom,
		                        signature: src.signature
		                    })
		                }]
		        }

		        update(src, this.update)
		        return true

		    },
		    update: function (dom, vdom, parent) {
		        var key = vdom.signature
		        var range = getEndRepeat(dom)
		        var doms = range.slice(1, -1)//
		        range.pop()
		        var DOMs = splitDOMs(doms, key)

		        for (var i = 0, el; el = vdom.removes[i++]; ) {
		            var removeNodes = DOMs[el.index]
		            if (removeNodes) {
		                removeNodes.forEach(function (n, k) {
		                    if (n.parentNode) {
		                        avalon.applyEffect(n, el.children[k], {
		                            hook: 'onLeaveDone',
		                            cb: function () {
		                                n.parentNode.removeChild(n)
		                            },
		                            staggerKey: key + 'leave'
		                        })
		                    }
		                })
		                el.children.length = 0
		            }
		        }
		        vdom.removes = []
		        var insertPoint = dom
		        var fragment = avalon.avalonFragment
		        var domTemplate
		        var keep = []

		        for (var i = 0; i < vdom.coms.length; i++) {
		            var com = vdom.coms[i]
		            var children = com.children

		            if (com.action === 'leave') {
		                continue
		            }

		            keep.push(com)
		            if (com.action === 'enter') {
		//                if (!domTemplate) {
		//                    //创建用于拷贝的数据,包括虚拟DOM与真实DOM 
		//                  domTemplate = avalon.vdomAdaptor(children, 'toDOM')
		//                }
		//                var newFragment = domTemplate.cloneNode(true)
		                var newFragment = avalon.vdomAdaptor(children, 'toDOM')
		                var cnodes = avalon.slice(newFragment.childNodes)
		                reconcile(cnodes, children, parent)//关联新的虚拟DOM与真实DOM
		                parent.insertBefore(newFragment, insertPoint.nextSibling)
		                applyEffects(cnodes, children, {
		                    hook: 'onEnterDone',
		                    staggerKey: key + 'enter'
		                })
		            } else if (com.action === 'move') {

		                var cnodes = DOMs[com.oldIndex] || []
		                if (com.index !== com.oldIndex) {
		                    var moveFragment = fragment.cloneNode(false)
		                    for (var k = 0, cc; cc = cnodes[k++]; ) {
		                        moveFragment.appendChild(cc)
		                    }
		                    parent.insertBefore(moveFragment, insertPoint.nextSibling)
		                    // reconcile(cnodes, children, parent)
		                    applyEffects(cnodes, children, {
		                        hook: 'onMoveDone',
		                        staggerKey: key + 'move'
		                    })
		                }
		            }

		            insertPoint = cnodes[cnodes.length - 1]

		            if (!insertPoint) {
		                break
		            }
		        }

		        vdom.preRepeat.length = 0
		        vdom.coms.length = 0
		        keep.forEach(function (el) {
		            vdom.coms.push(el)
		            range.push.apply(vdom.preRepeat, el.children)
		        })

		    }

		})

		function isEmptyObject(a) {
		    for (var i in a) {
		        return false
		    }
		    return true
		}
		function splitDOMs(nodes, signature) {
		    var items = []
		    var item = []
		    for (var i = 0, el; el = nodes[i++]; ) {
		        if (el.nodeType === 8 && el.nodeValue === signature) {
		            item.push(el)
		            items.push(item)
		            item = []
		        } else {
		            item.push(el)
		        }
		    }
		    return items
		}

		//将要循环的节点根据锚点元素再分成一个个更大的单元,用于diff
		function prepareCompare(nodes, cur) {
		    var splitText = cur.signature
		    var items = []
		    var keys = []
		    var com = {
		        children: []
		    }

		    for (var i = 0, el; el = nodes[i]; i++) {
		        if (el.nodeType === 8 && el.nodeValue === splitText) {
		            com.children.push(el)
		            com.key = el.key
		            keys.push(el.key)
		            com.index = items.length
		            items.push(com)
		            com = {
		                children: []
		            }
		        } else {
		            com.children.push(el)
		        }
		    }

		    cur.compareText = keys.length + '|' + keys.join(';;')
		    return items
		}


		function getEndRepeat(node) {
		    var isBreak = 0, ret = []
		    while (node) {
		        if (node.nodeType === 8) {
		            if (node.nodeValue.indexOf('ms-for:') === 0) {
		                ++isBreak
		            } else if (node.nodeValue.indexOf('ms-for-end:') === 0) {
		                --isBreak
		            }
		        }
		        ret.push(node)
		        node = node.nextSibling
		        if (isBreak === 0) {
		            break
		        }
		    }
		    return ret
		}


		var rfuzzy = /^(string|number|boolean)/
		var rkfuzzy = /^_*(string|number|boolean)/
		function fuzzyMatchCache(cache, id) {
		    var m = id.match(rfuzzy)
		    if (m) {
		        var fid = m[1]
		        for (var i in cache) {
		            var n = i.match(rkfuzzy)
		            if (n && n[1] === fid) {
		                return isInCache(cache, i)
		            }
		        }
		    }
		}

		// 新位置: 旧位置
		function isInCache(cache, id) {
		    var c = cache[id]
		    if (c) {
		        var arr = c.arr
		        if (arr) {
		            var r = arr.pop()
		            if (!arr.length) {
		                c.arr = 0
		            }
		            return r
		        }
		        delete cache[id]
		        return c
		    }
		}
		//[1,1,1] number1 number1_ number1__
		function saveInCache(cache, component) {
		    var trackId = component.key
		    if (!cache[trackId]) {
		        cache[trackId] = component
		    } else {
		        var c = cache[trackId]
		        var arr = c.arr || (c.arr = [])
		        arr.push(component)
		    }
		}
		var applyEffects = function (nodes, vnodes, opts) {
		    vnodes.forEach(function (el, i) {
		        avalon.applyEffect(nodes[i], vnodes[i], opts)
		    })
		}



	/***/ },
	/* 61 */
	/***/ function(module, exports, __webpack_require__) {

		var update = __webpack_require__(37)
		var reconcile = __webpack_require__(39)
		var tryInitComponent = __webpack_require__(62)

		avalon.component = function (name, definition) {
		    //这是定义组件的分支,并将列队中的同类型对象移除
		    if (!avalon.components[name]) {
		        avalon.components[name] = definition
		    }//这里没有返回值
		}
		avalon.directive('widget', {
		    priority: 4,
		    parse: function (copy, src, binding) {
		        src.props.wid = src.props.wid || avalon.makeHashCode('w')
		        //将渲染函数的某一部分存起来,渲在c方法中转换为函数
		        copy[binding.name] = avalon.parseExpr(binding)
		        copy.template = src.template
		        copy.vmodel = '__vmodel__'
		        copy.local = '__local__'
		    },
		    define: function () {
		        return avalon.mediatorFactory.apply(this, arguments)
		    },
		    diff: function (copy, src, name, copyList, srcList, index) {
		        var a = copy[name]

		        if (Object(a) === a) {
		            //有三个地方可以设置is, 属性,标签名,配置对象

		            var is = src.props.is || (/^ms\-/.test(src.type) ? src.type : 0)

		            if (!is) {//开始大费周章地获取组件的类型
		                a = a.$model || a//安全的遍历VBscript
		                if (Array.isArray(a)) {//转换成对象
		                    a.unshift({})// 防止污染旧数据
		                    avalon.mix.apply(0, a)
		                    a = a.shift()
		                }
		                is = a.is
		            }
		            var vmName = 'component-vm:' + is

		            src.props.is = is
		            src.vmodel = copy.vmodel
		            //如果组件没有初始化,那么先初始化(生成对应的vm,$render)
		            if (!src[vmName]) {
		                if (!tryInitComponent(src, copy[name], copy.local, copy.template)) {
		                    //替换成注释节点
		                    src.nodeType = 8
		                    src.nodeValue = 'unresolved component placeholder'
		                    copyList[index] = src

		                    update(src, this.mountComment)
		                    return
		                }
		            }

		            //如果已经存在于avalon.scopes
		            var comVm = src[vmName]
		            var scope = avalon.scopes[comVm.$id]
		            if (scope && scope.vmodel) {
		                var com = scope.vmodel.$element
		                if (src.dom !== com) {
		                    var component = com.vtree[0]
		                    srcList[index] = copyList[index] = component
		                    src.com = com
		                    if (!component.skipContent) {
		                        component.skipContent = 'optimize'
		                    }
		                    update(src, this.replaceCachedComponent)
		                    update(component, function () {
		                        if (component.skipContent === 'optimize') {
		                            component.skipContent = true
		                        }
		                    }, 'afterChange')
		                    return
		                }
		            }
		            var render = comVm.$render
		            var tree = render(comVm, copy.local)
		            var component = tree[0]
		            if (component && isComponentReady(component)) {
		                component.local = copy.local
		                src.dynamic = true
		                Array(
		                        vmName,
		                        'component-html:' + is,
		                        'component-ready:' + is,
		                        'dom', 'dynamic'
		                        ).forEach(function (name) {
		                    component[name] = src[name]
		                })
		                component.vmodel = comVm
		                copyList[index] = component
		                if (src.nodeType === 8 && src.comment) {
		                    component.dom = src.comment
		                    src.type = '#comment'
		                }
		                if (src.type !== component.type) {
		                    srcList[index] = component
		                    update(component, this.mountComponent)
		                } else {
		                    update(src, this.updateComponent)
		                }
		            } else {
		                src.nodeType = 8
		                src.nodeValue = 'unresolved component placeholder'
		                copyList[index] = src
		                update(src, this.mountComment)
		            }
		        } else {
		            if (src.props.is === copy.props.is) {
		                update(src, this.updateComponent)
		            }
		        }
		    },
		    replaceCachedComponent: function (dom, vdom, parent) {
		        var com = vdom.com
		        parent.replaceChild(com, dom)
		        delete vdom.com
		    },
		    mountComment: function (dom, vdom, parent) {
		        var comment = document.createComment(vdom.nodeValue)
		        vdom.dom = comment
		        parent.replaceChild(comment, dom)
		    },
		    updateComponent: function (dom, vdom) {
		        var vm = vdom["component-vm:" + vdom.props.is]
		        var viewChangeObservers = vm.$events.onViewChange
		        if (viewChangeObservers && viewChangeObservers.length) {
		            update(vdom, viewChangeHandle, 'afterChange')
		        }
		    },
		    mountComponent: function (dom, vdom, parent) {
		        var com = avalon.vdomAdaptor(vdom, 'toDOM')
		        var is = vdom.props.is
		        var vm = vdom['component-vm:' + is]
		        vm.$fire('onInit', {
		            type: 'init',
		            vmodel: vm,
		            is: is
		        })
		        reconcile([com], [vdom])
		        parent.replaceChild(com, dom)
		        vdom.dom = vm.$element = com
		        com.vtree = [vdom]
		        avalon.onComponentDispose(com)
		        vdom['component-ready:' + is] = true
		        //--------------
		        avalon.scopes[vm.$id] = {
		            vmodel: vm,
		            top: vdom.vmodel,
		            local: vdom.local
		        }
		        //--------------
		        update(vdom, function () {
		            vm.$fire('onReady', {
		                type: 'ready',
		                target: com,
		                vmodel: vm,
		                is: is
		            })
		        }, 'afterChange')

		        update(vdom, function () {
		            vdom[ 'component-html:' + is] = avalon.vdomAdaptor(vdom, 'toHTML')
		        }, 'afterChange')
		    }
		})



		function viewChangeHandle(dom, vdom) {
		    var is = vdom.props.is
		    var vm = vdom['component-vm:' + is]
		    var html = 'component-html:' + is
		    var preHTML = vdom[html]
		    var curHTML = avalon.vdomAdaptor(vdom, 'toHTML')
		    if (preHTML !== curHTML) {
		        vdom[html] = curHTML
		        vm.$fire('onViewChange', {
		            type: 'viewchange',
		            target: dom,
		            vmodel: vm,
		            is: is
		        })
		    }
		}



		function isComponentReady(vnode) {
		    var isReady = true
		    try {
		        hasUnresolvedComponent(vnode)
		    } catch (e) {
		        isReady = false
		    }
		    return isReady
		}

		function hasUnresolvedComponent(vnode) {
		    vnode.children.forEach(function (el) {
		        if (el.nodeType === 8) {
		            if (el.nodeValue === 'unresolved component placeholder') {
		                throw 'unresolved'
		            }
		        } else if (el.children) {
		            hasUnresolvedComponent(el)
		        }
		    })
		}

	/***/ },
	/* 62 */
	/***/ function(module, exports, __webpack_require__) {

		var skipArray = __webpack_require__(63)

		var legalTags = {wbr: 1, xmp: 1, template: 1}
		var events = 'onInit,onReady,onViewChange,onDispose'
		var componentEvents = avalon.oneObject(events)
		var immunity = events.split(',').concat('is', 'define')
		var onceWarn = true
		function initComponent(src, rawOption, local, template) {
		    var tag = src.type
		    var is = src.props.is
		    //判定用户传入的标签名是否符合规格
		    if (!legalTags[tag] && !isCustomTag(tag)) {
		        avalon.warn(tag + '不合适做组件的标签')
		        return
		    }
		    //开始初始化组件
		    var hooks = {}
		    //用户只能操作顶层VM
		    //只有$id,is的对象就是emptyOption
		    if (!rawOption) {
		        options = []
		    } else {
		        var options = [].concat(rawOption)
		        options.forEach(function (a) {
		            if (a && typeof a === 'object') {
		                mixinHooks(hooks, (a.$model || a), true)
		            }
		        })
		    }
		    var definition = avalon.components[is]
		    //如果连组件的定义都没有加载回来,应该立即返回 
		    if (!definition) {
		        return
		    }
		  

		    //得到组件在顶层vm的配置对象名
		    if (!hooks.$id && onceWarn) {
		        avalon.warn('warning!', is, '组件最好在ms-widget配置对象中指定全局不重复的$id以提高性能!\n',
		                '若在ms-for循环中可以利用 ($index,el) in @array 中的$index拼写你的$id\n',
		                '如 ms-widget="{is:\'ms-button\',$id:\'btn\'+$index}"'
		                )
		        onceWarn = false
		    }
		    var define = hooks.define
		    define = define || avalon.directives.widget.define
		    //生成组件VM
		    var $id = hooks.$id || src.props.wid || 'w' + (new Date - 0)
		    var defaults = avalon.mix(true, {}, definition.defaults)
		    mixinHooks( hooks, defaults, false)//src.vmodel,
		    var skipProps = immunity.concat()
		    function sweeper(a, b) {
		        skipProps.forEach(function (k) {
		            delete a[k]
		            delete b[k]
		        })
		    }

		    sweeper.isWidget = true
		    var vmodel = define.apply(sweeper, [src.vmodel,defaults].concat(options))
		    if (!avalon.modern) {//增强对IE的兼容
		        for (var i in vmodel) {
		            if (!skipArray[i] && typeof vmodel[i] === 'function') {
		                vmodel[i] = vmodel[i].bind(vmodel)
		            }
		        }
		    }
		   
		    vmodel.$id = $id
		    avalon.vmodels[$id] = vmodel

		    //绑定组件的生命周期钩子
		    for (var e in componentEvents) {
		        if (hooks[e]) {
		            hooks[e].forEach(function (fn) {
		                vmodel.$watch(e, fn)
		            })
		        }
		    }

		    // 生成外部的渲染函数
		    // template保存着最原始的组件容器信息
		    // 我们先将它转换成虚拟DOM,如果是xmp, template,
		    // 它们内部是一个纯文本节点, 需要继续转换为虚拟DOM
		    var shell = avalon.lexer(template)
		    var shellRoot = shell[0]
		    var sc = shellRoot.children
		    if (sc && sc.length === 1 && sc[0].nodeValue) {
		        shellRoot.children = avalon.lexer(sc[0].nodeValue)
		    }

		    delete shellRoot.isVoidTag
		    delete shellRoot.template
		    delete shellRoot.skipContent
		    delete shellRoot.props['ms-widget']
		    shellRoot.type = 'cheng7'
		    shellRoot.children = shellRoot.children || []
		    shellRoot.props.is = is
		    shellRoot.props.wid = $id
		    avalon.speedUp(shell)
		    var render = avalon.render(shell, local)
		    
		    //生成内部的渲染函数
		    var finalTemplate = definition.template.trim()
		    if (typeof definition.getTemplate === 'function') {
		        finalTemplate = definition.getTemplate(vmodel, finalTemplate)
		    }
		    var vtree = avalon.lexer(finalTemplate)

		    if (vtree.length > 1) {
		        avalon.error('组件必须用一个元素包起来')
		    }
		    var soleSlot = definition.soleSlot
		    replaceSlot(vtree, soleSlot)
		    avalon.speedUp(vtree)

		    var render2 = avalon.render(vtree)

		    //生成最终的组件渲染函数
		    var str = fnTemplate + ''
		    var zzzzz = soleSlot ? avalon.quote(soleSlot) : "null"
		    str = str.
		            replace('XXXXX', stringifyAnonymous(render)).
		            replace('YYYYY', stringifyAnonymous(render2)).
		            replace('ZZZZZ', zzzzz)

		    var begin = str.indexOf('{') + 1
		    var end = str.lastIndexOf("}")

		    var lastFn = Function('vm', 'local', str.slice(begin, end))
		    vmodel.$render = lastFn
		    src['component-vm:' + is] = vmodel

		    return  vmodel.$render = lastFn

		}
		module.exports = initComponent

		function stringifyAnonymous(fn) {
		    return fn.toString().replace('anonymous', '')
		            .replace(/\s*\/\*\*\//g, '')
		}


		function fnTemplate() {
		    var shell = (XXXXX)(vm, local);
		    var shellRoot = shell[0]
		    var vtree = (YYYYY)(vm, local);
		    var component = vtree[0]

		    //处理diff
		    var orderUniq = {}
		   
		    String('ms-widget,'+shellRoot.order + ',' + component.order).
		            replace(avalon.rword, function (a) {
		                if (a !== 'undefined')
		                    orderUniq[a] = a
		            })

		    shellRoot.order = Object.keys(orderUniq).join(',')

		    for (var i in shellRoot) {
		        if (i !== 'children' && i !== 'type') {
		            if (i === 'props') {
		                avalon.mix(component.props, shellRoot.props)
		            } else {
		                component[i] = shellRoot[i]
		            }
		        }
		    }


		    var soleSlot = ZZZZZ
		    var slots = avalon.collectSlots(shellRoot, soleSlot)
		    if (soleSlot && (!slots[soleSlot] || !slots[soleSlot].length)) {
		        slots[soleSlot] = [{
		                nodeType: 3,
		                type: '#text',
		                nodeValue: vm[soleSlot],
		                dynamic: true
		            }]
		    }
		    avalon.insertSlots(vtree, slots)

		    delete component.skipAttrs
		    delete component.skipContent
		    return vtree

		}

		function replaceSlot(vtree, slotName) {
		    for (var i = 0, el; el = vtree[i]; i++) {
		        if (el.type === 'slot') {
		            vtree.splice(i, 1, {
		                type: '#comment',
		                nodeValue: 'slot:' + (el.props.name || slotName),
		                nodeType: 8,
		                dynamic: (el.props.name || slotName)
		            }, {
		                type: '#comment',
		                nodeValue: 'slot-end:',
		                nodeType: 8
		            })
		            i++
		        } else if (el.nodeType === 1 && el.children) {
		            replaceSlot(el.children, slotName)
		        }
		    }
		}

		avalon.insertSlots = function (vtree, slots) {
		    for (var i = 0, el; el = vtree[i]; i++) {
		        if (el.nodeType === 8 && slots[el.dynamic]) {
		            var args = [i + 1, 0].concat(slots[el.dynamic])
		            vtree.splice.apply(vtree, args)
		            i += slots[el.dynamic].length
		        } else if (el.nodeType === 1 && el.children) {
		            avalon.insertSlots(el.children, slots)
		        }
		    }
		}

		avalon.collectSlots = function (node, soleSlot) {
		    var slots = {}
		    if (soleSlot) {
		        slots[soleSlot] = node.children
		        slots.__sole__ = soleSlot
		    } else {
		        node.children.forEach(function (el, i) {
		            if (el.nodeType === 1) {
		                var name = el.props.slot
		                if (name) {
		                    // delete el.props.slot
		                    if (Array.isArray(slots[name])) {
		                        slots[name].push(el)
		                    } else {
		                        slots[name] = [el]
		                    }
		                }
		            } else if (el.dynamic === 'for' && /slot=['"](\w+)/.test(el.template)) {
		                var a = RegExp.$1
		                slots[a] = node.children.slice(i, i + 2)
		            }
		        })
		    }
		    return slots
		}


		//必须以字母开头,结尾以字母或数字结束,中间至少出现一次"-",
		//并且不能大写字母,特殊符号,"_","$",汉字
		var rcustomTag = /^[a-z]([a-z\d]+\-)+[a-z\d]+$/

		function isCustomTag(type) {
		    return rcustomTag.test(type) || avalon.components[type]
		}

		function mixinHooks(target, option, overwrite) {
		    for (var k in option) {
		        var v = option[k]
		        //如果是生命周期钩子,总是不断收集
		        if (componentEvents[k]) {
		            if (k in target) {
		                target[k].push(v)
		            } else {
		                target[k] = [option[k]]
		            }
		        } else {
		            if (overwrite) {
		                target[k] = v
		            }
		        }
		    }
		}

	/***/ },
	/* 63 */
	/***/ function(module, exports) {

		/**
		 * 
		$$skipArray:是系统级通用的不可监听属性
		$skipArray: 是当前对象特有的不可监听属性

		 不同点是
		 $$skipArray被hasOwnProperty后返回false
		 $skipArray被hasOwnProperty后返回true
		 */

		module.exports = avalon.oneObject('$id,$render,$track,$element,$watch,$fire,$events,$model,$skipArray,$accessors,$hashcode,$run,$wait,__proxy__,__data__,__const__')

	/***/ },
	/* 64 */
	/***/ function(module, exports, __webpack_require__) {

		var support = __webpack_require__(65)
		var Cache = __webpack_require__(28)
		var update = __webpack_require__(37)

		avalon.directive('effect', {
		    priority: 5,
		    diff: function (copy, src, name) {
		        var copyObj = copy[name]
		        copyObj = copy.$model || copyObj
		        if (typeof copyObj === 'string') {
		            var is = copyObj
		            copyObj = {
		                is: is
		            }

		        } else if (Array.isArray(copyObj)) {
		            copyObj = avalon.mix.apply({}, copyObj)
		        }

		        copyObj.action = copyObj.action || 'enter'

		        if (Object(copyObj) === copyObj) {
		            if (copy === src || diffObj(copyObj, src[name] || {})) {
		                src[name] = copyObj
		                update(src, this.update, 'afterChange')
		            }
		        }
		        if (copy !== src) {
		            delete copy[name]
		        }
		    },
		    update: function (dom, vnode, parent, option) {
		        if (dom.animating) {
		            return
		        }
		        dom.animating = true
		        var localeOption = vnode['ms-effect']
		        var type = localeOption.is
		        option = option || {}
		        if (!type) {//如果没有指定类型
		            return avalon.warn('need is option')
		        }

		        var effects = avalon.effects
		        if (support.css && !effects[type]) {
		            avalon.effect(type, {})
		        }
		        var globalOption = effects[type]
		        if (!globalOption) {//如果没有定义特效
		            return avalon.warn(type + ' effect is undefined')
		        }
		        var action = option.action || localeOption.action
		        var Effect = avalon.Effect
		        if (typeof Effect.prototype[action] !== 'function') {
		            return avalon.warn(action + ' action is undefined')
		        }
		        var effect = new Effect(dom)
		        var finalOption = avalon.mix(option, globalOption, localeOption)
		        if (finalOption.queue) {
		            animationQueue.push(function () {
		                effect[action](finalOption)
		            })
		            callNextAnimation()
		        } else {
		            setTimeout(function () {
		                effect[action](finalOption)
		            }, 4)
		        }
		    }
		})
		function diffObj(a, b) {
		    for (var i in a) {
		        if (a[i] !== b[i])
		            return true
		    }
		    return false
		}

		var animationQueue = []
		function callNextAnimation() {
		    if (animationQueue.lock)
		        return
		    var fn = animationQueue[0]
		    if (fn) {
		        callNextAnimation.lock = true
		        fn()
		    }
		}

		avalon.effects = {}
		//这里定义CSS动画


		avalon.effect = function (name, definition) {
		    avalon.effects[name] = definition || {}
		    if (support.css) {
		        if (!definition.enterClass) {
		            definition.enterClass = name + '-enter'
		        }
		        if (!definition.enterActiveClass) {
		            definition.enterActiveClass = definition.enterClass + '-active'
		        }
		        if (!definition.leaveClass) {
		            definition.leaveClass = name + '-leave'
		        }
		        if (!definition.leaveActiveClass) {
		            definition.leaveActiveClass = definition.leaveClass + '-active'
		        }
		    }
		    if (!definition.action) {
		        definition.action = 'enter'
		    }
		}


		var Effect = function (el) {
		    this.el = el
		}
		avalon.Effect = Effect
		Effect.prototype = {
		    enter: createAction('Enter'),
		    leave: createAction('Leave'),
		    move: createAction('Move')
		}

		var rsecond = /\d+s$/
		function toMillisecond(str) {
		    var ratio = rsecond.test(str) ? 1000 : 1
		    return parseFloat(str) * ratio
		}

		function execHooks(options, name, el) {
		    var list = options[name]
		    list = Array.isArray(list) ? list : typeof list === 'function' ? [list] : []
		    list.forEach(function (fn) {
		        fn && fn(el)
		    })
		}
		var staggerCache = new Cache(128)

		function createAction(action) {
		    var lower = action.toLowerCase()
		    return function (option) {
		        var elem = this.el
		        var $el = avalon(elem)
		        var enterAnimateDone
		        var staggerTime = isFinite(option.stagger) ? option.stagger * 1000 : 0
		        if (staggerTime) {
		            if (option.staggerKey) {
		                var stagger = staggerCache.get(option.staggerKey) ||
		                        staggerCache.put(option.staggerKey, {
		                            count: 0,
		                            items: 0
		                        })
		                stagger.count++
		                stagger.items++
		            }
		        }
		        var staggerIndex = stagger && stagger.count || 0
		        var animationDone = function (e) {
		            var isOk = e !== false
		            elem.animating = void 0
		            enterAnimateDone = true
		            var dirWord = isOk ? 'Done' : 'Abort'
		            execHooks(option, 'on' + action + dirWord, elem)
		            avalon.unbind(elem, support.transitionEndEvent)
		            avalon.unbind(elem, support.animationEndEvent)
		            if (stagger) {
		                if (--stagger.items === 0) {
		                    stagger.count = 0
		                }
		            }
		            if (option.queue) {
		                animationQueue.lock = false
		                animationQueue.shift()
		                callNextAnimation()
		            }
		        }
		        execHooks(option, 'onBefore' + action, elem)

		        if (option[lower]) {
		            option[lower](elem, function (ok) {
		                animationDone(ok !== false)
		            })
		        } else if (support.css) {

		            $el.addClass(option[lower + 'Class'])
		            if (lower === 'leave') {
		                $el.removeClass(option.enterClass + ' ' + option.enterActiveClass)
		            } else if (lower === 'enter') {
		                $el.removeClass(option.leaveClass + ' ' + option.leaveActiveClass)
		            }

		            $el.bind(support.transitionEndEvent, animationDone)
		            $el.bind(support.animationEndEvent, animationDone)
		            setTimeout(function () {
		                enterAnimateDone = avalon.root.offsetWidth === NaN
		                $el.addClass(option[lower + 'ActiveClass'])
		                var computedStyles = window.getComputedStyle(elem)
		                var tranDuration = computedStyles[support.transitionDuration]
		                var animDuration = computedStyles[support.animationDuration]
		                var time = toMillisecond(tranDuration) || toMillisecond(animDuration)
		                if (!time === 0) {
		                    animationDone(false)
		                } else if (!staggerTime) {
		                    setTimeout(function () {
		                        if (!enterAnimateDone) {
		                            animationDone(false)
		                        }
		                    }, time + 130)
		                }
		            }, 17 + staggerTime * staggerIndex)// = 1000/60
		        }
		    }
		}

		avalon.applyEffect = function (node, vnode, opts) {
		    var cb = opts.cb
		    var hook = opts.hook
		    var curEffect = vnode['ms-effect']
		    if (curEffect && !avalon.document.hidden) {
		        var old = curEffect[hook]
		        if (cb) {
		            if (Array.isArray(old)) {
		                old.push(cb)
		            } else if (old) {
		                curEffect[hook] = [old, cb]
		            } else {
		                curEffect[hook] = [cb]
		            }
		        }
		        getAction(opts)
		        node.animate = true
		        avalon.directives.effect.update(node, vnode, 0, avalon.shadowCopy({}, opts))

		    } else if (cb) {
		        cb()
		    }
		}

		function getAction(opts) {
		    if (!opts.acton) {
		        opts.action = opts.hook.replace(/^on/, '').replace(/Done$/, '').toLowerCase()
		    }
		}



	/***/ },
	/* 65 */
	/***/ function(module, exports) {

		/**
		 * ------------------------------------------------------------
		 * 检测浏览器对CSS动画的支持与API名
		 * ------------------------------------------------------------
		 */
		var supportTransition = false
		var supportAnimation = false
		var supportCSS = false
		var transitionEndEvent
		var animationEndEvent
		var transitionDuration = avalon.cssName('transition-duration')
		var animationDuration = avalon.cssName('animation-duration')

		var checker = {
		    TransitionEvent: 'transitionend',
		    WebKitTransitionEvent: 'webkitTransitionEnd',
		    OTransitionEvent: 'oTransitionEnd',
		    otransitionEvent: 'otransitionEnd'
		}
		var window = avalon.window
		var tran
		//有的浏览器同时支持私有实现与标准写法，比如webkit支持前两种，Opera支持1、3、4
		for (var name in checker) {
		    if (window[name]) {
		        tran = checker[name]
		        break
		    }
		    try {
		        var a = document.createEvent(name)
		        tran = checker[name]
		        break
		    } catch (e) {
		    }
		}
		if (typeof tran === 'string') {
		    supportTransition = true
		    supportCSS = true
		    transitionEndEvent = tran
		}

		//animationend有两个可用形态
		//IE10+, Firefox 16+ & Opera 12.1+: animationend
		//Chrome/Safari: webkitAnimationEnd
		//http://blogs.msdn.com/b/davrous/archive/2011/12/06/introduction-to-css3-animat ions.aspx
		//IE10也可以使用MSAnimationEnd监听，但是回调里的事件 type依然为animationend
		//  el.addEventListener('MSAnimationEnd', function(e) {
		//     alert(e.type)// animationend！！！
		// })
		checker = {
		    'AnimationEvent': 'animationend',
		    'WebKitAnimationEvent': 'webkitAnimationEnd'
		}
		var ani
		for (name in checker) {
		    if (window[name]) {
		        ani = checker[name]
		        break
		    }
		}
		if (typeof ani === 'string') {
		    supportAnimation = true
		    supportCSS = true
		    animationEndEvent = ani
		}

		module.exports = {
		    transition: supportTransition,
		    animation: supportAnimation,
		    css: supportCSS,
		    transitionEndEvent: transitionEndEvent,
		    animationEndEvent: animationEndEvent,
		    transitionDuration: transitionDuration,
		    animationDuration: animationDuration
		}

	/***/ },
	/* 66 */
	/***/ function(module, exports, __webpack_require__) {

		
		avalon.lexer = __webpack_require__(67)
		avalon.diff = __webpack_require__(69)
		avalon.batch = __webpack_require__(70)
		// dispatch与patch 为内置模块
		var parseView = __webpack_require__(71)

		function render(vtree, local) {
		    var _body = Array.isArray(vtree) ? parseView(vtree) : vtree
		    var _local = []
		    if (local) {
		        for (var i in local) {
		            _local.push('var ' + i + ' = __local__['+avalon.quote(i)+']')
		        }
		    }
		    var body = '__local__ = __local__ || {};\n' +
		            _local.join(';\n')+'\n' + _body
		    try{
		    var fn = Function('__vmodel__', '__local__', body)
		    }catch(e){
		        avalon.warn(_body, 'parse error')
		    }
		    return fn
		}
		avalon.render = render

		module.exports = avalon


	/***/ },
	/* 67 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * ------------------------------------------------------------
		 * avalon2.1.1的新式lexer
		 * 将字符串变成一个虚拟DOM树,方便以后进一步变成模板函数
		 * 此阶段只会生成VElement,VText,VComment
		 * ------------------------------------------------------------
		 */
		var ropenTag = /^<([-A-Za-z0-9_]+)\s*([^>]*?)(\/?)>/
		var rendTag = /^<\/([^>]+)>/
		var rmsForStart = /^\s*ms\-for\:/
		var rmsForEnd = /^\s*ms\-for\-end/
		//https://github.com/rviscomi/trunk8/blob/master/trunk8.js
		//判定里面有没有内容
		var rcontent = /\S/
		var voidTag = avalon.oneObject('area,base,basefont,bgsound,br,col,command,embed,' +
		        'frame,hr,img,input,keygen,link,meta,param,source,track,wbr')
		var plainTag = avalon.oneObject('script,style,textarea,xmp,noscript,option,template')
		var stringPool = {}
		__webpack_require__(68)

		function lexer(str) {
		    stringPool = {}
		    str = clearString(str)
		    var stack = []
		    stack.last = function () {
		        return  stack[stack.length - 1]
		    }
		    var ret = []

		    var breakIndex = 100000
		    do {
		        var node = false
		        if (str.charAt(0) !== '<') {
		            var i = str.indexOf('<')
		            i = i === -1 ? str.length : i
		            var nodeValue = str.slice(0, i).replace(rfill, fill)
		            str = str.slice(i)//处理文本节点
		            node = {type: "#text", nodeType: 3, nodeValue: nodeValue}
		            if (rcontent.test(nodeValue)) {
		                collectNodes(node, stack, ret)//不收集空白节点
		            }
		        }
		        if (!node) {
		            var i = str.indexOf('<!--')
		            if (i === 0) {
		                var l = str.indexOf('-->')
		                if (l === -1) {
		                    avalon.error("注释节点没有闭合" + str)
		                }
		                var nodeValue = str.slice(4, l).replace(rfill, fill)
		                str = str.slice(l + 3)
		                node = {type: "#comment", nodeType: 8, nodeValue: nodeValue}
		                collectNodes(node, stack, ret)
		                if (rmsForEnd.test(nodeValue)) {
		                    var p = stack.last()
		                    var nodes = p ? p.children : ret
		                    markeRepeatRange(nodes, nodes.pop())
		                }
		            }

		        }
		        if (!node) {
		            var match = str.match(ropenTag)
		            if (match) {
		                var type = match[1].toLowerCase()
		                var isVoidTag = voidTag[type] || match[3] === '\/'
		                node = {type: type, nodeType: 1, props: {}, children: [], isVoidTag: isVoidTag}
		                var attrs = match[2]
		                if (attrs) {
		                    collectProps(attrs, node.props)
		                }

		                collectNodes(node, stack, ret)
		                str = str.slice(match[0].length)
		                if (isVoidTag) {
		                    node.fire = node.isVoidTag = true
		                } else {
		                    stack.push(node)
		                    if (plainTag[type]) {
		                        var index = str.indexOf("</" + type + '>')
		                        var innerHTML = str.slice(0, index).trim()
		                        str = str.slice(index)
		                        if (innerHTML) {
		                            switch (type) {
		                                case 'style':
		                                case 'script':
		                                case 'noscript':
		                                case 'template':
		                                case 'xmp':
		                                    node.skipContent = true
		                                    if (innerHTML) {
		                                        node.children.push({
		                                            nodeType: 3,
		                                            type: '#text',
		                                            skipContent: true,
		                                            nodeValue: nomalString(innerHTML)
		                                        })
		                                    }
		                                    break
		                                case 'textarea':
		                                    node.skipContent = true
		                                    node.props.type = 'textarea'
		                                    node.props.value = nomalString(innerHTML)
		                                    break
		                                case 'option':
		                                    node.children.push({
		                                        nodeType: 3,
		                                        type: '#text',
		                                        nodeValue: nomalString(trimHTML(innerHTML))
		                                    })
		                                    break
		                            }
		                        }
		                    }
		                }
		            }
		        }
		        if (!node) {
		            var match = str.match(rendTag)
		            if (match) {
		                var type = match[1].toLowerCase()
		                var last = stack.last()
		                if (!last) {
		                    avalon.error(match[0] + '前面缺少<' + type + '>')
		                } else if (last.type !== type) {
		                    avalon.error(last.type + '没有闭合')
		                }
		                node = stack.pop()
		                node.fire = true
		                str = str.slice(match[0].length)
		            }
		        }

		        if (!node || --breakIndex === 0) {
		            break
		        }
		        if (node.fire) {
		            fireEnd(node, stack, ret)
		            delete node.fire
		        }

		    } while (str.length);

		    return ret

		}

		module.exports = lexer

		function fireEnd(node, stack, ret) {
		    var type = node.type
		    var props = node.props
		    switch (type) {
		        case 'input':
		            if (!props.type) {
		                props.type = 'text'
		            }
		            break
		        case 'select':
		            props.type = type + '-' + props.hasOwnProperty('multiple') ? 'multiple' : 'one'
		            break
		        case 'table':
		            addTbody(node.children)
		            break
		        default:
		            if (type.indexOf('ms-') === 0) {
		                props.is = type
		                if (!props['ms-widget']) {
		                    props['ms-widget'] = '{is:' + avalon.quote(type) + '}'
		                }
		            }
		            if (props['ms-widget']) {
		                node.template = avalon.vdomAdaptor(node, 'toHTML')

		            }
		            break
		    }
		    var forExpr = props['ms-for']
		    if (forExpr) {
		        delete props['ms-for']
		        var p = stack.last()
		        var arr = p ? p.children : ret
		        arr.splice(arr.length - 1, 0, {
		            nodeType: 8,
		            type: '#comment',
		            nodeValue: 'ms-for:' + forExpr
		        })

		        markeRepeatRange(arr, {
		            nodeType: 8,
		            type: '#comment',
		            nodeValue: 'ms-for-end:'
		        })
		    }
		}

		function markeRepeatRange(nodes, end) {
		    end.dynamic = true
		    end.signature = avalon.makeHashCode('for')
		    var array = [], start, deep = 1
		    while (start = nodes.pop()) {
		        if (start.nodeType === 8) {
		            if (rmsForEnd.test(start.nodeValue)) {
		                ++deep
		            } else if (rmsForStart.test(start.nodeValue)) {
		                --deep
		                if (deep === 0) {
		                    start.nodeValue = start.nodeValue.replace(rfill, fill)        //nomalString(start.nodeValue)
		                    start.signature = end.signature
		                    start.dynamic = 'for'
		                    start.template = array.map(function (a) {
		                        return avalon.vdomAdaptor(a, 'toHTML')
		                    }).join('')
		                    var element = array[0]
		                    if (element.props) {
		                        var cb = element.props['data-for-rendered']
		                        if (cb) {
		                            var wid = cb + ':cb'
		                            if (!avalon.caches[wid]) {
		                                avalon.caches[wid] = Function('return ' + avalon.parseExpr(cb, 'on'))()
		                            }
		                            start.wid = wid
		                        }
		                    }
		                    nodes.push(start, [], end)
		                    break
		                }
		            }
		        }
		        array.unshift(start)
		    }

		}


		function collectNodes(node, stack, ret) {
		    var p = stack.last()
		    if (p) {
		        p.children.push(node)
		    } else {
		        ret.push(node)
		    }
		}

		function collectProps(attrs, props) {
		    attrs.replace(rnowhite, function (prop) {
		        var arr = prop.split('=')
		        var name = arr[0]
		        var value = arr[1] || ''
		        if (name.charAt(0) === ':') {
		            name = 'ms-' + name.slice(1)
		        }
		        if (value) {
		            if (value.indexOf('??') === 0) {
		                value = nomalString(value).
		                        replace(rlineSp, '').
		                        replace(/\"/g, "'").
		                        slice(1, -1)
		            }
		        }
		        if (!(name in props)) {
		            props[name] = value
		        }
		    })

		}
		function nomalString(str) {
		    return avalon.unescapeHTML(str.replace(rfill, fill))
		}

		function clearString(str) {
		    var array = readString(str)
		    for (var i = 0, n = array.length; i < n; i++) {
		        str = str.replace(array[i], dig)
		    }
		    return str
		}
		function readString(str) {
		    var end, s = 0
		    var ret = []
		    for (var i = 0, n = str.length; i < n; i++) {
		        var c = str.charAt(i)
		        if (!end) {
		            if (c === "'") {
		                end = "'"
		                s = i
		            } else if (c === '"') {
		                end = '"'
		                s = i
		            }
		        } else {
		            if (c === '\\') {
		                i += 1
		                continue
		            }
		            if (c === end) {
		                ret.push(str.slice(s, i + 1))
		                end = false
		            }
		        }
		    }
		    return ret
		}

		var rfill = /\?\?\d+/g
		var rlineSp = /\n\s*/g
		var rnowhite = /\S+/g
		var number = 1
		function dig(a) {
		    var key = '??' + number++
		    stringPool[key] = a
		    return key
		}
		function fill(a) {
		    var val = stringPool[a]
		    return val
		}
		//专门用于处理option标签里面的标签
		var rtrimHTML = /<\w+(\s+("[^"]*"|'[^']*'|[^>])+)?>|<\/\w+>/gi
		function trimHTML(v) {
		    return String(v).replace(rtrimHTML, '').trim()
		}

		//如果直接将tr元素写table下面,那么浏览器将将它们(相邻的那几个),放到一个动态创建的tbody底下
		function addTbody(nodes) {
		    var tbody, needAddTbody = false, count = 0, start = 0, n = nodes.length
		    for (var i = 0; i < n; i++) {
		        var node = nodes[i]
		        if (!tbody) {
		            if (node.type === 'tr') {
		                tbody = {
		                    nodeType: 1,
		                    type: 'tbody',
		                    children: [],
		                    props: {}
		                }
		                tbody.children.push(node)
		                needAddTbody = true
		                if (start === 0)
		                    start = i
		                nodes[i] = tbody
		            }
		        } else {
		            if (node.type !== 'tr' && node.nodeType === 1) {
		                tbody = false
		            } else {
		                tbody.children.push(node)
		                count++
		                nodes[i] = 0
		            }
		        }
		    }

		    if (needAddTbody) {
		        for (i = start; i < n; i++) {
		            if (nodes[i] === 0) {
		                nodes.splice(i, 1)
		                i--
		                count--
		                if (count === 0) {
		                    break
		                }
		            }
		        }
		    }
		}



	/***/ },
	/* 68 */
	/***/ function(module, exports) {

		avalon.speedUp = function (arr) {
		    for (var i = 0; i < arr.length; i++) {
		        hasDirective(arr[i])
		    }
		    return arr
		}

		function hasDirective(a) {
		    switch (a.nodeType) {
		        case 3:
		            if (avalon.config.rbind.test(a.nodeValue)) {
		                a.dynamic = 'expr'
		                return true
		            } else {
		                a.skipContent = true
		                return false
		            }
		        case 8:
		            if (a.dynamic) {
		                return true
		            } else {
		                a.skipContent = true
		                return false
		            }
		        case 1:
		            if (a.props['ms-skip']) {
		                a.skipAttrs = true
		                a.skipContent = true
		                return false
		            }
		            if (/^ms\-/.test(a.type) || hasDirectiveAttrs(a.props)) {
		                a.dynamic = true
		            } else {
		                a.skipAttrs = true
		            }
		            if (a.isVoidTag && !a.dynamic) {
		                a.skipContent = true
		                return false
		            }
		            var hasDirective = childrenHasDirective(a.children)
		            if (!hasDirective && !a.dynamic) {
		                a.skipContent = true
		                return false
		            }
		            return true
		        default:
		            if (Array.isArray(a)) {
		                return childrenHasDirective(a)
		            }
		    }
		}

		function childrenHasDirective(arr) {
		    var ret = false
		    for (var i = 0, el; el = arr[i++]; ) {
		        if (hasDirective(el)) {
		            ret = true
		        }
		    }
		    return ret
		}
		var rdirAttr = /^(\:|ms\-)\w/
		function hasDirectiveAttrs(props) {
		    if ('ms-skip' in props)
		        return false
		    for (var i in props) {
		        if (rdirAttr.test(i)) {
		            return true
		        }
		    }
		    return false
		}


	/***/ },
	/* 69 */
	/***/ function(module, exports) {

		/**
		 * ------------------------------------------------------------
		 * diff 对比新旧两个虚拟DOM树,根据directive中的diff方法为新虚拟DOM树
		 * 添加change, afterChange更新钩子
		 * ------------------------------------------------------------
		 */
		var emptyArr = []
		// 防止被引用
		var emptyObj = function () {
		    return {
		        children: [], props: {}
		    }
		}
		var directives = avalon.directives
		var rbinding = /^ms-(\w+)-?(.*)/

		function diff(copys, sources) {
		    for (var i = 0; i < copys.length; i++) {
		        var copy = copys[i]
		        var src = sources[i] || emptyObj()

		        switch (copy.nodeType) {
		            case 3:
		                if (copy.dynamic) {
		                    directives.expr.diff(copy, src)
		                }
		                break
		            case 8:
		                if (copy.dynamic === 'for') {//比较循环区域的元素位置
		                    directives['for'].diff(copy, src, copys, sources, i)
		                } else if (src.afterChange) {
		                    execHooks(src, src.afterChange)
		                }
		                break
		            case 1:
		                if (copy.order) {
		                    diffProps(copys, sources, i)
		                }
		                copy = copys[i]
		                src = sources[i]
		                if (copy.nodeType === 1 && !copy.skipContent && !copy.isVoidTag) {
		                    diff(copy.children, src && src.children || [])
		                }
		                if (src && src.afterChange) {
		                    execHooks(src, src.afterChange)
		                }
		                break
		            default:
		                if (Array.isArray(copy)) {
		                    diff(copy, src)//比较循环区域的内容
		                }
		                break
		        }
		    }
		}

		function execHooks(el, hooks) {
		    if (hooks.length) {
		        for (var hook, i = 0; hook = hooks[i++]; ) {
		            hook(el.dom, el)
		        }
		    }
		    delete el.afterChange
		}

		function diffProps(copys, sources, index) {
		    var order = copys[index].order
		    if (order) {
		        var oldOrder = order
		        try {
		            var arr = order.match(avalon.rword)
		            var checked = {}
		            for(var i = 0; i < arr.length; i++){
		                var name = arr[i]
		                
		                if (checked[name]) {
		                    continue
		                } else {
		                    checked[name] = 1
		                }
		                var match = name.match(rbinding)
		                var type = match && match[1]
		                if (directives[type]) {
		                    directives[type].diff(copys[index], sources[index] || emptyObj(), name, copys, sources, index)
		                }
		                var newOrder = copys[index].order
		                if (!newOrder) {
		                    arr.splice(0, arr.length)
		                } else if (newOrder !== oldOrder) {
		                    arr.push.apply(arr, newOrder.match(avalon.rword))
		                }
		            }

		        } catch (e) {
		            avalon.warn(type, e, e.stack || e.message, 'diffProps error')
		        }
		    }
		}
		avalon.diffProps = diffProps
		module.exports = diff


	/***/ },
	/* 70 */
	/***/ function(module, exports, __webpack_require__) {

		
		/**
		 * ------------------------------------------------------------
		 * batch 同时对N个视图进行全量更新
		 * ------------------------------------------------------------
		 */

		var reconcile = __webpack_require__(39)

		//如果正在更新一个子树,那么将它放到
		var needRenderIds = []
		var renderingID = false
		avalon.suspendUpdate = 0


		function batchUpdate(id) {
		    if (renderingID) {
		        return avalon.Array.ensure(needRenderIds, id)
		    } else {
		        renderingID = id
		    }
		    var scope = avalon.scopes[id]
		    if (!scope || !document.nodeName || avalon.suspendUpdate) {
		        return renderingID = null
		    }
		    var vm = scope.vmodel
		    var dom = vm.$element
		    var source = dom.vtree || []
		    var renderFn = vm.$render
		    var copy = renderFn(scope.vmodel, scope.local)
		    if (scope.isTemp) {
		        //在最开始时,替换作用域的所有节点,确保虚拟DOM与真实DOM是对齐的
		        reconcile([dom], source, dom.parentNode)
		        delete avalon.scopes[id]
		    }
		    avalon.diff(copy, source)


		    var index = needRenderIds.indexOf(renderingID)
		    renderingID = 0
		    if (index > -1) {
		        var removed = needRenderIds.splice(index, 1)
		        return batchUpdate(removed[0])
		    }

		    var more = needRenderIds.shift()
		    if (more) {
		        batchUpdate(more)
		    }
		}



		module.exports = avalon.batch = batchUpdate


	/***/ },
	/* 71 */
	/***/ function(module, exports, __webpack_require__) {

		/*
		 * 本模块是用于将虚拟DOM变成一个函数
		 */

		var extractBindings = __webpack_require__(72)
		var stringify = __webpack_require__(50)
		var parseExpr = __webpack_require__(73)
		var decode = __webpack_require__(16)
		var config = avalon.config
		var quote = avalon.quote
		var rident = /^[$a-zA-Z_][$a-zA-Z0-9_]*$/
		var rstatement = /^\s*var\s+([$\w]+)\s*\=\s*\S+/
		var skips = {__local__: 1, vmode: 1, dom: 1}


		function parseNodes(source, inner) {
		    //ms-important， ms-controller ， ms-for 不可复制，省得死循环
		    //ms-important --> ms-controller --> ms-for --> ms-widget --> ms-effect --> ms-if
		    var buffer = inner ? [] : ['\nvar vnodes = [];']

		    for (var i = 0, el; el = source[i++]; ) {
		        var vnode = parseNode(el)
		        if (el.$prepend) {
		            buffer.push(el.$prepend)
		        }
		        var append = el.$append
		        delete el.$append
		        delete el.$prepend
		        if (vnode) {
		            buffer.push(vnode + '\n')
		        }
		        if (append) {
		            buffer.push(append)
		        }
		    }
		    if (!inner) {
		        buffer.push('return vnodes\n')
		    }
		    return buffer.join('\n')
		}



		function parseNode(vdom) {
		    switch (vdom.nodeType) {
		        case 3:
		            if (config.rexpr.test(vdom.nodeValue) && !vdom.skipContent ) {
		                return add(parseText(vdom))
		            } else {
		                return add(createCachedNode(vdom))
		            }
		        case 1:

		            if (vdom.skipContent && vdom.skipAttrs) {
		                return add(createCachedNode(vdom))
		            }
		            var copy = {
		                props: {},
		                type: vdom.type,
		                nodeType: 1
		            }
		            var bindings = extractBindings(copy, vdom.props)
		            var order = bindings.map(function (b) {
		                //将ms-*的值变成函数,并赋给copy.props[ms-*]
		                //如果涉及到修改结构,则在source添加$append,$prepend
		                avalon.directives[b.type].parse(copy, vdom, b)
		                return b.name
		            }).join(',')
		            if (order) {
		                copy.order = order
		            }
		            if (vdom.isVoidTag) {
		                copy.isVoidTag = true
		            } else {
		                if (!('children' in copy)) {
		                    var c = vdom.children
		                    if (c.length) {
		                        copy.children = '(function(){' + parseNodes(c) + '})()'
		                    } else {
		                        copy.children = '[]'
		                    }
		                }
		            }
		            if (vdom.template)
		                copy.template = vdom.template
		            if (vdom.skipContent)
		                copy.skipContent = true
		            if (vdom.skipAttrs) {
		                copy.skipAttrs = true
		            }
		            if (vdom.dynamic) {
		                copy.dynamic = true
		            }
		            return addTag(copy)
		        case 8:
		            var nodeValue = vdom.nodeValue
		            if (vdom.dynamic === 'for') {// 处理ms-for指令
		                if (nodeValue.indexOf('ms-for:') !== 0) {
		                    avalon.error('ms-for指令前不能有空格')
		                }
		               
		                var copy = {
		                    dynamic: 'for',
		                    vmodel: '__vmodel__'
		                }
		                for (var i in vdom) {
		                    if (vdom.hasOwnProperty(i) && !skips[i]) {
		                        copy[i] = vdom[i]
		                    }
		                }

		                avalon.directives['for'].parse(copy, vdom, vdom)
		                vdom.$append += parseNodes(avalon.speedUp(avalon.lexer(vdom.template)),true)
		                return addTag(copy) 
		            } else if (nodeValue === 'ms-for-end:') {
		              
		                vdom.$append = addTag({
		                    nodeType: 8,
		                    type: '#comment',
		                    nodeValue: vdom.signature,
		                    key: 'traceKey'
		                }) + '\n},__local__,vnodes)\n' +
		                        addTag({
		                            nodeType: 8,
		                            type: "#comment",
		                            signature: vdom.signature,
		                            nodeValue: "ms-for-end:"
		                        }) + '\n'
		                return ''

		            } else if (nodeValue.indexOf('ms-js:') === 0) {//插入JS声明语句
		                var statement = parseExpr(nodeValue.replace('ms-js:', ''), 'js') + '\n'
		                var ret = addTag(vdom)
		                var match = statement.match(rstatement)
		                if (match && match[1]) {
		                    vdom.$append = (vdom.$append || '') + statement +
		                            "\n__local__." + match[1] + ' = ' + match[1] + '\n'
		                } else {
		                    avalon.warn(nodeValue + ' parse fail!')
		                }
		                return ret
		            } else if(vdom.dynamic){
		                return addTag(vdom)
		            }else{
		                return add(createCachedNode(vdom))
		            }
		   //     default:
		//            if (Array.isArray(vdom)) {
		//                console.log(vdom)
		//                vdom.$append = parseNodes(vdom, true)
		//            }
		    }

		}

		module.exports = parseNodes

		function wrapDelimiter(expr) {
		    return rident.test(expr) ? expr : parseExpr(expr, 'text')
		}

		function add(a) {
		    return 'vnodes.push(' + a + ');'
		}
		function addTag(obj) {
		    return add(stringify(obj))
		}

		function parseText(el) {
		    var array = extractExpr(el.nodeValue)//返回一个数组
		    var nodeValue = ''
		    if (array.length === 1) {
		        nodeValue = wrapDelimiter(array[0].expr)
		    } else {
		        var token = array.map(function (el) {
		            return el.type ? wrapDelimiter(el.expr) : quote(el.expr)
		        }).join(' + ')
		        nodeValue = 'String(' + token + ')'
		    }
		    return '{\ntype: "#text",\nnodeType:3,\ndynamic:true,\nnodeValue: ' + nodeValue + '\n}'
		}

		var rlineSp = /\n\s*/g

		function extractExpr(str) {
		    var ret = []
		    do {//aaa{{@bbb}}ccc
		        var index = str.indexOf(config.openTag)
		        index = index === -1 ? str.length : index
		        var value = str.slice(0, index)
		        if (/\S/.test(value)) {
		            ret.push({expr: decode(value)})
		        }
		        str = str.slice(index + config.openTag.length)
		        if (str) {
		            index = str.indexOf(config.closeTag)
		            var value = str.slice(0, index)
		            ret.push({
		                expr: avalon.unescapeHTML(value.replace(rlineSp, '')),
		                type: '{{}}'
		            })
		            str = str.slice(index + config.closeTag.length)
		        }
		    } while (str.length)
		    return ret
		}

		function createCachedNode(vdom) {
		    var uuid
		    switch (vdom.nodeType) {
		        case 1:
		            uuid = vdom.type + ';' + Object.keys(vdom.props).sort().map(function (k) {
		                return k + '-' + vdom.props[k]
		            }).join(';') + ';' + avalon.vdomAdaptor(vdom, 'toHTML').length
		            break
		        case 3:
		        case 8:
		            uuid = vdom.nodeType + ';' + vdom.nodeValue
		            break
		    }

		    avalon.caches[uuid] = vdom

		    return 'avalon.getCachedNode(' + quote(uuid) + ')'
		}

		avalon.getCachedNode = function (uuid) {
		    return avalon.caches[uuid]
		}

	/***/ },
	/* 72 */
	/***/ function(module, exports) {

		var directives = avalon.directives
		var rbinding = /^ms-(\w+)-?(.*)/
		var eventMap = avalon.oneObject('animationend,blur,change,input,click,dblclick,focus,keydown,keypress,keyup,mousedown,mouseenter,mouseleave,mousemove,mouseout,mouseover,mouseup,scan,scroll,submit')

		function extractBindings(cur, props) {
		    var bindings = []
		    var skip = 'ms-skip' in props
		    var uniq = {}
		    for (var i in props) {
		        var value = props[i], match

		        if (!skip && (match = i.match(rbinding))) {
		            var type = match[1]
		            var param = match[2] || ''
		            var name = i
		            if (eventMap[type]) {
		                var order = parseFloat(param) || 0
		                param = type
		                type = 'on'
		            }
		            name = 'ms-' + type + (param ? '-' + param : '')
		            if (i !== name) {
		                delete props[i]
		                props[name] = value
		            }
		            if (directives[type]) {

		                var binding = {
		                    type: type,
		                    param: param,
		                    name: name,
		                    expr: value,
		                    priority: directives[type].priority || type.charCodeAt(0) * 100
		                }
		                if (type === 'on') {
		                    order = order || 0
		                    binding.name += '-' + order
		                    binding.priority = param.charCodeAt(0) * 100 + order
		                }
		                if (!uniq[binding.name]) {
		                    uniq[binding.name] = 1
		                    bindings.push(binding)
		                }
		            }
		        } else {
		            cur.props[i] = props[i]
		        }
		    }
		    bindings.sort(byPriority)

		    return bindings
		}

		function byPriority(a, b) {
		    return a.priority - b.priority
		}

		module.exports = extractBindings


	/***/ },
	/* 73 */
	/***/ function(module, exports, __webpack_require__) {

		

		//缓存求值函数，以便多次利用
		var evaluatorPool = __webpack_require__(49)

		var rregexp = /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/g
		var rstring = /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/g
		var rfill = /\?\?\d+/g
		var brackets = /\(([^)]*)\)/

		var rshortCircuit = /\|\|/g
		var rpipeline = /\|(?=\w)/
		var ruselessSp = /\s*(\.|\|)\s*/g

		var rAt = /(^|[^\w\u00c0-\uFFFF_])(@|##)(?=[$\w])/g
		var rhandleName = /^(?:\@|##)[$\w\.]+$/i

		var rfilters = /\|.+/g
		var rvar = /((?:\@|\$|\#\#)?\w+)/g

		function collectLocal(str, ret) {
		    var arr = str.replace(rfilters, '').match(rvar)
		    if (arr) {
		        arr.filter(function (el) {
		            if (!/^[@\d\-]/.test(el) &&
		                    el.slice(0, 2) !== '##' &&
		                    el !== '$event' && !avalon.keyMap[el]) {
		                ret[el] = 1
		            }
		        })
		    }
		}

		function extLocal(ret) {
		    var arr = []
		    for (var i in ret) {
		        arr.push('var ' + i + ' = __local__[' + avalon.quote(i) + ']')
		    }
		    return arr
		}

		function parseExpr(str, category) {
		    var binding = {}
		    category = category || 'other'
		    if (typeof str === 'object') {
		        category = str.type
		        binding = str
		        str = binding.expr
		    }
		    if (typeof str !== 'string')
		        return ''
		    var cacheID = str
		    var cacheStr = evaluatorPool.get(category + ':' + cacheID)

		    if (cacheStr) {
		        return cacheStr
		    }

		    var number = 1
		//相同的表达式生成相同的函数
		    var maps = {}
		    function dig(a) {
		        var key = '??' + number++
		        maps[key] = a
		        return key
		    }

		    function fill(a) {
		        return maps[a]
		    }

		    var input = str.replace(rregexp, dig).//移除所有正则
		            replace(rstring, dig).//移除所有字符串
		            
		   // input = avalon.unescapeHTML(input).
		            replace(rshortCircuit, dig).//移除所有短路或
		            replace(ruselessSp, '$1').//移除. |两端空白
		            split(rpipeline) //使用管道符分离所有过滤器及表达式的正体
		    //还原body
		    var _body = input.shift()
		    var local = {}
		    var body = _body.replace(rfill, fill).trim()
		    if (category === 'on' && rhandleName.test(body)) {
		        body = body + '($event)'
		    }

		    body = body.replace(rAt, '$1__vmodel__.')
		    if (category === 'js') {
		        return evaluatorPool.put(category + ':' + cacheID, body)
		    } else if (category === 'on') {
		        collectLocal(_body, local)
		    }

		//处理表达式的过滤器部分

		    var filters = input.map(function (str) {
		        collectLocal(str.replace(/^\w+/g, ""), local)
		        str = str.replace(rfill, fill).replace(rAt, '$1__vmodel__.') //还原
		        var hasBracket = false
		        str = str.replace(brackets, function (a, b) {
		            hasBracket = true
		            return /\S/.test(b) ?
		                    '(__value__,' + b + ');' :
		                    '(__value__);'
		        })
		        if (!hasBracket) {
		            str += '(__value__);'
		        }
		        str = str.replace(/(\w+)/, 'avalon.__format__("$1")')
		        return '__value__ = ' + str
		    })
		    var ret = []
		    if (category === 'on') {
		        filters = filters.map(function (el) {
		            return el.replace(/__value__/g, '$event')
		        })
		        if (filters.length) {
		            filters.push('if($event.$return){\n\treturn;\n}')
		        }
		        if (!avalon.modern) {
		            body = body.replace(/__vmodel__\.([^(]+)\(([^)]*)\)/, function (a, b, c) {
		                return '__vmodel__.' + b + ".call(__vmodel__" + (/\S/.test(c) ? ',' + c : "") + ")"
		            })
		        }

		        ret = ['function ms_on($event, __local__){',
		            'try{',
		            extLocal(local).join('\n'),
		            '\tvar __vmodel__ = this;',
		            '\t' + body,
		            '}catch(e){',
		            quoteError(str, category),
		            '}',
		            '}']
		        filters.unshift(2, 0)
		    } else if (category === 'duplex') {

		//从vm中得到当前属性的值
		        var getterBody = [
		            'function (__vmodel__){',
		            'try{',
		            'return ' + body + '\n',
		            '}catch(e){',
		            quoteError(str, category).replace('parse', 'get'),
		            '}',
		            '}']
		        evaluatorPool.put('duplex:' + cacheID, getterBody.join('\n'))
		        //给vm同步某个属性
		        var setterBody = [
		            'function (__vmodel__,__value__){',
		            'try{',
		            '\t' + body + ' = __value__',
		            '}catch(e){',
		            quoteError(str, category).replace('parse', 'set'),
		            '}',
		            '}']
		        evaluatorPool.put('duplex:set:' + cacheID, setterBody.join('\n'))
		        //对某个值进行格式化
		        if (input.length) {
		            var formatBody = [
		                'function (__vmodel__, __value__){',
		                'try{',
		                filters.join('\n'),
		                'return __value__\n',
		                '}catch(e){',
		                quoteError(str, category).replace('parse', 'format'),
		                '}',
		                '}']
		            evaluatorPool.put('duplex:format:' + cacheID, formatBody.join('\n'))
		        }
		        return  evaluatorPool.get('duplex:' + cacheID)
		    } else {
		        ret = [
		            '(function(){',
		            'try{',
		            'var __value__ = ' + body,
		            (category === 'text' ?
		                    'return avalon.parsers.string(__value__)' :
		                    'return __value__'),
		            '}catch(e){',
		            quoteError(str, category),
		            '\treturn ""',
		            '}',
		            '})()'
		        ]
		        filters.unshift(3, 0)
		    }
		    ret.splice.apply(ret, filters)
		    cacheStr = ret.join('\n')
		    evaluatorPool.put(category + ':' + cacheID, cacheStr)
		    return cacheStr

		}

		function quoteError(str, type) {
		    return '\tavalon.warn(e, ' +
		            avalon.quote('parse ' + type + ' binding【 ' + str + ' 】fail')
		            + ')'
		}

		module.exports = avalon.parseExpr = parseExpr




	/***/ },
	/* 74 */,
	/* 75 */
	/***/ function(module, exports) {

		function inDomTree(el) {
		    while (el) {
		        if (el.nodeType === 9) {
		            return true
		        }
		        el = el.parentNode
		    }
		    return false
		}

		function fireDisposeHook(el) {
		    if (el.nodeType === 1 && el.getAttribute('wid') && !inDomTree(el)) {
		        var wid = el.getAttribute('wid')
		        var docker = avalon.scopes[ wid ]
		        if (!docker)
		            return
		        var vm = docker.vmodel
		        docker.vmodel.$fire("onDispose", {
		            type: 'dispose',
		            target: el,
		            vmodel: vm
		        })
		        if (docker && !el.getAttribute('cached')) {
		            delete docker.vmodel
		            delete avalon.scopes[ wid ]
		            var is = el.getAttribute('is')
		            var v = el.vtree
		            detachEvents(v)
		            if (v) {
		                v[0][is + '-mount'] = false
		                v[0]['component-ready:' + is] = false
		            }
		        }
		        return false
		    }
		}
		function detachEvents(arr) {
		    for (var i in arr) {
		        var el = arr[i]
		        if (el.nodeType === 1) {
		            for (var i in el) {
		                if (i.indexOf('ms-on') === 0) {
		                    delete el[i]
		                }
		            }
		            if (el.children) {
		                detachEvents(el.children)
		            }
		        }
		    }
		}
		function fireDisposeHookDelay(a) {
		    setTimeout(function () {
		        fireDisposeHook(a)
		    }, 4)
		}
		function fireDisposeHooks(nodes) {
		    for (var i = 0, el; el = nodes[i++]; ) {
		        fireDisposeHook(el)
		    }
		}
		module.exports = {
		    fireDisposeHookDelay: fireDisposeHookDelay,
		    fireDisposeHooks: fireDisposeHooks,
		    fireDisposeHook: fireDisposeHook
		}

	/***/ },
	/* 76 */,
	/* 77 */,
	/* 78 */
	/***/ function(module, exports, __webpack_require__) {

		
		var $$midway = {}
		var $$skipArray = __webpack_require__(63)
		var dispatch = __webpack_require__(79)
		var $emit = dispatch.$emit
		var $watch = dispatch.$watch
		/*
		 * initEvents
		 * isSkip
		 * modelAdaptor
		 * makeAccessor
		 */

		function initEvents($vmodel, heirloom) {
		    heirloom.__vmodel__ = $vmodel
		    var hide = $$midway.hideProperty

		    hide($vmodel, '$events', heirloom)
		    hide($vmodel, '$watch', function () {
		        if (arguments.length === 2) {
		            return $watch.apply($vmodel, arguments)
		        } else {
		            throw '$watch方法参数不对'
		        }
		    })
		    hide($vmodel, '$fire', function (expr, a, b) {
		        var list = $vmodel.$events[expr]
		        $emit(list, $vmodel, expr, a, b)
		    })
		}

		var rskip = /function|window|date|regexp|element/i

		function isSkip(key, value, skipArray) {
		    // 判定此属性能否转换访问器
		    return key.charAt(0) === '$' ||
		            skipArray[key] ||
		            (rskip.test(avalon.type(value))) ||
		            (value && value.nodeName && value.nodeType > 0)
		}

		function modelAdaptor(definition, old, heirloom, options) {
		    //如果数组转换为监控数组
		    if (Array.isArray(definition)) {
		        return $$midway.arrayFactory(definition, old, heirloom, options)
		    } else if (Object(definition) === definition && typeof definition !== 'function') {
		        //如果此属性原来就是一个VM,拆分里面的访问器属性
		        if (old && old.$id) {
		            ++avalon.suspendUpdate
		            //1.5带来的优化方案
		            if (old.$track !== Object.keys(definition).sort().join(';;')) {
		                var vm = $$midway.slaveFactory(old, definition, heirloom, options)
		            } else {
		                vm = old
		            }
		            for (var i in definition) {
		                if ($$skipArray[i])
		                    continue
		                vm[i] = definition[i]
		            }
		            --avalon.suspendUpdate
		            return vm
		        } else {
		            vm = $$midway.masterFactory(definition, heirloom, options)
		            return vm
		        }
		    } else {
		        return definition
		    }
		}
		$$midway.modelAdaptor = modelAdaptor


		function makeAccessor(sid, spath, heirloom) {
		    var old = NaN
		    function get() {
		        return old
		    }
		    get.heirloom = heirloom
		    return {
		        get: get,
		        set: function (val) {
		            if (old === val) {
		                return
		            }
		            var vm = heirloom.__vmodel__
		            if (val && typeof val === 'object') {
		                val = $$midway.modelAdaptor(val, old, heirloom, {
		                    pathname: spath,
		                    id: sid
		                })
		            }
		            var older = old
		            old = val
		            if (this.$hashcode && vm ) {
		                vm.$events.$$dirty$$ = true
		                if(vm.$events.$$wait$$)
		                    return
		                //★★确保切换到新的events中(这个events可能是来自oldProxy)               
		                if (heirloom !== vm.$events) {
		                    get.heirloom = vm.$events
		                }
		               
		                //如果这个属性是组件配置对象中的属性,那么它需要触发组件的回调
		                emitWidget(get.$decompose, spath, val, older)
		                //触发普通属性的回调
		                if (spath.indexOf('*') === -1) {
		                    $emit(get.heirloom[spath], vm, spath, val, older)
		                }
		                //如果这个属性是数组元素上的属性
		                emitArray(sid+'', vm, spath, val, older)
		                //如果这个属性存在通配符
		                emitWildcard(get.heirloom, vm, spath, val, older)
		                vm.$events.$$dirty$$ = false
		                batchUpdateView(vm.$id)
		            }
		        },
		        enumerable: true,
		        configurable: true
		    }
		}

		function batchUpdateView(id) {
		    avalon.rerenderStart = new Date
		    var dotIndex = id.indexOf('.')
		    if (dotIndex > 0) {
		        avalon.batch(id.slice(0, dotIndex))
		    } else {
		        avalon.batch(id)
		    }
		}

		var rtopsub = /([^.]+)\.(.+)/
		function emitArray(sid, vm, spath, val, older) {
		    if (sid.indexOf('.*.') > 0) {
		        var arr = sid.match(rtopsub)
		        var top = avalon.vmodels[ arr[1] ]
		        if (top) {
		            var path = arr[2]
		            $emit(top.$events[ path ], vm, spath, val, older)
		        }
		    }
		}

		function emitWidget(whole, spath, val, older) {
		    if (whole && whole[spath]) {
		        var wvm = whole[spath]
		        if (!wvm.$hashcode) {
		            delete whole[spath]
		        } else {
		            var wpath = spath.replace(/^[^.]+\./, '')
		            if (wpath !== spath) {
		                $emit(wvm.$events[wpath], wvm, wpath, val, older)
		            }
		        }
		    }
		}

		function emitWildcard(obj, vm, spath, val, older) {
		    if (obj.__fuzzy__) {
		        obj.__fuzzy__.replace(avalon.rword, function (expr) {
		            var list = obj[expr]
		            var reg = list.reg
		            if (reg && reg.test(spath)) {
		                $emit(list, vm, spath, val, older)
		            }
		            return expr
		        })
		    }
		}


		function define(definition) {
		    var $id = definition.$id
		    if (!$id && avalon.config.debug) {
		        avalon.warn('vm.$id must be specified')
		    }
		    if (avalon.vmodels[$id]) {
		        throw Error('error:[' + $id + '] had defined!')
		    }
		    var vm = $$midway.masterFactory(definition, {}, {
		        pathname: '',
		        id: $id,
		        master: true
		    })

		    return avalon.vmodels[$id] = vm

		}

		function arrayFactory(array, old, heirloom, options) {
		    if (old && old.splice) {
		        var args = [0, old.length].concat(array)
		        ++avalon.suspendUpdate
		        old.splice.apply(old, args)
		        --avalon.suspendUpdate
		        return old
		    } else {
		        for (var i in __array__) {
		            array[i] = __array__[i]
		        }

		        array.notify = function (a, b, c, d) {
		            var vm = heirloom.__vmodel__
		            if (vm) {
		                var path = a === null || a === void 0 ?
		                        options.pathname :
		                        options.pathname + '.' + a
		                vm.$fire(path, b, c)
		                if (!d && !heirloom.$$wait$$ && !avalon.suspendUpdate ) {
		                    batchUpdateView(vm.$id)
		                }
		            }
		        }

		        var hashcode = avalon.makeHashCode('$')
		        options.array = true
		        options.hashcode = hashcode
		        options.id = options.id || hashcode
		        $$midway.initViewModel(array, heirloom, {}, {}, options)

		        for (var j = 0, n = array.length; j < n; j++) {
		            array[j] = modelAdaptor(array[j], 0, {}, {
		                id: array.$id + '.*',
		                master: true
		            })
		        }
		        return array
		    }
		}
		$$midway.arrayFactory = arrayFactory

		var __array__ = {
		    set: function (index, val) {
		        if (((index >>> 0) === index) && this[index] !== val) {
		            if (index > this.length) {
		                throw Error(index + 'set方法的第一个参数不能大于原数组长度')
		            }
		            this.splice(index, 1, val)
		        }
		    },
		    contains: function (el) { //判定是否包含
		        return this.indexOf(el) !== -1
		    },
		    ensure: function (el) {
		        if (!this.contains(el)) { //只有不存在才push
		            this.push(el)
		        }
		        return this
		    },
		    pushArray: function (arr) {
		        return this.push.apply(this, arr)
		    },
		    remove: function (el) { //移除第一个等于给定值的元素
		        return this.removeAt(this.indexOf(el))
		    },
		    removeAt: function (index) { //移除指定索引上的元素
		        if ((index >>> 0) === index) {
		            return this.splice(index, 1)
		        }
		        return []
		    },
		    clear: function () {
		        this.removeAll()
		        return this
		    }
		}
		avalon.define = define

		module.exports = {
		    $$midway: $$midway,
		    $$skipArray: $$skipArray,
		    isSkip: isSkip,
		    __array__: __array__,
		    initEvents: initEvents,
		    makeAccessor: makeAccessor,
		    modelAdaptor: modelAdaptor
		}

	/***/ },
	/* 79 */
	/***/ function(module, exports) {

		
		/**
		 * ------------------------------------------------------------
		 * 属性监听系统 
		 * ------------------------------------------------------------
		 */

		function adjustVm(vm, expr) {
		    var toppath = expr.split(".")[0], other
		    try {
		        if (vm.hasOwnProperty(toppath)) {
		            if (vm.$accessors) {
		                other = vm.$accessors[toppath].get.heirloom.__vmodel__
		            } else {
		                other = Object.getOwnPropertyDescriptor(vm, toppath).get.heirloom.__vmodel__
		            }

		        }
		    } catch (e) {
		    }
		    return other || vm
		}

		function toRegExp(expr) {
		    var arr = expr.split('.')
		    return new RegExp("^" + arr.map(function (el) {
		        return el === '*' ? '(?:[^.]+)' : el
		    }).join('\\.') + '$', 'i')
		}
		function addFuzzy(add, obj, expr) {
		    if (add) {
		        if (obj.__fuzzy__) {
		            if (obj.__fuzzy__.indexOf(',' + expr) === -1) {
		                obj.__fuzzy__ += ',' + expr
		            }
		        } else {
		            obj.__fuzzy__ = expr
		        }
		    }
		}

		function $watch(expr, callback) {
		    var fuzzy = expr.indexOf('.*') > 0 || expr === '*'
		    var vm = fuzzy ? this : $watch.adjust(this, expr)
		    var hive = this.$events
		    var list = hive[expr] || (hive[expr] = [])
		    if (fuzzy) {
		        list.reg = list.reg || toRegExp(expr)
		    }
		    addFuzzy(fuzzy, hive, expr)
		    if (vm !== this) {
		        addFuzzy(fuzzy, this.$events, expr)
		    }

		    avalon.Array.ensure(list, callback)

		    return function () {
		        avalon.Array.remove(list, callback)
		    }
		}

		$watch.adjust = adjustVm
		/**
		 * $fire 方法的内部实现
		 * 
		 * @param {Array} list 订阅者数组
		 * @param {Component} vm
		 * @param {String} path 监听属性名或路径
		 * @param {Any} a 当前值 
		 * @param {Any} b 过去值
		 * @param {Number} i 如果抛错,让下一个继续执行
		 * @returns {undefined}
		 */
		function $emit(list, vm, path, a, b, i) {
		    if (list && list.length) {
		        try {
		            for (i = i || list.length - 1; i >= 0; i--) {
		                var callback = list[i]
		                callback.call(vm, a, b, path)
		            }
		        } catch (e) {
		            if (i - 1 > 0)
		                $emit(list, vm, path, a, b, i - 1)
		            avalon.log(e, path)
		        }

		    }
		}


		module.exports = {
		    $emit: $emit,
		    $watch: $watch,
		    adjustVm: adjustVm
		}


	/***/ },
	/* 80 */,
	/* 81 */,
	/* 82 */
	/***/ function(module, exports, __webpack_require__) {

		
		var avalon = __webpack_require__(3)
		var browser = __webpack_require__(4)

		avalon.shadowCopy(avalon, browser)

		__webpack_require__(83)
		__webpack_require__(6)
		__webpack_require__(7)

		module.exports = avalon

	/***/ },
	/* 83 */
	/***/ function(module, exports) {

		//这里放置存在异议的方法

		var serialize = avalon.inspect
		var rwindow = /^\[object (?:Window|DOMWindow|global)\]$/
		var rarraylike = /(Array|List|Collection|Map|Arguments)\]$/

		avalon.quote = JSON.stringify

		// avalon.type
		var class2type = {}
		'Boolean Number String Function Array Date RegExp Object Error'.replace(avalon.rword, function (name) {
		    class2type['[object ' + name + ']'] = name.toLowerCase()
		})

		avalon.type = function (obj) { //取得目标的类型
		    if (obj == null) {
		        return String(obj)
		    }
		    // 早期的webkit内核浏览器实现了已废弃的ecma262v4标准，可以将正则字面量当作函数使用，因此typeof在判定正则时会返回function
		    return typeof obj === 'object' || typeof obj === 'function' ?
		            class2type[serialize.call(obj)] || 'object' :
		            typeof obj
		}


		avalon.isFunction = function (fn) {
		    return typeof fn === 'function'
		}

		avalon.isWindow = function (obj) {
		    return rwindow.test(serialize.call(obj))
		}


		/*判定是否是一个朴素的javascript对象（Object），不是DOM对象，不是BOM对象，不是自定义类的实例*/
		avalon.isPlainObject = function (obj) {
		    // 简单的 typeof obj === 'object'检测，会致使用isPlainObject(window)在opera下通不过
		    return serialize.call(obj) === '[object Object]' &&
		            Object.getPrototypeOf(obj) === Object.prototype
		}

		//与jQuery.extend方法，可用于浅拷贝，深拷贝
		avalon.mix = avalon.fn.mix = function () {
		    var options, name, src, copy, copyIsArray, clone,
		            target = arguments[0] || {},
		            i = 1,
		            length = arguments.length,
		            deep = false

		    // 如果第一个参数为布尔,判定是否深拷贝
		    if (typeof target === 'boolean') {
		        deep = target
		        target = arguments[1] || {}
		        i++
		    }

		    //确保接受方为一个复杂的数据类型
		    if (typeof target !== 'object' && typeof target !== 'function') {
		        target = {}
		    }

		    //如果只有一个参数，那么新成员添加于mix所在的对象上
		    if (i === length) {
		        target = this
		        i--
		    }

		    for (; i < length; i++) {
		        //只处理非空参数
		        if ((options = arguments[i]) != null) {
		            for (name in options) {
		                src = target[name]
		                try {
		                    copy = options[name] //当options为VBS对象时报错
		                } catch (e) {
		                    continue
		                }

		                // 防止环引用
		                if (target === copy) {
		                    continue
		                }
		                if (deep && copy && (avalon.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {

		                    if (copyIsArray) {
		                        copyIsArray = false
		                        clone = src && Array.isArray(src) ? src : []

		                    } else {
		                        clone = src && avalon.isPlainObject(src) ? src : {}
		                    }

		                    target[name] = avalon.mix(deep, clone, copy)
		                } else if (copy !== void 0) {
		                    target[name] = copy
		                }
		            }
		        }
		    }
		    return target
		}

		/*判定是否类数组，如节点集合，纯数组，arguments与拥有非负整数的length属性的纯JS对象*/
		function isArrayLike(obj) {
		    if (obj && typeof obj === 'object') {
		        var n = obj.length,
		                str = serialize.call(obj)
		        if (rarraylike.test(str)) {
		            return true
		        } else if (str === '[object Object]' && n === (n >>> 0)) {
		            return true //由于ecma262v5能修改对象属性的enumerable，因此不能用propertyIsEnumerable来判定了
		        }
		    }
		    return false
		}


		avalon.each = function (obj, fn) {
		    if (obj) { //排除null, undefined
		        var i = 0
		        if (isArrayLike(obj)) {
		            for (var n = obj.length; i < n; i++) {
		                if (fn(i, obj[i]) === false)
		                    break
		            }
		        } else {
		            for (i in obj) {
		                if (obj.hasOwnProperty(i) && fn(i, obj[i]) === false) {
		                    break
		                }
		            }
		        }
		    }
		}

		module.exports = {
		    avalon: avalon,
		    isArrayLike: isArrayLike
		}




	/***/ },
	/* 84 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * 虚拟DOM的3大构造器
		 */
		var VText = __webpack_require__(15)
		var VComment = __webpack_require__(17)
		var VElement = __webpack_require__(85)

		avalon.vdomAdaptor = function (obj, method) {
		    if (!obj) {//obj在ms-for循环里面可能是null
		        return (method === "toHTML" ? '' :
		            avalon.avalonFragment.cloneNode(false))
		    }
		    switch (obj.nodeType) {
		        case 3:
		            return VText.prototype[method].call(obj)
		        case 8:
		            return VComment.prototype[method].call(obj)
		        case 1:
		            return VElement.prototype[method].call(obj)
		        default:
		            if (Array.isArray(obj)) {
		                if (method === "toHTML") {
		                    return obj.map(function (a) {
		                        return avalon.vdomAdaptor(a, 'toHTML')
		                    }).join('')
		                } else {
		                    var f = avalon.avalonFragment.cloneNode(false)
		                    obj.forEach(function (a) {
		                        f.appendChild(avalon.vdomAdaptor(a, 'toDOM'))
		                    })
		                    return f
		                }
		            }
		    }
		}

		module.exports = {
		    VText: VText,
		    VComment: VComment,
		    VElement: VElement
		}


	/***/ },
	/* 85 */
	/***/ function(module, exports) {

		
		function VElement(type, props, children) {
		    if (typeof type === 'object') {
		        for (var i in type) {
		            this[i] = type[i]
		        }
		    } else {
		        this.nodeType = 1
		        this.type = type
		        this.props = props
		        this.children = children
		    }
		}
		function skipFalseAndFunction(a) {
		    return a !== false && (Object(a) !== a)
		}


		function createSVG(type) {
		    return document.createElementNS('http://www.w3.org/2000/svg', type)
		}
		var svgTags = avalon.oneObject('circle,defs,ellipse,image,line,' +
		        'path,polygon,polyline,rect,symbol,text,use,g,svg')


		var rvml = /^\w+\:\w+/
		var supportTemplate = 'content' in document.createElement('template')
		VElement.prototype = {
		    constructor: VElement,
		    toDOM: function () {
		        var dom, tagName = this.type
		        if (avalon.modern && svgTags[tagName]) {
		            dom = createSVG(tagName)
		        } else {
		            dom = document.createElement(tagName)
		        }
		        var wid = this.props['ms-important'] ||
		                this.props['ms-controller'] || this.wid
		        if (wid) {
		            var scope = avalon.scopes[wid]
		            var element = scope && scope.vmodel && scope.vmodel.$element
		            if (element) {
		                var oldVdom = element.vtree[0]
		                if (oldVdom.children) {
		                    this.children = oldVdom.children
		                }
		                return element
		            }
		        }
		        for (var i in this.props) {
		            var val = this.props[i]
		            if (skipFalseAndFunction(val)) {
		                dom.setAttribute(i, val + '')
		            }
		        }
		        var c = this.children || []
		        var template = c[0] ? c[0].nodeValue : ''
		        switch (this.type) {
		            case 'xmp':
		            case 'script':
		            case 'style':
		            case 'noscript':
		                dom.innerHTML = template
		                break
		            case 'template':
		                if (supportTemplate) {
		                    dom.innerHTML = template
		                } else {
		                    dom.textContent = template
		                }
		                break
		            default:
		                if (!this.isVoidTag) {
		                    this.children.forEach(function (c) {
		                        c && dom.appendChild(avalon.vdomAdaptor(c, 'toDOM'))
		                    })
		                }
		                break
		        }
		        return dom
		    },
		    toHTML: function () {
		        var arr = []
		        for (var i in this.props) {
		            var val = this.props[i]
		            if (skipFalseAndFunction(val)) {
		                arr.push(i + '=' + avalon.quote(this.props[i] + ''))
		            }
		        }
		        arr = arr.length ? ' ' + arr.join(' ') : ''
		        var str = '<' + this.type + arr
		        if (this.isVoidTag) {
		            return str + '/>'
		        }
		        str += '>'
		        if (this.children.length) {
		            str += this.children.map(function (c) {
		                return c ? avalon.vdomAdaptor(c, 'toHTML') : ''
		            }).join('')
		        }
		        return str + '</' + this.type + '>'
		    }
		}

		module.exports = VElement

	/***/ },
	/* 86 */
	/***/ function(module, exports, __webpack_require__) {

		
		/*********************************************************************
		 *                          DOM Api                                 *
		 *           shim,class,data,css,val,html,event,ready               *
		 **********************************************************************/

		__webpack_require__(87)
		__webpack_require__(88)
		__webpack_require__(89)
		__webpack_require__(90)
		__webpack_require__(91)
		__webpack_require__(27)
		__webpack_require__(92)
		__webpack_require__(93)

		module.exports = avalon


	/***/ },
	/* 87 */
	/***/ function(module, exports) {

		//safari5+是把contains方法放在Element.prototype上而不是Node.prototype
		if (!avalon.document.contains) {
		    Node.prototype.contains = function (arg) {
		        return !!(this.compareDocumentPosition(arg) & 16)
		    }
		}
		avalon.contains = function (root, el) {
		    try {
		        while ((el = el.parentNode))
		            if (el === root)
		                return true
		        return false
		    } catch (e) {
		        return false
		    }
		}





	/***/ },
	/* 88 */
	/***/ function(module, exports) {

		var rnowhite = /\S+/g

		'add,remove'.replace(avalon.rword, function (method) {
		    avalon.fn[method + 'Class'] = function (cls) {
		        var el = this[0] || {}
		        //https://developer.mozilla.org/zh-CN/docs/Mozilla/Firefox/Releases/26
		        if (cls && typeof cls === 'string' && el.nodeType === 1) {
		            cls.replace(rnowhite, function (c) {
		                el.classList[method](c)
		            })
		        }
		        return this
		    }
		})

		avalon.fn.mix({
		    hasClass: function (cls) {
		        var el = this[0] || {}
		        //IE10+, chrome8+, firefox3.6+, safari5.1+,opera11.5+支持classList,
		        //chrome24+,firefox26+支持classList2.0
		        return el.nodeType === 1 && el.classList.contains(cls)
		    },
		    toggleClass: function (value, stateVal) {
		        var isBool = typeof stateVal === 'boolean'
		        var me = this
		        String(value).replace(rnowhite, function (c) {
		            var state = isBool ? stateVal : !me.hasClass(c)
		            me[state ? 'addClass' : 'removeClass'](c)
		        })
		        return this
		    }
		})



	/***/ },
	/* 89 */
	/***/ function(module, exports, __webpack_require__) {

		var propMap = __webpack_require__(23)
		var rsvg = /^\[object SVG\w*Element\]$/

		function attrUpdate(node, vnode) {
		    var attrs = vnode.changeAttr
		    if (attrs) {
		        for (var attrName in attrs) {
		            var val = attrs[attrName]
		            // switch
		            if (attrName === 'src' && window.chrome && node.tagName === 'EMBED') {
		                node[attrName] = val
		                var parent = node.parentNode //#525  chrome1-37下embed标签动态设置src不能发生请求
		                var comment = document.createComment('ms-src')
		                parent.replaceChild(comment, node)
		                parent.replaceChild(node, comment)
		            } else if (attrName.indexOf('data-') == 0) {
		                node.setAttribute(attrName, val)
		            } else {
		                var propName = propMap[attrName] || attrName
		                if (typeof node[propName] === 'boolean') {
		                    //布尔属性必须使用el.xxx = true|false方式设值
		                    //如果为false, IE全系列下相当于setAttribute(xxx,''),
		                    //会影响到样式,需要进一步处理
		                    node[propName] = !!val
		                }
		                if (val === false) {
		                    node.removeAttribute(attrName)
		                    continue
		                }

		                //SVG只能使用setAttribute(xxx, yyy), VML只能使用node.xxx = yyy ,
		                //HTML的固有属性必须node.xxx = yyy
		                var isInnate = rsvg.test(node) ? false : attrName in node.cloneNode(false)
		                if (isInnate) {
		                    node[propName] = val + ''
		                } else {
		                    node.setAttribute(attrName, val)
		                }
		            }
		        }
		    }
		    vnode.changeAttr = null
		}

		avalon.parseJSON = JSON.parse

		avalon.fn.attr = function (name, value) {
		    if (arguments.length === 2) {
		        this[0].setAttribute(name, value)
		        return this
		    } else {
		        return this[0].getAttribute(name)
		    }
		}


		module.exports = attrUpdate

	/***/ },
	/* 90 */
	/***/ function(module, exports) {

		var root = avalon.root
		var camelize = avalon.camelize
		var cssHooks = avalon.cssHooks

		var prefixes = ['', '-webkit-', '-o-', '-moz-', '-ms-']
		var cssMap = {
		    'float': 'cssFloat'
		}

		avalon.cssNumber = avalon.oneObject('animationIterationCount,columnCount,order,flex,flexGrow,flexShrink,fillOpacity,fontWeight,lineHeight,opacity,orphans,widows,zIndex,zoom')

		avalon.cssName = function (name, host, camelCase) {
		    if (cssMap[name]) {
		        return cssMap[name]
		    }
		    host = host || root.style
		    for (var i = 0, n = prefixes.length; i < n; i++) {
		        camelCase = camelize(prefixes[i] + name)
		        if (camelCase in host) {
		            return (cssMap[name] = camelCase)
		        }
		    }
		    return null
		}


		avalon.fn.css = function (name, value) {
		    if (avalon.isPlainObject(name)) {
		        for (var i in name) {
		            avalon.css(this, i, name[i])
		        }
		    } else {
		        var ret = avalon.css(this, name, value)
		    }
		    return ret !== void 0 ? ret : this
		}

		avalon.fn.position = function () {
		    var offsetParent, offset,
		            elem = this[0],
		            parentOffset = {
		                top: 0,
		                left: 0
		            }
		    if (!elem) {
		        return parentOffset
		    }
		    if (this.css("position") === "fixed") {
		        offset = elem.getBoundingClientRect()
		    } else {
		        offsetParent = this.offsetParent() //得到真正的offsetParent
		        offset = this.offset() // 得到正确的offsetParent
		        if (offsetParent[0].tagName !== "HTML") {
		            parentOffset = offsetParent.offset()
		        }
		        parentOffset.top += avalon.css(offsetParent[0], "borderTopWidth", true)
		        parentOffset.left += avalon.css(offsetParent[0], "borderLeftWidth", true)

		        // Subtract offsetParent scroll positions
		        parentOffset.top -= offsetParent.scrollTop()
		        parentOffset.left -= offsetParent.scrollLeft()
		    }
		    return {
		        top: offset.top - parentOffset.top - avalon.css(elem, "marginTop", true),
		        left: offset.left - parentOffset.left - avalon.css(elem, "marginLeft", true)
		    }
		}
		avalon.fn.offsetParent = function () {
		    var offsetParent = this[0].offsetParent
		    while (offsetParent && avalon.css(offsetParent, "position") === "static") {
		        offsetParent = offsetParent.offsetParent
		    }
		    return avalon(offsetParent || root)
		}


		cssHooks["@:set"] = function (node, name, value) {
		    node.style[name] = value
		}

		cssHooks["@:get"] = function (node, name) {
		    if (!node || !node.style) {
		        throw new Error("getComputedStyle要求传入一个节点 " + node)
		    }
		    var ret, computed = getComputedStyle(node)
		    if (computed) {
		        ret = name === "filter" ? computed.getPropertyValue(name) : computed[name]
		        if (ret === "") {
		            ret = node.style[name] //其他浏览器需要我们手动取内联样式
		        }
		    }
		    return ret
		}
		cssHooks["opacity:get"] = function (node) {
		    var ret = cssHooks["@:get"](node, "opacity")
		    return ret === "" ? "1" : ret
		}

		"top,left".replace(avalon.rword, function (name) {
		    cssHooks[name + ":get"] = function (node) {
		        var computed = cssHooks["@:get"](node, name)
		        return /px$/.test(computed) ? computed :
		                avalon(node).position()[name] + "px"
		    }
		})

		var cssShow = {
		    position: "absolute",
		    visibility: "hidden",
		    display: "block"
		}
		var rdisplayswap = /^(none|table(?!-c[ea]).+)/

		function showHidden(node, array) {
		    //http://www.cnblogs.com/rubylouvre/archive/2012/10/27/2742529.html
		    if (node.offsetWidth <= 0) { //opera.offsetWidth可能小于0
		        var styles = getComputedStyle(node, null)
		        if (rdisplayswap.test(styles["display"])) {
		            var obj = {
		                node: node
		            }
		            for (var name in cssShow) {
		                obj[name] = styles[name]
		                node.style[name] = cssShow[name]
		            }
		            array.push(obj)
		        }
		        var parent = node.parentNode
		        if (parent && parent.nodeType === 1) {
		            showHidden(parent, array)
		        }
		    }
		}

		avalon.each({
		    Width: "width",
		    Height: "height"
		}, function (name, method) {
		    var clientProp = "client" + name,
		            scrollProp = "scroll" + name,
		            offsetProp = "offset" + name
		    cssHooks[method + ":get"] = function (node, which, override) {
		        var boxSizing = -4
		        if (typeof override === "number") {
		            boxSizing = override
		        }
		        which = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"]
		        var ret = node[offsetProp] // border-box 0
		        if (boxSizing === 2) { // margin-box 2
		            return ret + avalon.css(node, "margin" + which[0], true) + avalon.css(node, "margin" + which[1], true)
		        }
		        if (boxSizing < 0) { // padding-box  -2
		            ret = ret - avalon.css(node, "border" + which[0] + "Width", true) - avalon.css(node, "border" + which[1] + "Width", true)
		        }
		        if (boxSizing === -4) { // content-box -4
		            ret = ret - avalon.css(node, "padding" + which[0], true) - avalon.css(node, "padding" + which[1], true)
		        }
		        return ret
		    }
		    cssHooks[method + "&get"] = function (node) {
		        var hidden = []
		        showHidden(node, hidden)
		        var val = cssHooks[method + ":get"](node)
		        for (var i = 0, obj; obj = hidden[i++]; ) {
		            node = obj.node
		            for (var n in obj) {
		                if (typeof obj[n] === "string") {
		                    node.style[n] = obj[n]
		                }
		            }
		        }
		        return val
		    }
		    avalon.fn[method] = function (value) { //会忽视其display
		        var node = this[0]
		        if (arguments.length === 0) {
		            if (node.setTimeout) { //取得窗口尺寸,IE9后可以用node.innerWidth /innerHeight代替
		                return node["inner" + name]
		            }
		            if (node.nodeType === 9) { //取得页面尺寸
		                var doc = node.documentElement
		                //FF chrome    html.scrollHeight< body.scrollHeight
		                //IE 标准模式 : html.scrollHeight> body.scrollHeight
		                //IE 怪异模式 : html.scrollHeight 最大等于可视窗口多一点？
		                return Math.max(node.body[scrollProp], doc[scrollProp], node.body[offsetProp], doc[offsetProp], doc[clientProp])
		            }
		            return cssHooks[method + "&get"](node)
		        } else {
		            return this.css(method, value)
		        }
		    }
		    avalon.fn["inner" + name] = function () {
		        return cssHooks[method + ":get"](this[0], void 0, -2)
		    }
		    avalon.fn["outer" + name] = function (includeMargin) {
		        return cssHooks[method + ":get"](this[0], void 0, includeMargin === true ? 2 : 0)
		    }
		})

		avalon.fn.offset = function () { //取得距离页面左右角的坐标
		    var node = this[0]
		    try {
		        var rect = node.getBoundingClientRect()
		        // Make sure element is not hidden (display: none) or disconnected
		        // https://github.com/jquery/jquery/pull/2043/files#r23981494
		        if (rect.width || rect.height || node.getClientRects().length) {
		            var doc = node.ownerDocument
		            var root = doc.documentElement
		            var win = doc.defaultView
		            return {
		                top: rect.top + win.pageYOffset - root.clientTop,
		                left: rect.left + win.pageXOffset - root.clientLeft
		            }
		        }
		    } catch (e) {
		        return {
		            left: 0,
		            top: 0
		        }
		    }
		}

		avalon.each({
		    scrollLeft: "pageXOffset",
		    scrollTop: "pageYOffset"
		}, function (method, prop) {
		    avalon.fn[method] = function (val) {
		        var node = this[0] || {},
		                win = getWindow(node),
		                top = method === "scrollTop"
		        if (!arguments.length) {
		            return win ? win[prop] : node[method]
		        } else {
		            if (win) {
		                win.scrollTo(!top ? val : win[prop], top ? val : win[prop])
		            } else {
		                node[method] = val
		            }
		        }
		    }
		})

		function getWindow(node) {
		    return node.window || node.defaultView || false
		}

	/***/ },
	/* 91 */
	/***/ function(module, exports) {

		function getValType(elem) {
		    var ret = elem.tagName.toLowerCase()
		    return ret === 'input' && /checkbox|radio/.test(elem.type) ? 'checked' : ret
		}
		var valHooks = {
		    'select:get': function self(node, ret, index, singleton) {
		        var nodes = node.children, value,
		                getter = valHooks['option:get']
		        index = ret ? index : node.selectedIndex
		        singleton = ret ? singleton : node.type === 'select-one' || index < 0
		        ret = ret || []
		        for (var i = 0, el; el = nodes[i++]; ) {
		            if (!el.disabled) {
		                switch (el.nodeName.toLowerCase()) {
		                    case 'option':
		                        if ((el.selected || el.index === index)) {
		                            value = el.value
		                            if (singleton) {
		                                return value
		                            } else {
		                                ret.push(value)
		                            }
		                        }
		                        break
		                    case 'optgroup':
		                        value = self(el, ret, index, singleton)
		                        if (typeof value === 'string') {
		                            return value
		                        }
		                        break
		                }
		            }
		        }
		        return singleton ? null : ret
		    },
		    'select:set': function (node, values, optionSet) {
		        values = [].concat(values) //强制转换为数组
		        for (var i = 0, el; el = node.options[i++]; ) {
		            if ((el.selected = values.indexOf(el.value) > -1)) {
		                optionSet = true
		            }
		        }
		        if (!optionSet) {
		            node.selectedIndex = -1
		        }
		    }
		}

		avalon.fn.val = function (value) {
		    var node = this[0]
		    if (node && node.nodeType === 1) {
		        var get = arguments.length === 0
		        var access = get ? ':get' : ':set'
		        var fn = valHooks[getValType(node) + access]
		        if (fn) {
		            var val = fn(node, value)
		        } else if (get) {
		            return (node.value || '').replace(/\r/g, '')
		        } else {
		            node.value = value
		        }
		    }
		    return get ? val : this
		}

	/***/ },
	/* 92 */
	/***/ function(module, exports, __webpack_require__) {

		var document = avalon.document
		var window = avalon.window
		var root = avalon.root

		var getShortID = __webpack_require__(6).getShortID
		var canBubbleUp = __webpack_require__(31)

		var eventHooks = avalon.eventHooks
		/*绑定事件*/
		avalon.bind = function (elem, type, fn) {
		    if (elem.nodeType === 1) {
		        var value = elem.getAttribute('avalon-events') || ''
		        //如果是使用ms-on-*绑定的回调,其uuid格式为e12122324,
		        //如果是使用bind方法绑定的回调,其uuid格式为_12
		        var uuid = getShortID(fn)
		        var hook = eventHooks[type]
		        if (hook) {
		            type = hook.type || type
		            if (hook.fix) {
		                fn = hook.fix(elem, fn)
		                fn.uuid = uuid
		            }
		        }
		        var key = type + ':' + uuid
		        avalon.eventListeners[fn.uuid] = fn
		        if (value.indexOf(type + ':') === -1) {//同一种事件只绑定一次
		            if (canBubbleUp[type] || focusBlur[type]) {
		                delegateEvent(type)
		            } else {
		                nativeBind(elem, type, dispatch)
		            }
		        }
		        var keys = value.split(',')
		        if (keys[0] === '') {
		            keys.shift()
		        }
		        if (keys.indexOf(key) === -1) {
		            keys.push(key)
		            elem.setAttribute('avalon-events', keys.join(','))
		            //将令牌放进avalon-events属性中
		        }

		    } else {
		        nativeBind(elem, type, fn)
		    }
		    return fn //兼容之前的版本
		}

		avalon.unbind = function (elem, type, fn) {
		    if (elem.nodeType === 1) {
		        var value = elem.getAttribute('avalon-events') || ''
		        switch (arguments.length) {
		            case 1:
		                nativeUnBind(elem, type, dispatch)
		                elem.removeAttribute('avalon-events')
		                break
		            case 2:
		                value = value.split(',').filter(function (str) {
		                    return str.indexOf(type + ':') === -1
		                }).join(',')

		                elem.setAttribute('avalon-events', value)
		                break
		            default:
		                var search = type + ':' + fn.uuid
		                value = value.split(',').filter(function (str) {
		                    return str !== search
		                }).join(',')
		                elem.setAttribute('avalon-events', value)
		                delete avalon.eventListeners[fn.uuid]
		                break
		        }
		    } else {
		        nativeUnBind(elem, type, fn)
		    }
		}

		var typeRegExp = {}
		function collectHandlers(elem, type, handlers) {
		    var value = elem.getAttribute('avalon-events')
		    if (value && (elem.disabled !== true || type !== 'click')) {
		        var uuids = []
		        var reg = typeRegExp[type] || (typeRegExp[type] = new RegExp('\\b' + type + '\\:([^,\\s]+)', 'g'))
		        value.replace(reg, function (a, b) {
		            uuids.push(b)
		            return a
		        })
		        if (uuids.length) {
		            handlers.push({
		                elem: elem,
		                uuids: uuids
		            })
		        }
		    }
		    elem = elem.parentNode
		    var g = avalon.gestureEvents || {}
		    if (elem && elem.getAttribute && (canBubbleUp[type] || g[type])) {
		        collectHandlers(elem, type, handlers)
		    }

		}

		var rhandleHasVm = /^e/
		var stopImmediate = false

		function dispatch(event) {
		    event = new avEvent(event)
		    var type = event.type
		    var elem = event.target
		    var handlers = []
		    collectHandlers(elem, type, handlers)
		    var i = 0, j, uuid, handler
		    while ((handler = handlers[i++]) && !event.cancelBubble) {
		        var host = event.currentTarget = handler.elem
		        j = 0
		        while ((uuid = handler.uuids[ j++ ])) {
		            if (stopImmediate) {
		                stopImmediate = false
		                break
		            }
		            var fn = avalon.eventListeners[uuid]
		            if (fn) {
		                var vm = rhandleHasVm.test(uuid) ? handler.elem._ms_context_ : 0
		                if (vm && vm.$hashcode === false) {
		                    return avalon.unbind(elem, type, fn)
		                }
		                var ret = fn.call(vm || elem, event, host._ms_local)
		                if (ret === false) {
		                    event.preventDefault()
		                    event.stopPropagation()
		                }
		            }
		        }
		    }
		}
		var focusBlur = {
		    focus: true,
		    blur: true
		}

		var nativeBind = function (el, type, fn, capture) {
		    el.addEventListener(type, fn, capture)
		}
		var nativeUnBind = function (el, type, fn) {
		    el.removeEventListener(type, fn)
		}

		function delegateEvent(type) {
		    var value = root.getAttribute('delegate-events') || ''
		    if (value.indexOf(type) === -1) {
		        var arr = value.match(avalon.rword) || []
		        arr.push(type)
		        root.setAttribute('delegate-events', arr.join(','))
		        nativeBind(root, type, dispatch, !!focusBlur[type])
		    }
		}

		var rconstant = /^[A-Z_]+$/
		function avEvent(event) {
		    if (event.originalEvent) {
		        return this
		    }
		    for (var i in event) {
		        if (!rconstant.test(i) && typeof event[i] !== 'function') {
		            this[i] = event[i]
		        }
		    }
		    this.timeStamp = new Date() - 0
		    this.originalEvent = event
		}
		avEvent.prototype = {
		    preventDefault: function () {
		        var e = this.originalEvent || {}
		        this.returnValue = false
		        if (e.preventDefault) {
		            e.preventDefault()
		        }
		    },
		    stopPropagation: function () {
		        var e = this.originalEvent || {}
		        this.cancelBubble = true
		        if (e.stopPropagation) {
		            e.stopPropagation()
		        }
		    },
		    stopImmediatePropagation: function () {
		        stopImmediate = true
		        this.stopPropagation()
		    },
		    toString: function () {
		        return '[object Event]'//#1619
		    }
		}

		avalon.fireDom = function (elem, type, opts) {
		    var hackEvent = document.createEvent('Events')
		    hackEvent.initEvent(type, true, true)
		    avalon.shadowCopy(hackEvent, opts)
		    elem.dispatchEvent(hackEvent)
		}

		var eventHooks = avalon.eventHooks
		//针对firefox, chrome修正mouseenter, mouseleave(chrome30+)
		if (!('onmouseenter' in root)) {
		    avalon.each({
		        mouseenter: 'mouseover',
		        mouseleave: 'mouseout'
		    }, function (origType, fixType) {
		        eventHooks[origType] = {
		            type: fixType,
		            fn: function (elem, fn) {
		                return function (e) {
		                    var t = e.relatedTarget
		                    if (!t || (t !== elem && !(elem.compareDocumentPosition(t) & 16))) {
		                        delete e.type
		                        e.type = origType
		                        return fn.call(this, e)
		                    }
		                }
		            }
		        }
		    })
		}
		//针对IE9+, w3c修正animationend
		avalon.each({
		    AnimationEvent: 'animationend',
		    WebKitAnimationEvent: 'webkitAnimationEnd'
		}, function (construct, fixType) {
		    if (window[construct] && !eventHooks.animationend) {
		        eventHooks.animationend = {
		            type: fixType
		        }
		    }
		})

		if (document.onmousewheel === void 0) {
		    /* IE6-11 chrome mousewheel wheelDetla 下 -120 上 120
		     firefox DOMMouseScroll detail 下3 上-3
		     firefox wheel detlaY 下3 上-3
		     IE9-11 wheel deltaY 下40 上-40
		     chrome wheel deltaY 下100 上-100 */
		    eventHooks.mousewheel = {
		        type: 'wheel',
		        fn: function (elem, fn) {
		            return function (e) {
		                e.wheelDeltaY = e.wheelDelta = e.deltaY > 0 ? -120 : 120
		                e.wheelDeltaX = 0
		                Object.defineProperty(e, 'type', {
		                    value: 'mousewheel'
		                })
		                fn.call(this, e)
		            }
		        }
		    }
		}

		avalon.fn.bind = function (type, fn, phase) {
		    if (this[0]) { //此方法不会链
		        return avalon.bind(this[0], type, fn, phase)
		    }
		}

		avalon.fn.unbind = function (type, fn, phase) {
		    if (this[0]) {
		        avalon.unbind(this[0], type, fn, phase)
		    }
		    return this
		}


	/***/ },
	/* 93 */
	/***/ function(module, exports, __webpack_require__) {

		var scan = __webpack_require__(33)
		scan.htmlfy = function(el){
		    return el.outerHTML
		}

		var document = avalon.document
		var window = avalon.window

		var readyList = [], isReady
		var fireReady = function (fn) {
		    isReady = true

		    while (fn = readyList.shift()) {
		        fn(avalon)
		    }
		}

		if (document.readyState === 'complete') {
		    setTimeout(fireReady) //如果在domReady之外加载
		} else {
		    document.addEventListener('DOMContentLoaded', fireReady)
		}

		avalon.bind(window, 'load', fireReady)

		avalon.ready = function (fn) {
		    if (!isReady) {
		        readyList.push(fn)
		    } else {
		        fn(avalon)
		    }
		}

		avalon.ready(function(){
		    scan(document.body)
		})


	/***/ },
	/* 94 */
	/***/ function(module, exports, __webpack_require__) {

		__webpack_require__(36)
		__webpack_require__(38)
		//处理属性样式
		__webpack_require__(95)
		__webpack_require__(41)
		__webpack_require__(42)
		//处理内容
		__webpack_require__(43)
		__webpack_require__(44)
		__webpack_require__(45)
		//需要用到事件的
		__webpack_require__(46)
		__webpack_require__(47)
		__webpack_require__(96)
		__webpack_require__(57)
		__webpack_require__(58)

		//处理逻辑
		__webpack_require__(59)
		__webpack_require__(60)

		__webpack_require__(61)
		__webpack_require__(64)

	/***/ },
	/* 95 */
	/***/ function(module, exports, __webpack_require__) {

		
		var attrUpdate = __webpack_require__(89)
		var update = __webpack_require__(37)

		avalon.directive('attr', {
		    diff: function (copy, src, name) {
		        var a = copy[name]
		        var p = src[name]
		        if (a && typeof a === 'object') {
		            if (Array.isArray(a)) {//转换成对象
		                a = avalon.mix.apply({}, a)
		            }
		            if (copy === src || typeof p !== 'object') {//如果一开始为空
		                src.changeAttr = src[name] = a
		            } else {
		                var patch = {}
		                var hasChange = false
		                for (var i in a) {//diff差异点
		                    if (a[i] !== p[i]) {
		                        hasChange = true
		                        patch[i] = a[i]
		                    }
		                }
		                if (hasChange) {
		                    src[name] = a
		                    src.changeAttr = patch
		                }
		            }
		            if (src.changeAttr) {
		                update(src, this.update)
		            }
		        }
		        if (copy !== src) {
		            delete copy[name]//释放内存
		        }
		    },
		    //dom, vnode
		    update: attrUpdate
		})


	/***/ },
	/* 96 */
	/***/ function(module, exports, __webpack_require__) {

		
		var update = __webpack_require__(37)
		var evaluatorPool = __webpack_require__(49)
		var stringify = __webpack_require__(50)

		var rchangeFilter = /\|\s*change\b/
		var rcheckedType = /^(?:checkbox|radio)$/
		var rdebounceFilter = /\|\s*debounce(?:\(([^)]+)\))?/
		var updateModelByEvent = __webpack_require__(97)
		var updateModelByValue = __webpack_require__(54)
		var updateModel = __webpack_require__(52)
		var updateView = __webpack_require__(98)
		var addValidateField = __webpack_require__(56)


		avalon.directive('duplex', {
		    priority: 2000,
		    parse: function (copy, src, binding) {
		        var expr = binding.expr
		        var etype = src.props.type
		        //处理数据转换器
		        var parser = binding.param, dtype
		        var isChecked = false
		        parser = parser ? parser.split('-').map(function (a) {
		            if (a === 'checked') {
		                isChecked = true
		            }
		            return a
		        }) : []

		        if (rcheckedType.test(etype) && isChecked) {
		            //如果是radio, checkbox,判定用户使用了checked格式函数没有
		            parser = []
		            dtype = 'radio'
		        }

		        if (!/input|textarea|select/.test(src.type)) {
		            if ('contenteditable' in src.props) {
		                dtype = 'contenteditable'
		            }
		        } else if (!dtype) {
		            dtype = src.type === 'select' ? 'select' :
		                    etype === 'checkbox' ? 'checkbox' :
		                    etype === 'radio' ? 'radio' :
		                    'input'
		        }
		        var isChanged = false, debounceTime = 0
		        //判定是否使用了 change debounce 过滤器
		        if (dtype === 'input' || dtype === 'contenteditable') {
		            var isString = true
		            if (rchangeFilter.test(expr)) {
		                isChanged = true
		            }
		            if (!isChanged) {
		                var match = expr.match(rdebounceFilter)
		                if (match) {
		                    debounceTime = parseInt(match[1], 10) || 300
		                }
		            }
		        }


		        var changed = copy.props['data-duplex-changed']
		        copy.parser = avalon.quote(parser + "")
		        copy.modelValue = '(' + avalon.parseExpr(binding, 'duplex') + ')(__vmodel__)'// 输出原始数据
		        var format = evaluatorPool.get('duplex:format:' + expr)

		        copy.duplexData = stringify({
		            type: dtype, //这个决定绑定什么事件
		            vmodel: '__vmodel__',
		            isChecked: isChecked,
		            isString: !!isString,
		            isChanged: isChanged, //这个决定同步的频数
		            debounceTime: debounceTime, //这个决定同步的频数
		            format: format || 'function(vm, a){return a}',
		            set: evaluatorPool.get('duplex:set:' + expr),
		            callback: changed ? avalon.parseExpr(changed, 'on') : 'avalon.noop'
		        })

		    },
		    diff: function (copy, src) {

		        if (copy === src || !src.duplexData) {
		            //第一次为原始虚拟DOM添加duplexData
		            var data = src.duplexData = copy.duplexData
		            data.parser = copy.parser ? copy.parser.split(',') : []
		            data.parse = parseValue
		            var curValue = copy.modelValue
		        } else {
		            data = src.duplexData
		            var curValue = copy.modelValue
		            var preValue = data.modelValue
		            //#1502
		            copy.duplexData = 0
		            if (!Array.isArray(curValue) &&
		                    curValue === preValue) {
		                return
		            }
		        }
		       
		        if (data.isString) {//输出到页面时要格式化
		           var value = data.parse(curValue)
		           if(value !== curValue){
		               data.set(data.vmodel, value)
		               return
		           }
		           curValue = value
		        }
		        data.modelValue = curValue
		        if (data.isString) {//输出到页面时要格式化
		            value = data.format(data.vmodel, curValue + '')
		            if(value !== curValue+''){
		                data.set(data.vmodel, value)
		                return
		            }
		            curValue = value
		        }
		        data.viewValue = curValue
		        update(src, this.update, 'afterChange')


		    },
		    update: function (dom, vdom) {
		        if (dom && dom.nodeType === 1) {
		            if (!dom.__ms_duplex__) {
		                dom.__ms_duplex__ = vdom.duplexData
		                updateModelByEvent(dom, vdom)
		            }
		            var data = dom.__ms_duplex__

		            data.dom = dom
		            addValidateField(dom, vdom)
		            if (data.isString
		                    && !avalon.msie
		                    && updateModelByValue === false
		                    && !dom.valueHijack) {
		                //chrome 42及以下版本需要这个hack

		                dom.valueHijack = updateModel
		                var intervalID = setInterval(function () {
		                    if (!avalon.contains(avalon.root, dom)) {
		                        clearInterval(intervalID)
		                    } else {
		                        dom.valueHijack()
		                    }
		                }, 30)
		            }

		            updateView[data.type].call(data)
		            if (dom.caret) {
		                var pos = data.caretPos
		                pos && data.setCaret(dom, pos.start, pos.end)
		                data.caretPos = null
		            }

		        }

		    }
		})

		function parseValue(val) {
		    for (var i = 0, k; k = this.parser[i++]; ) {
		        var fn = avalon.parsers[k]
		        if (fn) {
		            val = fn.call(this, val)
		        }
		    }
		    return val
		}

		/*
		 vm[ms-duplex]  →  原始modelValue →  格式化后比较   →   输出页面
		 ↑                                                ↓
		 比较modelValue  ←  parsed后得到modelValue  ← 格式化后比较 ←  原始viewValue
		 */

	/***/ },
	/* 97 */
	/***/ function(module, exports, __webpack_require__) {

		/* 
		 * 通过绑定事件同步vmodel
		 * 总共有三种方式同步视图
		 * 1. 各种事件 input, change, click, propertychange, keydown...
		 * 2. value属性重写
		 * 3. 定时器轮询
		 */
		var updateModel = __webpack_require__(52)
		var markID = __webpack_require__(6).getShortID
		var msie = avalon.msie
		var window = avalon.window
		var document = avalon.document

		function updateModelByEvent(node, vnode) {
		    var events = {}
		    var data = vnode.duplexData
		    data.update = updateModel
		    //添加需要监听的事件
		    switch (data.type) {
		        case 'radio':
		        case 'checkbox':
		            events.click = updateModel
		            break
		        case 'select':
		            events.change = updateModel
		            break
		        case 'contenteditable':
		            if (data.isChanged) {
		                events.blur = updateModel
		            } else {

		                if (window.webkitURL) {
		                    // http://code.metager.de/source/xref/WebKit/LayoutTests/fast/events/
		                    // https://bugs.webkit.org/show_bug.cgi?id=110742
		                    events.webkitEditableContentChanged = updateModel
		                } else if (window.MutationEvent) {
		                    events.DOMCharacterDataModified = updateModel
		                }
		                events.input = updateModel
		            }
		            break
		        case 'input':
		            if (data.isChanged) {
		                events.change = updateModel
		            } else {
		                events.input = updateModel

		                //https://github.com/RubyLouvre/avalon/issues/1368#issuecomment-220503284
		                events.compositionstart = openComposition
		                events.compositionend = closeComposition
		                if(avalon.msie){
		                   events.keyup = updateModelKeyDown 
		                }
		            }
		            break
		    }

		    if (/password|text/.test(vnode.props.type)) {
		        events.focus = openCaret //判定是否使用光标修正功能 
		        events.blur = closeCaret
		        data.getCaret = getCaret
		        data.setCaret = setCaret
		    }

		    for (var name in events) {
		        avalon.bind(node, name, events[name])
		    }
		}


		function updateModelKeyDown(e) {
		    var key = e.keyCode
		    // ignore
		    //    command            modifiers                   arrows
		    if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
		        return
		    updateModel.call(this, e)
		}

		function openCaret() {
		    this.caret = true
		}

		function closeCaret() {
		    this.caret = false
		}
		function openComposition() {
		    this.composing = true
		}

		function closeComposition(e) {
		    this.composing = false
		    var elem = this
		    setTimeout(function(){
		       updateModel.call(elem, e) 
		    }, 0)
		    
		}


		markID(openCaret)
		markID(closeCaret)
		markID(openComposition)
		markID(closeComposition)
		markID(updateModelKeyDown)
		markID(updateModel)


		function getCaret(field) {
		    var start = NaN
		    if (field.setSelectionRange) {
		        start = field.selectionStart
		    }
		    return start
		}

		function setCaret(field, pos) {
		    if (!field.value || field.readOnly)
		        return
		    field.selectionStart = pos
		    field.selectionEnd = pos
		}


		module.exports = updateModelByEvent

	/***/ },
	/* 98 */
	/***/ function(module, exports) {

		
		var updateView = {
		    input: function () {//处理单个value值处理
		        this.dom.value = this.viewValue
		    },
		    radio: function () {//处理单个checked属性
		        var checked
		        if (this.isChecked) {
		            checked = !!this.viewValue
		        } else {
		            checked = this.viewValue + '' === this.dom.value
		        }
		        var dom = this.dom

		        dom.checked = checked

		    },
		    checkbox: function () {//处理多个checked属性
		        var checked = false
		        var dom = this.dom
		        var value = dom.value
		        for (var i = 0; i < this.modelValue.length; i++) {
		            var el = this.modelValue[i]
		            if (el + '' === value) {
		                checked = true
		            }
		        }
		        dom.checked = checked
		    },
		    select: function () {//处理子级的selected属性
		        var a = Array.isArray(this.viewValue) ?
		                this.viewValue.map(String) : this.viewValue + ''
		        avalon(this.dom).val(a)
		    },
		    contenteditable: function () {//处理单个innerHTML
		        this.dom.innerHTML = this.viewValue
		        this.update.call(this.dom)
		    }
		}

		module.exports = updateView


	/***/ },
	/* 99 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * ------------------------------------------------------------
		 * avalon基于纯净的Object.defineProperties的vm工厂 
		 * masterFactory,slaveFactory,mediatorFactory, ArrayFactory
		 * ------------------------------------------------------------
		 */
		var share = __webpack_require__(100)
		var isSkip = share.isSkip
		var $$midway = share.$$midway
		var $$skipArray = share.$$skipArray
		delete $$skipArray.$accessors
		delete $$skipArray.__data__
		delete $$skipArray.__proxy__
		delete $$skipArray.__const__

		var makeAccessor = share.makeAccessor
		var initViewModel = share.initViewModel
		var modelAccessor = share.modelAccessor
		var modelAdaptor = share.modelAdaptor
		var makeHashCode = avalon.makeHashCode


		//一个vm总是为Observer的实例
		function Observer() {
		}
		function masterFactory(definition, heirloom, options) {

		    var $skipArray = {}
		    if (definition.$skipArray) {//收集所有不可监听属性
		        $skipArray = avalon.oneObject(definition.$skipArray)
		        delete definition.$skipArray
		    }

		    var keys = {}
		    options = options || {}
		    heirloom = heirloom || {}
		    var accessors = {}
		    var hashcode = makeHashCode('$')
		    var pathname = options.pathname || ''
		    options.id = options.id || hashcode
		    options.hashcode = hashcode
		    var key, sid, spath
		    for (key in definition) {
		        if ($$skipArray[key])
		            continue
		        var val = keys[key] = definition[key]
		        if (!isSkip(key, val, $skipArray)) {
		            sid = options.id + '.' + key
		            spath = pathname ? pathname + '.' + key : key
		            accessors[key] = makeAccessor(sid, spath, heirloom)
		        }
		    }

		    accessors.$model = modelAccessor
		    var $vmodel = new Observer()
		    Object.defineProperties($vmodel, accessors)

		    for (key in keys) {
		        //对普通监控属性或访问器属性进行赋值
		        $vmodel[key] = keys[key]
		        //删除系统属性
		        if (key in $skipArray) {
		            delete keys[key]
		        } else {
		            keys[key] = true
		        }
		    }
		    initViewModel($vmodel, heirloom, keys, accessors, options)

		    return $vmodel
		}
		$$midway.masterFactory = masterFactory

		var empty = {}
		function slaveFactory(before, after, heirloom, options) {
		    var keys = {}
		    var accessors = {}
		    var pathname = options.pathname
		    heirloom = heirloom || {}
		    var key, sid, spath
		    for (key in after) {
		        if ($$skipArray[key])
		            continue
		        keys[key] = after[key]
		        if (!isSkip(key, after[key], empty)) {
		            var accessor = Object.getOwnPropertyDescriptor(before, key)
		            if (accessor && accessor.get) {
		                accessors[key] = accessor
		            } else {
		                sid = options.id + '.' + key
		                spath = pathname ? pathname + '.' + key : key
		                accessors[key] = makeAccessor(sid, spath, heirloom)
		            }
		        }
		    }
		    for (key in before) {
		        delete before[key]
		    }

		    options.hashcode = before.$hashcode || makeHashCode('$')
		    accessors.$model = modelAccessor
		    var $vmodel = before
		    Object.defineProperties($vmodel, accessors)

		    for (key in keys) {
		        if (!accessors[key]) {//添加不可监控的属性
		            $vmodel[key] = keys[key]
		        }
		        keys[key] = true
		    }
		    initViewModel($vmodel, heirloom, keys, accessors, options)

		    return $vmodel
		}

		$$midway.slaveFactory = slaveFactory

		function mediatorFactory(before, after) {
		    var keys = {}
		    var accessors = {}
		    var unresolve = {}
		    var heirloom = {}
		    var $skipArray = {}
		    var arr = avalon.slice(arguments)
		    var config
		    var configName
		    var isWidget = typeof this === 'function' && this.isWidget
		    for (var i = 0; i < arr.length; i++) {
		        var obj = arr[i]
		        //收集所有键值对及访问器属性
		        for (var key in obj) {
		            var cur = obj[key]
		            if (key === '$skipArray') {
		                if (Array.isArray(cur)) {
		                    cur.forEach(function (el) {
		                        $skipArray[el] = 1
		                    })
		                }
		                continue
		            }
		            if (isWidget && arr.indexOf(cur) !== -1) {//处理配置对象
		                config = cur
		                configName = key
		                continue
		            }
		            var accessor = Object.getOwnPropertyDescriptor(obj, key)

		            keys[key] = cur

		            if (accessors[key] && avalon.isObject(cur)) {//处理子vm
		                delete accessors[key]
		            }
		            if (accessor.set) {
		                accessors[key] = accessor
		            } else if (typeof keys[key] !== 'function') {
		                unresolve[key] = 1
		            }
		        }
		    }
		    if (typeof this === 'function') {
		        this(keys, unresolve)
		    }
		    for (key in unresolve) {
		        if ($$skipArray[key] || accessors[key])
		            continue
		        if (!isSkip(key, keys[key], $skipArray)) {
		            accessors[key] = makeAccessor(before.$id + '.' + key, key, heirloom)
		            accessors[key].set(keys[key])
		        }
		    }

		    var $vmodel = new Observer()
		    Object.defineProperties($vmodel, accessors)

		    for (key in keys) {
		        if (!accessors[key]) {//添加不可监控的属性
		            $vmodel[key] = keys[key]
		        }
		        if (isWidget && config && accessors[key] && config.hasOwnProperty(key)) {
		            var GET = accessors[key].get
		            if (!GET.$decompose) {
		                GET.$decompose = {}
		            }
		            GET.$decompose[configName + '.' + key] = $vmodel
		        }
		        keys[key] = true
		    }

		    initViewModel($vmodel, heirloom, keys, accessors, {
		        id: before.$id,
		        hashcode: makeHashCode("$"),
		        master: true
		    })

		    return $vmodel
		}

		$$midway.mediatorFactory = avalon.mediatorFactory = mediatorFactory

		var __array__ = share.__array__
		var ap = Array.prototype
		var _splice = ap.splice
		function notifySize(array, size) {
		    if (array.length !== size) {
		        array.notify('length', array.length, size, true)
		    }
		}

		__array__.removeAll = function (all) { //移除N个元素
		    var size = this.length
		    if (Array.isArray(all)) {
		        for (var i = this.length - 1; i >= 0; i--) {
		            if (all.indexOf(this[i]) !== -1) {
		                _splice.call(this, i, 1)
		            }
		        }
		    } else if (typeof all === 'function') {
		        for (i = this.length - 1; i >= 0; i--) {
		            var el = this[i]
		            if (all(el, i)) {
		                _splice.call(this, i, 1)
		            }
		        }
		    } else {
		        _splice.call(this, 0, this.length)

		    }

		    notifySize(this, size)
		    this.notify()
		}


		var __method__ = ['push', 'pop', 'shift', 'unshift', 'splice']
		__method__.forEach(function (method) {
		    var original = ap[method]
		    __array__[method] = function (a, b) {
		        // 继续尝试劫持数组元素的属性
		        var args = [], size = this.length
		        if (method === 'splice' && Object(this[0]) === this[0]) {
		            var old = this.slice(a, b)
		            var neo = ap.slice.call(arguments, 2)
		            var args = [a, b]
		            for (var j = 0, jn = neo.length; j < jn; j++) {
		                var item = old[j]
		                args[j + 2] = modelAdaptor(neo[j], item, (item && item.$events || {}), {
		                    id: this.$id + '.*',
		                    master: true
		                })
		            }
		        } else {
		            for (var i = 0, n = arguments.length; i < n; i++) {
		                args[i] = modelAdaptor(arguments[i], 0, {}, {
		                    id: this.$id + '.*',
		                    master: true
		                })
		            }
		        }

		        var result = original.apply(this, args)

		        notifySize(this, size)
		        this.notify()

		        return result
		    }
		})

		'sort,reverse'.replace(avalon.rword, function (method) {
		    __array__[method] = function () {
		        ap[method].apply(this, arguments)
		        this.notify()
		        return this
		    }
		})


		module.exports = avalon


	/***/ },
	/* 100 */
	/***/ function(module, exports, __webpack_require__) {

		var share = __webpack_require__(78)
		var initEvents = share.initEvents

		function toJson(val) {
		    var xtype = avalon.type(val)
		    if (xtype === 'array') {
		        var array = []
		        for (var i = 0; i < val.length; i++) {
		            array[i] = toJson(val[i])
		        }
		        return array
		    } else if (xtype === 'object') {
		        var obj = {}
		        for (i in val) {
		            if (val.hasOwnProperty(i)) {
		                var value = val[i]
		                obj[i] = value && value.nodeType ? value : toJson(value)
		            }
		        }
		        return obj
		    }
		    return val
		}

		function hideProperty(host, name, value) {
		    Object.defineProperty(host, name, {
		        value: value,
		        writable: true,
		        enumerable: false,
		        configurable: true
		    })
		}

		var modelAccessor = {
		    get: function () {
		        return toJson(this)
		    },
		    set: avalon.noop,
		    enumerable: false,
		    configurable: true
		}

		share.$$midway.hideProperty = hideProperty

		function initViewModel($vmodel, heirloom, keys, accessors, options) {

		    if (options.array) {
		        Object.defineProperty($vmodel, '$model', modelAccessor)
		    } else {
		        function hasOwnKey(key) {
		            return keys[key] === true
		        }
		        hideProperty($vmodel, 'hasOwnProperty', hasOwnKey)
		    }
		    hideProperty($vmodel, '$id', options.id)
		    hideProperty($vmodel, '$hashcode', options.hashcode)
		    hideProperty($vmodel, '$track', Object.keys(keys).sort().join(';;'))
		    if (options.master === true) {
		        hideProperty($vmodel, '$run', run)
		        hideProperty($vmodel, '$wait', wait)
		        hideProperty($vmodel, '$element', null)
		        hideProperty($vmodel, '$render', 0)
		        initEvents($vmodel, heirloom)
		    }
		}
		function wait() {
		    this.$events.$$wait$$ = true
		}

		function run() {
		    var host = this.$events
		    delete host.$$wait$$
		    if (host.$$dirty$$) {
		        delete host.$$dirty$$
		        avalon.rerenderStart = new Date
		        var id = this.$id
		        var dotIndex = id.indexOf('.')
		        if (dotIndex > 0) {
		            avalon.batch(id.slice(0, dotIndex))
		        } else {
		            avalon.batch(id)
		        }
		    }
		}

		share.$$midway.initViewModel = initViewModel

		var mixin = {
		    toJson: toJson,
		    initViewModel: initViewModel,
		    modelAccessor: modelAccessor
		}
		for (var i in share) {
		    mixin[i] = share[i]
		}

		module.exports = mixin


	/***/ },
	/* 101 */
	/***/ function(module, exports, __webpack_require__) {

		var ret = __webpack_require__(75)
		var fireDisposeHook = ret.fireDisposeHook
		var fireDisposeHooks = ret.fireDisposeHooks
		var fireDisposeHookDelay = ret.fireDisposeHookDelay

		//用于IE8+, firefox
		function byRewritePrototype() {
		    if (byRewritePrototype.execute) {
		        return
		    }
		//https://www.web-tinker.com/article/20618.html?utm_source=tuicool&utm_medium=referral
		//IE6-8虽然暴露了Element.prototype,但无法重写已有的DOM API
		    byRewritePrototype.execute = true
		    var p = Node.prototype
		    function rewite(name, fn) {
		        var cb = p[name]
		        p[name] = function (a, b) {
		            return  fn.call(this, cb, a, b)
		        }
		    }
		    rewite('removeChild', function (fn, a, b) {
		        fn.call(this, a, b)
		        if (a.nodeType === 1) {
		            fireDisposeHookDelay(a)
		        }
		        return a
		    })

		    rewite('replaceChild', function (fn, a, b) {
		        fn.call(this, a, b)
		        if (a.nodeType === 1) {
		            fireDisposeHookDelay(a)
		        }
		        return a
		    })
		    //访问器属性需要用getOwnPropertyDescriptor处理
		    var ep = Element.prototype
		    function newSetter(html) {
		        var all = avalon.slice(this.getElementsByTagName('*'))
		        oldSetter.call(this, html)
		        fireDisposeHooks(all)
		    }
		    var obj = Object.getOwnPropertyDescriptor(ep, 'innerHTML')
		    var oldSetter = obj.set
		    obj.set = newSetter
		    Object.defineProperty(ep, 'innerHTML', obj)


		    rewite('appendChild', function (fn, a) {
		        fn.call(this, a)
		        if (a.nodeType === 1 && this.nodeType === 11) {
		            fireDisposeHookDelay(a)
		        }
		        return a
		    })

		    rewite('insertBefore', function (fn, a, b) {
		        fn.call(this, a, b)
		        if (a.nodeType === 1 && this.nodeType === 11) {
		            fireDisposeHookDelay(a)
		        }
		        return a
		    })
		}

		module.exports = function onComponentDispose(dom) {
		    byRewritePrototype(dom)
		}



	/***/ }
	/******/ ])
	});
	;

/***/ },
/* 26 */,
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(28);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(30)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./../../node_modules/less-loader/index.js!./core.less", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./../../node_modules/less-loader/index.js!./core.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(29)();
	// imports


	// module
	exports.push([module.id, "abbr,address,article,aside,audio,b,blockquote,body,body div,caption,cite,code,dd,del,details,dfn,dl,dt,em,fieldset,figure,footer,form,h1,h2,h3,h4,h5,h6,header,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,p,pre,q,samp,section,small,span,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,ul,var,video{margin:0;padding:0;border:0;font-size:100%;font-weight:400;vertical-align:baseline;background:transparent}article,aside,details,figure,footer,header,nav,section,summary{display:block}html{box-sizing:border-box}*,:after,:before{box-sizing:inherit}embed,img,object{max-width:100%}html{overflow-y:scroll}ul{list-style:none}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:'';content:none}a{margin:0;padding:0;font-size:100%;vertical-align:baseline;background:transparent}del{text-decoration:line-through}abbr[title],dfn[title]{border-bottom:1px dotted #000;cursor:help}table{border-collapse:separate;border-spacing:0}th{font-weight:700;vertical-align:bottom}td{font-weight:400;vertical-align:top}hr{display:block;height:1px;border:0;border-top:1px solid #ccc;margin:1em 0;padding:0}input,select{vertical-align:middle}pre{white-space:pre;white-space:pre-wrap;white-space:pre-line;word-wrap:break-word}input[type=radio]{vertical-align:text-bottom}input[type=checkbox]{vertical-align:bottom}.ie7 input[type=checkbox]{vertical-align:baseline}.ie6 input{vertical-align:text-bottom}input,select,textarea{font:99% sans-serif}table{font-size:inherit;font:100%}small{font-size:85%}strong{font-weight:700}td,td img{vertical-align:top}sub,sup{font-size:75%;line-height:0;position:relative}sup{top:-.5em}sub{bottom:-.25em}code,kbd,pre,samp{font-family:monospace,sans-serif}.clickable,button,input[type=button],input[type=file],input[type=submit],label{cursor:pointer}button,input,select,textarea{margin:0}button,input[type=button]{width:auto;overflow:visible}.ie7 img{-ms-interpolation-mode:bicubic}.clearfix:after{content:\" \";display:block;clear:both}input,textarea{outline:none}textarea{resize:none}button{border:none}body,html{-webkit-tap-highlight-color:rgba(0,0,0,0);-moz-tap-highlight-color:transparent;-ms-tap-highlight-color:transparent;tap-highlight-color:transparent}.ms-controller{visibility:hidden}::-webkit-scrollbar{background:transparent}::-webkit-scrollbar-thumb:vertical,::-webkit-scrollbar-track-piece{background:transparent;-webkit-border-radius:6px}::-webkit-scrollbar-thumb:vertical{height:5px}::-webkit-scrollbar-thumb:horizontal{width:5px;background:transparent;-webkit-border-radius:6px}@font-face{font-family:iconfont;src:url('http://localhost:3000/_fonts/iconfont.eot');src:url('http://localhost:3000/_fonts/iconfont.eot#iefix') format('embedded-opentype'),url('http://localhost:3000/_fonts/iconfont.woff') format('woff'),url('http://localhost:3000/_fonts/iconfont.ttf') format('truetype'),url('http://localhost:3000/_fonts/iconfont.svg#iconfont') format('svg')}.ico{font-style:normal;font-family:iconfont}.ico-sch:before{content:'\\E60A'}.ico-sch2:before{content:'\\E606'}.ico-del:before{content:'\\E619'}.ico-home:before{content:'\\E6D5'}.ico-category:before{content:'\\E659'}.ico-me:before{content:'\\E706'}.g-doc,body,html{background-color:#f0f0f0}.g-bd{padding-top:4.69333333rem;padding-bottom:3.84rem}.scroll{overflow:auto;-webkit-overflow-scrolling:touch}.u-ipt{font-size:1.024rem;padding:.46933333rem .42666667rem;border:none;border-radius:.21333333rem;background-color:#fff}.u-btn{text-decoration:none}.u-btn:active{-webkit-transition:all .3s ease;transition:all .3s ease;-webkit-transform:scale(1.1);transform:scale(1.1)}.u-btn.z-dis{color:#ccc;cursor:default}.u-btn-sm{width:4.69333333rem;height:1.536rem;line-height:1.536rem;font-size:.93866667rem}.u-btn-sm.u-btn-rds{border-radius:.17066667rem}.u-btn-c1{color:#e41b45}.m-mask{position:fixed;top:0;left:0;right:0;bottom:0;z-index:100;background-color:rgba(0,0,0,.5)}.m-mask.z-show{display:block}.m-mask.z-hide{display:none}.m-modal-tips{position:fixed;top:50%;left:50%;z-index:200;background-color:rgba(0,0,0,.8);border-radius:.42666667rem;color:#fff;padding:.42666667rem .85333333rem;text-align:center;font-size:1.024rem;line-height:1.5}.m-modal-tips.z-hide{display:none}.m-modal-tips.z-show{display:block}.m-navbar{position:fixed;left:0;right:0;bottom:0;z-index:100;background-color:#fff;height:3.84rem;border-top:1px solid #d4d4d4}.m-navbar .itm,.m-navbar .itm a,.m-navbar .lst{display:-webkit-box;display:-ms-flexbox;display:box;height:100%}.m-navbar .itm,.m-navbar .itm a{-webkit-box-flex:1;-ms-box-flex:1;-prefix-box-flex:1;box-flex:1;flex:1;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-orient:vertical;-moz-box-orient:vertical;-ms-flex-align:vertical;box-orient:vertical;width:100%;color:#2b2e37;font-size:.68266667rem;font-weight:700}.m-navbar .itm.z-crt,.m-navbar .itm.z-crt a,.m-navbar .itm:active,.m-navbar .itm:active a,.m-navbar .itm a.z-crt,.m-navbar .itm a.z-crt a,.m-navbar .itm a:active,.m-navbar .itm a:active a{color:#e31a44}.m-navbar .itm a{text-decoration:none}.m-navbar .itm .ico,.m-navbar .itm .txt{display:block}.m-navbar .itm .ico{font-size:1.36533333rem;height:1.70666667rem}.m-navbar .itm .ico-me,.m-navbar .itm .ico-sch2{font-size:1.70666667rem}.m-navbar .itm .txt{padding-top:.256rem}.m-schbar{position:fixed;top:0;left:0;right:0;z-index:100;background-color:#fff;padding:.68266667rem 1.28rem;-ms-flex-align:center}.m-schbar,.m-schbar .ipt{display:-webkit-box;display:-ms-flexbox;display:box;-webkit-box-align:center;align-items:center}.m-schbar .ipt{-webkit-box-flex:1;-ms-box-flex:1;-prefix-box-flex:1;box-flex:1;flex:1;-ms-flex-align:center;height:2.38933333rem;border:1px solid #dcdcdc;border-radius:1.19466667rem;overflow:hidden}.m-schbar .ipt .ico{color:#999}.m-schbar .ipt .ico-sch{width:2.56rem;line-height:1.36533333rem;overflow:hidden;font-size:1.70666667rem;margin:0 .42666667rem 0 .85333333rem}.m-schbar .ipt .ico-del{color:#cbcbcb;font-size:1.36533333rem;line-height:1.024rem;margin:0 .68266667rem}.m-schbar .ipt .u-ipt{display:-webkit-box;display:-ms-flexbox;display:box;-webkit-box-flex:1;-ms-box-flex:1;-prefix-box-flex:1;box-flex:1;flex:1;font-size:1.024rem;color:#333}.m-schbar .u-btn-sch{text-align:center;color:#e71a45;margin-left:.85333333rem}.m-prolst>.lst>.itm{padding:1.28rem;margin-bottom:.85333333rem;background-color:#fff}.m-prolst>.lst>.itm,.m-prolst>.lst>.itm>.mn{display:-webkit-box;display:-ms-flexbox;display:box}.m-prolst>.lst>.itm>.mn{-webkit-box-flex:1;-ms-box-flex:1;-prefix-box-flex:1;box-flex:1;flex:1;-webkit-box-orient:vertical;-moz-box-orient:vertical;-ms-flex-align:vertical;box-orient:vertical;padding-left:.85333333rem}.m-prolst>.lst>.itm .poster{width:7.25333333rem;height:9.81333333rem;background-repeat:no-repeat;background-position:50%;background-size:cover}.m-prolst>.lst>.itm .tt{line-height:1.70666667rem;color:#333;font-size:1.10933333rem;padding-bottom:1.36533333rem}.m-prolst>.lst>.itm .info{color:#928fa4;font-size:.93866667rem;line-height:1.5}.m-prolst>.lst>.itm .info .row{padding-bottom:.21333333rem}.m-banner{padding-top:532.8%;background:url('http://localhost:3000/_images/m-page-bg@3x.jpg') no-repeat top;background-size:contain;overflow:hidden}.m-banner .tt{height:0;overflow:hidden}.m-banner .u-btn-share{position:fixed;top:1.024rem;right:1.19466667rem;width:2.56rem;height:2.13333333rem;line-height:426.624rem;overflow:hidden;background:url('http://localhost:3000/_images/u-btn-share@3x.png') no-repeat 50%;background-size:contain}.m-what .tt,.m-what .txt{height:0;overflow:hidden}.m-what .swiper-container{position:absolute;top:36.352rem;left:2.304rem;width:27.22133333rem;height:18.176rem;overflow:hidden}.m-what .swiper-slide{background-repeat:no-repeat;background-position:50%;background-size:cover}.m-join .tt,.m-join .txt{height:0;overflow:hidden}.m-join .u-btn-join{position:absolute;top:81.70666667rem;left:12.20266667rem;width:7.552rem;height:2.38933333rem;line-height:426.624rem;overflow:hidden;background:url('http://localhost:3000/_images/u-btn-join@3x.png') no-repeat top;background-size:contain}.m-coupon .lst,.m-coupon .tt,.m-coupon .txt{height:0;overflow:hidden}.m-coupon .coupon{position:absolute;top:105.344rem;left:50%;width:13.01333333rem;margin-left:-6.50666667rem}.m-coupon .coupon img{display:block;width:100%}.m-free .lst,.m-free .tt{height:0;overflow:hidden}.m-free .link{position:absolute;top:159.488rem;left:3.24266667rem;width:9.81333333rem;height:1.70666667rem}.m-free .u-btn-want{position:absolute;top:148.52266667rem;left:10.88rem;width:10.496rem;height:3.328rem;line-height:426.624rem;overflow:hidden;background:url('http://localhost:3000/_images/u-btn-want@3x.png') no-repeat top;background-size:contain}.m-modal-form{text-align:center}.m-modal-form .bd{-webkit-box-orient:vertical;-moz-box-orient:vertical;-ms-flex-align:vertical;box-orient:vertical;padding:.93866667rem 1.96266667rem}.m-modal-form .bd,.m-modal-form .row{display:-webkit-box;display:-ms-flexbox;display:box}.m-modal-form .row{-webkit-box-flex:1;-ms-box-flex:1;-prefix-box-flex:1;box-flex:1;flex:1;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:100%;padding-bottom:.64rem}.m-modal-form .row .u-btn-code{margin:0 0 0 .512rem;width:5.12rem;height:1.96266667rem;line-height:1.96266667rem;box-shadow:none;border-radius:.21333333rem;font-size:.85333333rem}.m-modal-form .txt{font-size:1.10933333rem}.m-modal-form .txt-1{font-size:1.024rem;line-height:1.536rem}.m-modal-form .u-btn{display:block;margin:0 auto}.m-modal-form .u-ipt{display:-webkit-box;display:-ms-flexbox;display:box;-webkit-box-flex:1;-ms-box-flex:1;-prefix-box-flex:1;box-flex:1;flex:1;width:100%}.m-modal-info .bd{padding:.85333333rem 1.10933333rem;font-size:.93866667rem;line-height:1.36533333rem}", ""]);

	// exports


/***/ },
/* 29 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}

	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}

	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}

	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}

	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;

		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		var blob = new Blob([css], { type: "text/css" });

		var oldSrc = linkElement.href;

		linkElement.href = URL.createObjectURL(blob);

		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// utils

	var _stringify = __webpack_require__(32);

	var _stringify2 = _interopRequireDefault(_stringify);

	var _typeof2 = __webpack_require__(35);

	var _typeof3 = _interopRequireDefault(_typeof2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _global = __webpack_require__(102);

	var _module = {};

	_module = window.utils = {
	  // 浏览器
	  browser: {
	    // 特性检测
	    detection: function detection(key) {
	      var features = {
	        localstorage: window.localStorage ? true : false
	      };

	      if (key) {
	        return features[key];
	      } else {
	        return features;
	      }
	    }
	  },
	  // cookie
	  cookie: {
	    // 设置 cookie
	    set: function set(key, value, path, times) {
	      var date = new Date(),
	          time = times || 30 * 24 * 60 * 60 * 1000; // 榛樿瀛樺偍30澶�

	      date.setTime(date.getTime() + time);

	      document.cookie = key + '=' + encodeURI(value) + ';expires=' + date.toGMTString() + (path ? ';path=' + path : ';path=/');
	    },
	    // 获取 cookie
	    get: function get(key) {
	      var cookies = document.cookie.split('; ');

	      for (var i = 0, len = cookies.length; i < cookies.length; i++) {
	        var tmp = cookies[i].split('=');

	        if (tmp[0] == key) {
	          return decodeURI(tmp[1]);
	        }
	      }
	    },
	    // 删除 cookie
	    remove: function remove(key) {
	      this.set(key, 1, -1);
	    },
	    // 更新 cookie
	    update: function update(key, val) {
	      this.remove(key);

	      this.set(key, val);
	    }
	  },
	  /* 深度克隆 */
	  clone: function clone(source) {
	    var str,
	        target = source.constructor === Array ? [] : {};

	    if ((typeof source === 'undefined' ? 'undefined' : (0, _typeof3.default)(source)) !== 'object') {
	      return;
	    } else if (window.JSON) {
	      str = (0, _stringify2.default)(source), // 系列化对象
	      target = JSON.parse(str); // 还原
	    } else {
	      for (var key in source) {
	        target[key] = (0, _typeof3.default)(source[key]) === 'object' ? this.clone(source[key]) : source[key];
	      }
	    }

	    return target;
	  },

	  /**
	   *  空间解析
	   *
	   *  通过 damai.mobile 解析成 json 对象 { damai: { mobile: {} } }
	   */
	  provide: function provide(namespace, context, val) {
	    var spaces = namespace.split('.'),
	        pointer = {},
	        result = context || {};

	    pointer = this.clone(result);

	    for (var i = 0, len = spaces.length; i < len; i++) {
	      if (pointer[spaces[i]]) {
	        pointer = pointer[spaces[i]];
	      } else {
	        pointer = pointer[spaces[i]] = {};
	      }

	      if (i === 0) {
	        result[spaces[i]] = pointer;
	      }
	    }

	    return result;
	  },
	  // 本地存储
	  storage: {
	    set: function set(key, val) {
	      var space = [_global.config.namespace, key].join('.');
	      var local = window.localStorage[space];

	      if (local === undefined) window.localStorage[space] = (0, _stringify2.default)({});

	      window.localStorage[space] = (0, _stringify2.default)(val);
	    },
	    get: function get(key) {
	      var space = [_global.config.namespace, key].join('.');
	      var local = window.localStorage[space];

	      if (local === undefined) return undefined;

	      return JSON.parse(local);
	    }
	  }
	};

	module.exports = _module;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(33), __esModule: true };

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(34)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 34 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _iterator = __webpack_require__(36);

	var _iterator2 = _interopRequireDefault(_iterator);

	var _symbol = __webpack_require__(86);

	var _symbol2 = _interopRequireDefault(_symbol);

	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(37), __esModule: true };

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(38);
	__webpack_require__(81);
	module.exports = __webpack_require__(85).f('iterator');

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(39)(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(42)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(40)
	  , defined   = __webpack_require__(41);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 40 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 41 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(43)
	  , $export        = __webpack_require__(44)
	  , redefine       = __webpack_require__(58)
	  , hide           = __webpack_require__(48)
	  , has            = __webpack_require__(59)
	  , Iterators      = __webpack_require__(60)
	  , $iterCreate    = __webpack_require__(61)
	  , setToStringTag = __webpack_require__(77)
	  , getPrototypeOf = __webpack_require__(79)
	  , ITERATOR       = __webpack_require__(78)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';

	var returnThis = function(){ return this; };

	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(45)
	  , core      = __webpack_require__(34)
	  , ctx       = __webpack_require__(46)
	  , hide      = __webpack_require__(48)
	  , PROTOTYPE = 'prototype';

	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 45 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(47);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 47 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(49)
	  , createDesc = __webpack_require__(57);
	module.exports = __webpack_require__(53) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(50)
	  , IE8_DOM_DEFINE = __webpack_require__(52)
	  , toPrimitive    = __webpack_require__(56)
	  , dP             = Object.defineProperty;

	exports.f = __webpack_require__(53) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(51);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(53) && !__webpack_require__(54)(function(){
	  return Object.defineProperty(__webpack_require__(55)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(54)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(51)
	  , document = __webpack_require__(45).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(51);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 57 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(48);

/***/ },
/* 59 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 60 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(62)
	  , descriptor     = __webpack_require__(57)
	  , setToStringTag = __webpack_require__(77)
	  , IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(48)(IteratorPrototype, __webpack_require__(78)('iterator'), function(){ return this; });

	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(50)
	  , dPs         = __webpack_require__(63)
	  , enumBugKeys = __webpack_require__(75)
	  , IE_PROTO    = __webpack_require__(72)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(55)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(76).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};

	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(49)
	  , anObject = __webpack_require__(50)
	  , getKeys  = __webpack_require__(64);

	module.exports = __webpack_require__(53) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(65)
	  , enumBugKeys = __webpack_require__(75);

	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(59)
	  , toIObject    = __webpack_require__(66)
	  , arrayIndexOf = __webpack_require__(69)(false)
	  , IE_PROTO     = __webpack_require__(72)('IE_PROTO');

	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(67)
	  , defined = __webpack_require__(41);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(68);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 68 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(66)
	  , toLength  = __webpack_require__(70)
	  , toIndex   = __webpack_require__(71);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(40)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(40)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(73)('keys')
	  , uid    = __webpack_require__(74);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(45)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 74 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 75 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(45).document && document.documentElement;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(49).f
	  , has = __webpack_require__(59)
	  , TAG = __webpack_require__(78)('toStringTag');

	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(73)('wks')
	  , uid        = __webpack_require__(74)
	  , Symbol     = __webpack_require__(45).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};

	$exports.store = store;

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(59)
	  , toObject    = __webpack_require__(80)
	  , IE_PROTO    = __webpack_require__(72)('IE_PROTO')
	  , ObjectProto = Object.prototype;

	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(41);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(82);
	var global        = __webpack_require__(45)
	  , hide          = __webpack_require__(48)
	  , Iterators     = __webpack_require__(60)
	  , TO_STRING_TAG = __webpack_require__(78)('toStringTag');

	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(83)
	  , step             = __webpack_require__(84)
	  , Iterators        = __webpack_require__(60)
	  , toIObject        = __webpack_require__(66);

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(42)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(78);

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(87), __esModule: true };

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(88);
	__webpack_require__(99);
	__webpack_require__(100);
	__webpack_require__(101);
	module.exports = __webpack_require__(34).Symbol;

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(45)
	  , has            = __webpack_require__(59)
	  , DESCRIPTORS    = __webpack_require__(53)
	  , $export        = __webpack_require__(44)
	  , redefine       = __webpack_require__(58)
	  , META           = __webpack_require__(89).KEY
	  , $fails         = __webpack_require__(54)
	  , shared         = __webpack_require__(73)
	  , setToStringTag = __webpack_require__(77)
	  , uid            = __webpack_require__(74)
	  , wks            = __webpack_require__(78)
	  , wksExt         = __webpack_require__(85)
	  , wksDefine      = __webpack_require__(90)
	  , keyOf          = __webpack_require__(91)
	  , enumKeys       = __webpack_require__(92)
	  , isArray        = __webpack_require__(95)
	  , anObject       = __webpack_require__(50)
	  , toIObject      = __webpack_require__(66)
	  , toPrimitive    = __webpack_require__(56)
	  , createDesc     = __webpack_require__(57)
	  , _create        = __webpack_require__(62)
	  , gOPNExt        = __webpack_require__(96)
	  , $GOPD          = __webpack_require__(98)
	  , $DP            = __webpack_require__(49)
	  , $keys          = __webpack_require__(64)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;

	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};

	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });

	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(97).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(94).f  = $propertyIsEnumerable;
	  __webpack_require__(93).f = $getOwnPropertySymbols;

	  if(DESCRIPTORS && !__webpack_require__(43)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});

	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(48)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(74)('meta')
	  , isObject = __webpack_require__(51)
	  , has      = __webpack_require__(59)
	  , setDesc  = __webpack_require__(49).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(54)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(45)
	  , core           = __webpack_require__(34)
	  , LIBRARY        = __webpack_require__(43)
	  , wksExt         = __webpack_require__(85)
	  , defineProperty = __webpack_require__(49).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(64)
	  , toIObject = __webpack_require__(66);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(64)
	  , gOPS    = __webpack_require__(93)
	  , pIE     = __webpack_require__(94);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 93 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 94 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(68);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(66)
	  , gOPN      = __webpack_require__(97).f
	  , toString  = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};

	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(65)
	  , hiddenKeys = __webpack_require__(75).concat('length', 'prototype');

	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(94)
	  , createDesc     = __webpack_require__(57)
	  , toIObject      = __webpack_require__(66)
	  , toPrimitive    = __webpack_require__(56)
	  , has            = __webpack_require__(59)
	  , IE8_DOM_DEFINE = __webpack_require__(52)
	  , gOPD           = Object.getOwnPropertyDescriptor;

	exports.f = __webpack_require__(53) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 99 */
/***/ function(module, exports) {

	

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(90)('asyncIterator');

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(90)('observable');

/***/ },
/* 102 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	  // 设置
	  config: {
	    // 命名空间
	    namespace: 'damai.mobile.overseas',
	    // 版本
	    version: '1.0.0'
	  }
	};

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _stringify = __webpack_require__(32);

	var _stringify2 = _interopRequireDefault(_stringify);

	__webpack_require__(104);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _global = __webpack_require__(102);
	var _utils = __webpack_require__(31);

	var store = new EventEmitter();
	var cache = {};

	var api = {
	  // 国际化
	  i18n: {
	    // 语言包
	    lang: 'http://localhost/damai/mobile/english/server/i18n/lang.php'
	    // lang: 'http://www.veli.com.cn/h5/damai/mobile/english/server/i18n/lang.php'
	  },
	  // 项目列表接口
	  item: {
	    getList: 'http://localhost/damai/mobile/english/server/model/getItemList.php'
	    // getList: 'http://www.veli.com.cn/h5/damai/mobile/english/server/model/getItemList.php'
	  }
	};

	/**
	 *
	 * 获取国际化包
	 *
	 * @return { Promise }
	 *
	 */

	store.fetchI18n = function () {
	  var url = api.i18n.lang;
	  var opt = {
	    method: 'POST',
	    // 跨域携带 cookie
	    credentials: 'include'
	  };

	  /**
	   *  本地 localStorage 数据结构
	   *
	   *  damai.mobile.overseas.i18n
	   *
	   *  {
	   *    "lang": "zh-CN",
	   *    "locals": {
	   *      "en": { ... }
	   *      "jp": { ... }
	   *    },
	   *    "version": "0.0.1"
	   *  }
	   *  
	   */

	  /**
	   *  判断是否支持本地存储
	   *
	   *  支持本地存储则 body 携带参数 localstorage = true, version = damai.mobile.overseas.i18n.version
	   *
	   *  本地版本号和服务器不一致会返回语言包 locals，此时更新本地缓存
	   *  版本号一致则不会返回语言包，直接从本地缓存读取
	   *
	   *  如果不支持本地存储，body 不携带任何参数，直接从服务器返回值中读取
	   *
	   */
	  var support_localstorage = _utils.browser.detection('localstorage');

	  var params = {};

	  params.localstorage = support_localstorage;

	  if (support_localstorage) {
	    var version = _utils.storage.get('i18n') ? _utils.storage.get('i18n').version : undefined;

	    params.version = version;
	  }

	  opt.body = (0, _stringify2.default)(params);

	  return fetch(url, opt).then(function (res) {
	    return res.json();
	  }).then(function (res) {
	    // 每次获取国际化包后设置 cookie 语言字段
	    // _utils.cookie.set('lang', res.lang)

	    var result = {};

	    if (support_localstorage) {
	      // 支持本地存储

	      // 如果版本号不一致，返回语言包，更新本地语言包
	      if (res.locals) {
	        _utils.storage.set('i18n', res);
	      }

	      result = _utils.storage.get('i18n').locals[res.lang];
	    } else {
	      // 不支持本地存储
	      result = res.locals[res.lang];
	    }

	    return result;
	  });
	};

	/**
	 *
	 * 获取项目列表接口
	 *
	 * @return { Promise }
	 *
	 */

	store.fetchItemList = function (key) {
	  var form = new FormData();

	  form.append('key', key);

	  var url = api.item.getList;
	  var opt = {
	    // 跨域携带 cookie
	    credentials: 'include'
	  };

	  return fetch(url, opt).then(function (res) {
	    return res.json();
	  }).then(function (res) {
	    if (res.status.code === 200) {
	      return res.data;
	    } else {
	      return res.message;
	    }
	  }).catch(function (e) {
	    return e;
	  });
	};

	module.exports = store;

/***/ },
/* 104 */
/***/ function(module, exports) {

	"use strict";

	(function () {
		function Event() {
			this.json = {}; // { abc: [fn, fn, fn], data: [], end: [...] }
		}

		Event.prototype.addListener = Event.prototype.on = function (name, fn) {
			if (!this.json[name]) {
				this.json[name] = [];
			}

			this.json[name].push(fn);
		};

		Event.prototype.emit = function (name, data) {
			var arr = [];

			arr = arr.concat.apply(arr, arguments);

			arr.shift();

			if (this.json[name]) {
				var fns = this.json[name];

				for (var i = 0; i < fns.length; i++) {
					fns[i].apply(null, arr);
				}
			}
		};

		if (window.EventEmitter === undefined) window.EventEmitter = Event;
	})();

/***/ }
/******/ ]);